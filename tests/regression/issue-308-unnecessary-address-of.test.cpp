/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// test-execution
// Tests: Issue #308 - Unnecessary & added to struct member arrays
// NOTE: Uses cpp mode because C++ has stricter type checking that catches this error
// The .hpp include triggers C++ mode automatically
#include "issue-308-unnecessary-address-of.hpp"

#include <stdint.h>

// Bug: The transpiler incorrectly added & to struct member arrays:
//   result.data becomes &result.data (wrong - array should decay to pointer)
//
// Note: Array element access (data[3]) to primitive parameters (u8) was never
// broken - it uses the pass-by-value path (isPrimitivePassByValue). This test
// validates both scenarios work correctly.
// Struct with array member to test the fix
typedef struct DataResult {
    uint8_t errorCode;
    uint8_t data[6];
    uint8_t dataLen;
} DataResult;

// ============================================================
// Scenario 1: Array element access (was never broken)
// Primitive parameters use pass-by-value path (isPrimitivePassByValue)
// Included to validate this continues to work correctly
// ============================================================
uint32_t sumFourBytes(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    return b0 + b1 + b2 + b3;
}

// ============================================================
// Scenario 2: Struct member array (THE FIX)
// Array should decay to pointer, NOT have & added
// ============================================================
uint8_t sumArray(const uint8_t arr[6], uint8_t len) {
    uint8_t sum = 0U;
    uint8_t i = 0U;
    while (i < len) {
        sum = sum + arr[i];
        i = i + 1U;
    }
    return sum;
}

int main(void) {
    uint8_t data[8] = {0};
    data[0] = 0x12U;
    data[1] = 0x34U;
    data[2] = 0x56U;
    data[3] = 0x78U;
    uint32_t sum = sumFourBytes(data[0U], data[1U], data[2U], data[3U]);
    if (sum != 276) return 1;
    DataResult result = {0};
    result.errorCode = 0U;
    result.data[0] = 10U;
    result.data[1] = 20U;
    result.data[2] = 30U;
    result.data[3] = 40U;
    result.data[4] = 50U;
    result.data[5] = 60U;
    result.dataLen = 6U;
    uint8_t total = sumArray(result.data, result.dataLen);
    if (total != 210) return 2;
    return 0;
}
