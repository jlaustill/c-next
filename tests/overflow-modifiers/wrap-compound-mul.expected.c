/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// test-coverage: 21.2-compound-mul
// Tests: wrap modifier with compound multiplication (*<-)
// Validates multiplication overflow wraps around
// ADR-044: Per-variable overflow semantics
int main(void) {
    uint8_t val8 = 20U;
    val8 = (uint8_t)(val8 * 20U);
    if (val8 != 144) return 1;
    val8 = 200U;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 144) return 2;
    val8 = 10U;
    val8 = (uint8_t)(val8 * 100U);
    if (val8 != 232) return 3;
    val8 = 10U;
    val8 = (uint8_t)(val8 * 10U);
    if (val8 != 100) return 4;
    val8 = 200U;
    val8 = (uint8_t)(val8 * 1U);
    if (val8 != 200) return 5;
    val8 = 200U;
    val8 = (uint8_t)(val8 * 0U);
    if (val8 != 0) return 6;
    val8 = 255U;
    val8 = (uint8_t)(val8 * 1U);
    if (val8 != 255) return 7;
    val8 = 128U;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 0) return 8;
    val8 = 64U;
    val8 = (uint8_t)(val8 * 8U);
    if (val8 != 0) return 9;
    uint16_t val16 = 300U;
    val16 = (uint16_t)(val16 * 300U);
    if (val16 != 24464) return 10;
    val16 = 100U;
    val16 = (uint16_t)(val16 * 100U);
    if (val16 != 10000) return 11;
    val16 = 256U;
    val16 = (uint16_t)(val16 * 256U);
    if (val16 != 0) return 12;
    val16 = 512U;
    val16 = (uint16_t)(val16 * 128U);
    if (val16 != 0) return 13;
    uint32_t val32 = 1000U;
    val32 *= 1000U;
    if (val32 != 1000000) return 14;
    val32 = 65536U;
    val32 *= 65536U;
    if (val32 != 0) return 15;
    val32 = 100000U;
    val32 *= 100000U;
    if (val32 != 1410065408) return 16;
    uint64_t val64 = 1000000000ULL;
    val64 *= 1000ULL;
    if (val64 != 1000000000000) return 17;
    val64 = 9223372036854775807ULL;
    val64 *= 1ULL;
    if (val64 != 9223372036854775807) return 18;
    int8_t vali8 = 16;
    vali8 = (int8_t)(vali8 * 16);
    if (vali8 != 0) return 19;
    vali8 = 10;
    vali8 = (int8_t)(vali8 * 20);
    if (vali8 != -56) return 20;
    vali8 = -10;
    vali8 = (int8_t)(vali8 * 5);
    if (vali8 != -50) return 21;
    vali8 = -16;
    vali8 = (int8_t)(vali8 * -16);
    if (vali8 != 0) return 22;
    vali8 = 5;
    vali8 = (int8_t)(vali8 * 5);
    if (vali8 != 25) return 23;
    int16_t vali16 = 200;
    vali16 = (int16_t)(vali16 * 200);
    if (vali16 != -25536) return 24;
    vali16 = 256;
    vali16 = (int16_t)(vali16 * 256);
    if (vali16 != 0) return 25;
    vali16 = 100;
    vali16 = (int16_t)(vali16 * 100);
    if (vali16 != 10000) return 26;
    int32_t vali32 = 1000;
    vali32 *= 1000;
    if (vali32 != 1000000) return 27;
    vali32 = 65536;
    vali32 *= 65536;
    if (vali32 != 0) return 28;
    int64_t vali64 = 1000000;
    vali64 *= 1000000;
    if (vali64 != 1000000000000) return 29;
    vali64 = 100;
    vali64 *= -1;
    if (vali64 != -100) return 30;
    val8 = 2U;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 4) return 31;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 8) return 32;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 16) return 33;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 32) return 34;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 64) return 35;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 128) return 36;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 0) return 37;
    val8 = (uint8_t)(val8 * 2U);
    if (val8 != 0) return 38;
    return 0;
}
