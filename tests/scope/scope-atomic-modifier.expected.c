/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// Test: ADR-016 + ADR-049 Atomic variables inside scopes
// Verifies that atomic modifier works correctly with integer types inside scope methods
// Tests: atomic variables accessed via this. accessor with compound assignment operators

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint16_t cnx_clamp_add_u16(uint16_t a, uint32_t b) {
    if (b > UINT16_MAX - a) return UINT16_MAX;
    return a + (uint16_t)b;
}

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint32_t b) {
    if (b > UINT8_MAX - a) return UINT8_MAX;
    return a + (uint8_t)b;
}

static inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint32_t b) {
    if (b >= (uint32_t)a) return 0;
    return a - (uint16_t)b;
}

static inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint32_t b) {
    if (b >= (uint32_t)a) return 0;
    return a - (uint8_t)b;
}

/* Scope: AtomicTest */
static uint8_t AtomicTest_counterU8 = 0;
static uint16_t AtomicTest_counterU16 = 0;
static uint32_t AtomicTest_counterU32 = 0;
static uint8_t AtomicTest_brightness = 100;
static uint16_t AtomicTest_position = 500;
static uint32_t AtomicTest_ticks = 0;

uint8_t AtomicTest_getCounterU8(void) {
    return AtomicTest_counterU8;
}

uint16_t AtomicTest_getCounterU16(void) {
    return AtomicTest_counterU16;
}

uint32_t AtomicTest_getCounterU32(void) {
    return AtomicTest_counterU32;
}

uint8_t AtomicTest_getBrightness(void) {
    return AtomicTest_brightness;
}

uint16_t AtomicTest_getPosition(void) {
    return AtomicTest_position;
}

uint32_t AtomicTest_getTicks(void) {
    return AtomicTest_ticks;
}

void AtomicTest_incrementU8(void) {
    AtomicTest_counterU8 = cnx_clamp_add_u8(AtomicTest_counterU8, 1);
}

void AtomicTest_incrementU16(void) {
    AtomicTest_counterU16 = cnx_clamp_add_u16(AtomicTest_counterU16, 1);
}

void AtomicTest_incrementU32(void) {
    AtomicTest_counterU32 = cnx_clamp_add_u32(AtomicTest_counterU32, 1);
}

void AtomicTest_decrementBrightness(void) {
    AtomicTest_brightness = cnx_clamp_sub_u8(AtomicTest_brightness, 10);
}

void AtomicTest_decrementPosition(void) {
    AtomicTest_position = cnx_clamp_sub_u16(AtomicTest_position, 50);
}

void AtomicTest_maskTicks(void) {
    AtomicTest_ticks &= 0xFFFF;
}

void AtomicTest_setTickFlag(void) {
    AtomicTest_ticks |= 0x80000000;
}

void AtomicTest_incrementAll(void) {
    AtomicTest_counterU8 = cnx_clamp_add_u8(AtomicTest_counterU8, 1);
    AtomicTest_counterU16 = cnx_clamp_add_u16(AtomicTest_counterU16, 1);
    AtomicTest_counterU32 = cnx_clamp_add_u32(AtomicTest_counterU32, 1);
    AtomicTest_ticks = cnx_clamp_add_u32(AtomicTest_ticks, 1);
}

int main(void) {
    AtomicTest_getCounterU8();
    AtomicTest_getCounterU16();
    AtomicTest_getCounterU32();
    AtomicTest_getBrightness();
    AtomicTest_getPosition();
    AtomicTest_getTicks();
    AtomicTest_incrementU8();
    AtomicTest_incrementU16();
    AtomicTest_incrementU32();
    AtomicTest_decrementBrightness();
    AtomicTest_decrementPosition();
    AtomicTest_maskTicks();
    AtomicTest_setTickFlag();
    AtomicTest_incrementAll();
}
