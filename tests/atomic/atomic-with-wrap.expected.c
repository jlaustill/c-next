/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// test-coverage: 20-atomic-with-wrap
// Tests: atomic combined with wrap modifier
// Note: Compilation test only - ARM-specific code

#include <stdint.h>
#include <cmsis_gcc.h>

// Atomic wrap variables - wrapping arithmetic
volatile uint8_t tick8 = 0;

volatile uint16_t tick16 = 0;

volatile uint32_t tick32 = 0;

// Wrap is useful for counters that should overflow
volatile uint8_t sequenceNumber = 0;

volatile uint16_t frameCounter = 0;

void incrementTicks(void) {
    do {
        uint8_t __old = __LDREXB(&tick8);
        uint8_t __new = __old + 1;
        if (__STREXB(__new, &tick8) == 0) break;
    } while (1);
    do {
        uint16_t __old = __LDREXH(&tick16);
        uint16_t __new = __old + 1;
        if (__STREXH(__new, &tick16) == 0) break;
    } while (1);
    do {
        uint32_t __old = __LDREXW(&tick32);
        uint32_t __new = __old + 1;
        if (__STREXW(__new, &tick32) == 0) break;
    } while (1);
}

void nextSequence(void) {
    do {
        uint8_t __old = __LDREXB(&sequenceNumber);
        uint8_t __new = __old + 1;
        if (__STREXB(__new, &sequenceNumber) == 0) break;
    } while (1);
}

void nextFrame(void) {
    do {
        uint16_t __old = __LDREXH(&frameCounter);
        uint16_t __new = __old + 1;
        if (__STREXH(__new, &frameCounter) == 0) break;
    } while (1);
}

void addToTicks(const uint32_t* delta) {
    do {
        uint32_t __old = __LDREXW(&tick32);
        uint32_t __new = __old + (*delta);
        if (__STREXW(__new, &tick32) == 0) break;
    } while (1);
}

void subtractFromTick8(const uint8_t* delta) {
    do {
        uint8_t __old = __LDREXB(&tick8);
        uint8_t __new = __old - (*delta);
        if (__STREXB(__new, &tick8) == 0) break;
    } while (1);
}

int main(void) {
    incrementTicks();
    nextSequence();
    nextFrame();
    addToTicks(&(uint32_t){100});
    subtractFromTick8(&(uint8_t){10});
}
