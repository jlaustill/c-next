/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-execution */
// Test i16 arithmetic operations
// Coverage: Section 4.1-4.5 for i16 type
int main(void) {
    int16_t a = 5000;
    int16_t b = 3000;
    int16_t sum = a + b;
    int16_t c = -5000;
    int16_t d = 3000;
    int16_t sum_neg = c + d;
    int16_t e = -4000;
    int16_t f = -2000;
    int16_t sum_both_neg = e + f;
    int16_t g = 5000;
    int16_t h = 3000;
    int16_t diff = g - h;
    int16_t i = 3000;
    int16_t j = 5000;
    int16_t diff_neg = i - j;
    int16_t k = -3000;
    int16_t l = 2000;
    int16_t diff_mixed = k - l;
    int16_t m = 100;
    int16_t n = 50;
    int16_t product = m * n;
    int16_t o = -100;
    int16_t p = 50;
    int16_t product_neg = o * p;
    int16_t q = -100;
    int16_t r = -50;
    int16_t product_pos = q * r;
    int16_t s = 6000;
    int16_t t = 3;
    int16_t quotient = s / t;
    int16_t u = -6000;
    int16_t v = 3;
    int16_t quotient_neg = u / v;
    int16_t w = 6000;
    int16_t x = -3;
    int16_t quotient_neg_div = w / x;
    int16_t y = 1023;
    int16_t z = 50;
    int16_t remainder = y % z;
    int16_t aa = -1023;
    int16_t bb = 50;
    int16_t remainder_neg = aa % bb;
    int16_t max_val = 32767;
    int16_t one = 1;
    int16_t max_minus_one = max_val - one;
    int16_t min_val = -32768;
    int16_t min_plus_one = min_val + one;
    if (sum == 8000 && sum_neg == -2000 && sum_both_neg == -6000) {
        if (diff == 2000 && diff_neg == -2000 && diff_mixed == -5000) {
            if (product == 5000 && product_neg == -5000 && product_pos == 5000) {
                if (quotient == 2000 && quotient_neg == -2000 && quotient_neg_div == -2000) {
                    if (remainder == 23 && remainder_neg == -23) {
                        if (max_minus_one == 32766 && min_plus_one == -32767) {
                            return 0;
                        }
                    }
                }
            }
        }
    }
    return 1;
}
