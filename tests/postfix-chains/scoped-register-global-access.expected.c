/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// Postfix Chain Test: Scoped Register Access from Global Context
// Tests: Accessing scoped registers, bitmaps, and methods from outside the scope
// Coverage: Section 13 - Scope Declaration (global context access)
// Extracted from: scoped-register-bitmap-chain.test.cnx.skip (valid portions only)
/* Bitmap: MotorFlags */
/* Fields:
 *   Running: bit 0 (1 bit)
 *   Direction: bit 1 (1 bit)
 *   Fault: bit 2 (1 bit)
 *   Mode: bits 3-5 (3 bits)
 *   Reserved: bits 6-7 (2 bits)
 */
typedef uint8_t MotorFlags;

/* Scope: MotorController */
uint32_t MotorController_DEFAULT_SPEED = 100;

/* Register: MotorController_MOTOR_REG @ 0x40002000 */
#define MotorController_MOTOR_REG_CTRL (*(volatile MotorFlags*)(0x40002000 + 0x00))
#define MotorController_MOTOR_REG_SPEED (*(volatile uint32_t*)(0x40002000 + 0x04))
#define MotorController_MOTOR_REG_STATUS (*(volatile uint32_t const *)(0x40002000 + 0x08))


void MotorController_start(void) {
    MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(0x7 << 3)) | ((3 & 0x7) << 3);
    MotorController_MOTOR_REG_SPEED = MotorController_DEFAULT_SPEED;
}

bool MotorController_isRunning(void) {
    return ((MotorController_MOTOR_REG_CTRL >> 0) & 1);
}

uint8_t MotorController_getMode(void) {
    return ((MotorController_MOTOR_REG_CTRL >> 3) & 0x7);
}

/* Scope: Board */

/* Register: Board_GPIO @ 0x40000000 */
#define Board_GPIO_DR (*(volatile uint32_t*)(0x40000000 + 0x00))
#define Board_GPIO_DR_SET (*(volatile uint32_t*)(0x40000000 + 0x84))

uint32_t Board_LED_BIT = 3;

void Board_toggleLed(void) {
    Board_GPIO_DR_SET = (1 << Board_LED_BIT);
}

int main(void) {
    MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(1 << 1)) | ((false ? 1 : 0) << 1);
    MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(0x7 << 3)) | ((5 & 0x7) << 3);
    bool running = ((MotorController_MOTOR_REG_CTRL >> 0) & 1);
    uint8_t mode = ((MotorController_MOTOR_REG_CTRL >> 3) & 0x7);
    Board_GPIO_DR = (Board_GPIO_DR & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    bool ledState = ((Board_GPIO_DR >> 3) & 1);
    MotorController_start();
    bool isRun = MotorController_isRunning();
    uint8_t currentMode = MotorController_getMode();
    Board_toggleLed();
    if (((MotorController_MOTOR_REG_CTRL >> 2) & 1) == true) {
        MotorController_MOTOR_REG_CTRL = (MotorController_MOTOR_REG_CTRL & ~(0x7 << 3)) | ((0 & 0x7) << 3);
    }
}
