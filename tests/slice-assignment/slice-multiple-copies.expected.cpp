/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// test-execution
// Tests: Multiple sequential slice assignments to same buffer
// Validates non-overlapping regions with compile-time constant offsets
// Simulates real-world buffer building with explicit layout
int main(void) {
    uint8_t buffer[256] = {0};
    uint32_t magic = 0x50415255;
    memcpy(&buffer[0], &magic, 4);
    uint16_t version = 0x0100;
    memcpy(&buffer[4], &version, 2);
    uint16_t length = 20;
    memcpy(&buffer[6], &length, 2);
    uint8_t flags = 0x0F;
    memcpy(&buffer[8], &flags, 1);
    uint8_t reserved = 0;
    memcpy(&buffer[9], &reserved, 1);
    memcpy(&buffer[10], &reserved, 1);
    memcpy(&buffer[11], &reserved, 1);
    uint64_t data = 0x0102030405060708;
    memcpy(&buffer[12], &data, 8);
    if (buffer[0] != 0x55) return 1;
    if (buffer[1] != 0x52) return 2;
    if (buffer[2] != 0x41) return 3;
    if (buffer[3] != 0x50) return 4;
    if (buffer[4] != 0x00) return 5;
    if (buffer[5] != 0x01) return 6;
    if (buffer[6] != 20) return 7;
    if (buffer[7] != 0) return 8;
    if (buffer[8] != 0x0F) return 9;
    if (buffer[9] != 0) return 10;
    if (buffer[10] != 0) return 11;
    if (buffer[11] != 0) return 12;
    if (buffer[12] != 0x08) return 13;
    if (buffer[13] != 0x07) return 14;
    if (buffer[14] != 0x06) return 15;
    if (buffer[15] != 0x05) return 16;
    if (buffer[16] != 0x04) return 17;
    if (buffer[17] != 0x03) return 18;
    if (buffer[18] != 0x02) return 19;
    if (buffer[19] != 0x01) return 20;
    uint32_t newMagic = 0x44434241;
    memcpy(&buffer[0], &newMagic, 4);
    if (buffer[0] != 0x41) return 21;
    if (buffer[1] != 0x42) return 22;
    if (buffer[2] != 0x43) return 23;
    if (buffer[3] != 0x44) return 24;
    if (buffer[4] != 0x00) return 25;
    if (buffer[8] != 0x0F) return 26;
    return 0;
}
