// test-execution
// Tests: mixed break and continue in nested loops
// Validates: break and continue work correctly together in complex scenarios
u32 main() {
   
// Test 1: Continue outer, break inner
    u32 outerProcessed <- 0;
    u32 innerBreaks <- 0;
    for (u32 i <- 0; i < 10; i +<- 1) {
        if (i % 2 = 0) {
            continue; // Skip even outer iterations
        }
        outerProcessed +<- 1;
        for (u32 j <- 0; j < 20; j +<- 1) {
            if (j = 5) {
                innerBreaks +<- 1;
                break;
            }
        }
    }

    // Odd numbers 0-9: 1,3,5,7,9 = 5
    if (outerProcessed != 5) return 1;
    if (innerBreaks != 5) return 2;

   
// Test 2: Break based on accumulated value from inner loop
    u32 totalSum <- 0;
    u32 outerBreakAt <- 0;
    for (u32 a <- 0; a < 100; a +<- 1) {
        u32 innerSum <- 0;
        for (u32 b <- 0; b < 10; b +<- 1) {
            innerSum +<- b;
        }
        totalSum +<- innerSum;
        if (totalSum >= 200) {
            outerBreakAt <- a;
            break;
        }
    }

    // innerSum = 0+1+2+3+4+5+6+7+8+9 = 45 per iteration
    // 45*5 = 225 >= 200, so breaks at a=4
    if (outerBreakAt != 4) return 3;
    if (totalSum != 225) return 4;

   
// Test 3: Continue inner, then potentially break outer
    u32 validCount <- 0;
    u32 breakOuter <- 0;
    for (u32 c <- 0; c < 10; c +<- 1) {
        u32 validInner <- 0;
        for (u32 d <- 0; d < 8; d +<- 1) {
            if (d % 2 = 0) {
                continue; // Skip even
            }
            validInner +<- 1;
        }
        validCount +<- validInner;
        if (validCount >= 12) {
            breakOuter <- c;
            break;
        }
    }

    // validInner = 4 per c (d=1,3,5,7)
    // After c=0: validCount=4, c=1: 8, c=2: 12 >= 12, break
    if (breakOuter != 2) return 5;
    if (validCount != 12) return 6;

   
// Test 4: Complex pattern - search matrix
    u32 foundRow <- 99;
    u32 foundCol <- 99;
    bool found <- false;
    for (u32 row <- 0; row < 5; row +<- 1) {
        if (found) {
            break;
        }
        for (u32 col <- 0; col < 5; col +<- 1) {
            // Looking for "position" (3, 2)
            if (row = 3 && col = 2) {
                foundRow <- row;
                foundCol <- col;
                found <- true;
                break;
            }
        }
    }
    if (foundRow != 3) return 7;
    if (foundCol != 2) return 8;
    if (!found) return 9;

   
// Test 5: Alternating break and continue behavior
    u32 processed <- 0;
    u32 broken <- 0;
    for (u32 e <- 0; e < 4; e +<- 1) {
        for (u32 f <- 0; f < 10; f +<- 1) {
            if (f % 3 = 0) {
                continue; // Skip multiples of 3
            }
            if (f >= 7) {
                broken +<- 1;
                break; // Break at 7 or higher
            }
            processed +<- 1;
        }
    }

    // For each e: f processes 1,2,4,5 (4 values) then breaks at 7
    // processed = 4 * 4 = 16
    if (processed != 16) return 10;

    // broken = 4 (once per outer loop)
    if (broken != 4) return 11;

    return 0;
}
