/**
 * Generated by C-Next Transpiler from: break-for-comprehensive.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-execution
// Tests: comprehensive break scenarios in for loops
// Validates: various break patterns and edge cases
int main(void) {
    uint32_t breakPoint = 0U;
    for (uint32_t i = 0; i < 100; i += 1) {
        if (i == 25) {
            breakPoint = i;
            break;
        }
    }
    if (breakPoint != 25) return 1;
    uint32_t counter = 0U;
    for (uint32_t j = 10; j < 50; j += 1) {
        counter = j;
        if (j == 20) {
            break;
        }
    }
    if (counter != 20) return 2;
    uint32_t sum = 0U;
    for (uint32_t k = 1; k <= 100; k += 1) {
        sum = cnx_clamp_add_u32(sum, k);
        if (sum >= 50) {
            break;
        }
    }
    if (sum != 55) return 3;
    uint32_t countdown = 0U;
    for (uint32_t m = 100; m > 0; m -= 1) {
        countdown = cnx_clamp_add_u32(countdown, 1U);
        if (m == 90) {
            break;
        }
    }
    if (countdown != 11) return 4;
    uint32_t evenSum = 0U;
    for (uint32_t n = 0; n < 100; n += 2) {
        evenSum = cnx_clamp_add_u32(evenSum, n);
        if (n == 10) {
            break;
        }
    }
    if (evenSum != 30) return 5;
    uint32_t found = 0U;
    for (uint32_t p = 0; p < 100; p += 1) {
        if (p > 10) {
            if (p % 7 == 0) {
                found = p;
                break;
            }
        }
    }
    if (found != 14) return 6;
    bool shouldBreak = false;
    uint32_t iterCount = 0U;
    for (uint32_t q = 0; q < 50; q += 1) {
        iterCount = cnx_clamp_add_u32(iterCount, 1U);
        if (q == 15) {
            shouldBreak = true;
        }
        if (shouldBreak) {
            break;
        }
    }
    if (iterCount != 16) return 7;
    uint32_t emptyCount = 0U;
    for (uint32_t r = 0; r < 100; r += 1) {
        emptyCount = cnx_clamp_add_u32(emptyCount, 1U);
        if (r == 0) {
            break;
        }
    }
    if (emptyCount != 1) return 8;
    return 0;
}
