/**
 * Header Generator
 * Generates C header (.h) files from C-Next source
 */

import ISymbol from '../types/ISymbol.js';
import ESymbolKind from '../types/ESymbolKind.js';
import ESourceLanguage from '../types/ESourceLanguage.js';
import SymbolTable from '../symbols/SymbolTable.js';

/**
 * Maps C-Next types to C types
 */
const TYPE_MAP: Record<string, string> = {
    'u8': 'uint8_t',
    'u16': 'uint16_t',
    'u32': 'uint32_t',
    'u64': 'uint64_t',
    'i8': 'int8_t',
    'i16': 'int16_t',
    'i32': 'int32_t',
    'i64': 'int64_t',
    'f32': 'float',
    'f64': 'double',
    'bool': 'bool',
    'void': 'void',
    'ISR': 'ISR',  // ADR-040: Interrupt Service Routine function pointer
};

/**
 * Options for header generation
 */
interface IHeaderOptions {
    /** Guard prefix (default: derived from filename) */
    guardPrefix?: string;

    /** Include system headers in the output */
    includeSystemHeaders?: boolean;

    /** Only generate declarations for exported symbols */
    exportedOnly?: boolean;
}

/**
 * Generates C header files from symbol information
 */
class HeaderGenerator {
    /**
     * Generate a header file from symbols
     */
    generate(
        symbols: ISymbol[],
        filename: string,
        options: IHeaderOptions = {}
    ): string {
        const lines: string[] = [];
        const guard = this.makeGuard(filename, options.guardPrefix);

        // Header guard
        lines.push(`#ifndef ${guard}`);
        lines.push(`#define ${guard}`);
        lines.push('');

        // Header comment
        lines.push('/**');
        lines.push(' * Generated by C-Next Transpiler');
        lines.push(' * Header file for cross-language interoperability');
        lines.push(' */');
        lines.push('');

        // System includes
        if (options.includeSystemHeaders !== false) {
            lines.push('#include <stdint.h>');
            lines.push('#include <stdbool.h>');
            lines.push('');
        }

        // C++ compatibility
        lines.push('#ifdef __cplusplus');
        lines.push('extern "C" {');
        lines.push('#endif');
        lines.push('');

        // Filter symbols
        const exportedSymbols = options.exportedOnly
            ? symbols.filter(s => s.isExported)
            : symbols;

        // Group symbols by kind
        const structs = exportedSymbols.filter(s => s.kind === ESymbolKind.Struct);
        const classes = exportedSymbols.filter(s => s.kind === ESymbolKind.Class);
        const functions = exportedSymbols.filter(s => s.kind === ESymbolKind.Function);
        const variables = exportedSymbols.filter(s => s.kind === ESymbolKind.Variable);
        const enums = exportedSymbols.filter(s => s.kind === ESymbolKind.Enum);
        const types = exportedSymbols.filter(s => s.kind === ESymbolKind.Type);

        // Forward declarations for structs
        if (structs.length > 0 || classes.length > 0) {
            lines.push('/* Forward declarations */');
            for (const sym of structs) {
                lines.push(`typedef struct ${sym.name} ${sym.name};`);
            }
            for (const sym of classes) {
                // Classes become typedefs to structs
                lines.push(`typedef struct ${sym.name} ${sym.name};`);
            }
            lines.push('');
        }

        // Enum declarations
        if (enums.length > 0) {
            lines.push('/* Enumerations */');
            for (const sym of enums) {
                // For now, just forward declare - full definition would require enum values
                lines.push(`/* Enum: ${sym.name} (see implementation for values) */`);
            }
            lines.push('');
        }

        // Type aliases
        if (types.length > 0) {
            lines.push('/* Type aliases */');
            for (const sym of types) {
                if (sym.type) {
                    const cType = this.mapType(sym.type);
                    lines.push(`typedef ${cType} ${sym.name};`);
                }
            }
            lines.push('');
        }

        // Extern variable declarations
        if (variables.length > 0) {
            lines.push('/* External variables */');
            for (const sym of variables) {
                const cType = sym.type ? this.mapType(sym.type) : 'int';
                lines.push(`extern ${cType} ${sym.name};`);
            }
            lines.push('');
        }

        // Function prototypes
        if (functions.length > 0) {
            lines.push('/* Function prototypes */');
            for (const sym of functions) {
                const proto = this.generateFunctionPrototype(sym);
                if (proto) {
                    lines.push(proto);
                }
            }
            lines.push('');
        }

        // C++ compatibility end
        lines.push('#ifdef __cplusplus');
        lines.push('}');
        lines.push('#endif');
        lines.push('');

        // End header guard
        lines.push(`#endif /* ${guard} */`);
        lines.push('');

        return lines.join('\n');
    }

    /**
     * Generate header from a symbol table, filtering by source file
     */
    generateFromSymbolTable(
        symbolTable: SymbolTable,
        sourceFile: string,
        options: IHeaderOptions = {}
    ): string {
        const symbols = symbolTable.getSymbolsByFile(sourceFile);
        const basename = sourceFile.replace(/\.[^.]+$/, '');
        const headerName = `${basename}.h`;

        return this.generate(symbols, headerName, options);
    }

    /**
     * Generate header for all C-Next symbols in the symbol table
     */
    generateCNextHeader(
        symbolTable: SymbolTable,
        filename: string,
        options: IHeaderOptions = {}
    ): string {
        const symbols = symbolTable.getSymbolsByLanguage(ESourceLanguage.CNext);
        return this.generate(symbols, filename, options);
    }

    /**
     * Create an include guard macro from filename
     */
    private makeGuard(filename: string, prefix?: string): string {
        // Remove path and extension
        const base = filename.replace(/^.*[\\/]/, '').replace(/\.[^.]+$/, '');

        // Convert to uppercase and replace non-alphanumeric with underscore
        const sanitized = base.toUpperCase().replace(/[^A-Z0-9]/g, '_');

        if (prefix) {
            return `${prefix.toUpperCase()}_${sanitized}_H`;
        }

        return `${sanitized}_H`;
    }

    /**
     * Map a C-Next type to C type
     */
    private mapType(type: string): string {
        // Check direct mapping first
        if (TYPE_MAP[type]) {
            return TYPE_MAP[type];
        }

        // Handle pointer types
        if (type.endsWith('*')) {
            const baseType = type.slice(0, -1).trim();
            return `${this.mapType(baseType)}*`;
        }

        // Handle array types (simplified)
        const arrayMatch = type.match(/^(\w+)\[(\d*)\]$/);
        if (arrayMatch) {
            const baseType = this.mapType(arrayMatch[1]);
            const size = arrayMatch[2] || '';
            return `${baseType}[${size}]`;
        }

        // User-defined types pass through
        return type;
    }

    /**
     * Generate a function prototype from symbol info
     */
    private generateFunctionPrototype(sym: ISymbol): string | null {
        // Use signature if available
        if (sym.signature) {
            // Parse signature to extract return type and params
            // Signature format is typically: "return_type(param1_type, param2_type, ...)"
            return `${sym.signature};`;
        }

        // Generate from type info
        const returnType = sym.type ? this.mapType(sym.type) : 'void';

        // For C-Next functions, all non-array parameters become pointers
        // This is a simplified version - full implementation would need param info
        return `${returnType} ${sym.name}(void);`;
    }
}

export default HeaderGenerator;
export type { IHeaderOptions };
