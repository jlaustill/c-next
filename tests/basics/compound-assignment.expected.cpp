/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint32_t cnx_clamp_mul_u32(uint32_t a, uint64_t b) {
    if (b != 0 && a > UINT32_MAX / b) return UINT32_MAX;
    uint32_t result;
    if (__builtin_mul_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint32_t cnx_clamp_sub_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)a) return 0;
    uint32_t result;
    if (__builtin_sub_overflow(a, (uint32_t)b, &result)) return 0;
    return result;
}

// test-execution
// Tests: Compound assignment operators
// Demonstrates: +<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-
int main(void) {
    uint32_t a = 10U;
    a = cnx_clamp_add_u32(a, 5U);
    if (a != 15) return 1;
    a = cnx_clamp_sub_u32(a, 3U);
    if (a != 12) return 2;
    a = cnx_clamp_mul_u32(a, 2U);
    if (a != 24) return 3;
    a /= 4U;
    if (a != 6) return 4;
    a = 17U;
    a %= 5U;
    if (a != 2) return 5;
    uint8_t flags = 0b11111111U;
    flags &= 0b00001111U;
    if (flags != 0b00001111) return 6;
    flags |= 0b11110000U;
    if (flags != 0b11111111) return 7;
    flags = 0b10101010U;
    flags ^= 0b11110000U;
    if (flags != 0b01011010) return 8;
    uint8_t val = 0b00000001U;
    val <<= 4U;
    if (val != 0b00010000) return 9;
    val = 0b10000000U;
    val >>= 4U;
    if (val != 0b00001000) return 10;
    return 0;
}
