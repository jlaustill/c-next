/**
 * Generated by C-Next Transpiler from: enum-all-scenarios.test.cnx
 * A safer C for embedded systems
 */

#include "enum-all-scenarios.test.h"

#include <stdint.h>
#include <stdbool.h>

// ADR-050: Platform-portable IRQ wrappers for critical sections
#if defined(__arm__) || defined(__ARM_ARCH)
// ARM platforms (including ARM Arduino like Teensy 4.x, Due, Zero)
// Provide inline assembly PRIMASK access to avoid CMSIS header dependencies
__attribute__((always_inline)) static inline uint32_t __cnx_get_PRIMASK(void) {
    uint32_t result;
    __asm volatile ("MRS %0, primask" : "=r" (result));
    return result;
}
__attribute__((always_inline)) static inline void __cnx_set_PRIMASK(uint32_t mask) {
    __asm volatile ("MSR primask, %0" :: "r" (mask) : "memory");
}
#if defined(ARDUINO)
static inline void __cnx_disable_irq(void) { noInterrupts(); }
#else
__attribute__((always_inline)) static inline void __cnx_disable_irq(void) {
    __asm volatile ("cpsid i" ::: "memory");
}
#endif
#elif defined(__AVR__)
// AVR Arduino: use SREG for interrupt state
// Note: Uses PRIMASK naming for API consistency across platforms (AVR has no PRIMASK)
// Returns uint8_t which is implicitly widened to uint32_t at call sites - this is intentional
static inline uint8_t __cnx_get_PRIMASK(void) { return SREG; }
static inline void __cnx_set_PRIMASK(uint8_t mask) { SREG = mask; }
static inline void __cnx_disable_irq(void) { cli(); }
#else
// Fallback: assume CMSIS is available
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }
#endif

// test-c-only
// test-execution
// Tests: Comprehensive enum scenarios - global, scope, cross-scope, loops, atomic, critical
// === GLOBAL ENUM ===
// === GLOBAL ENUM VARIABLE ===
EGlobalState globalState = EGlobalState_IDLE;

// === SCOPE WITH ENUM ===
/* Scope: Motor */
static Motor_EMode Motor_mode = Motor_EMode_OFF;
static Motor_EMode Motor_atomicMode = Motor_EMode_OFF;

Motor_EMode Motor_getMode(void) {
    return Motor_mode;
}

Motor_EMode Motor_getAtomicMode(void) {
    return Motor_atomicMode;
}

void Motor_setMode(Motor_EMode newMode) {
    Motor_mode = newMode;
}

void Motor_setAtomicMode(Motor_EMode newMode) {
    Motor_atomicMode = newMode;
}

bool Motor_testThisMethodEnum(void) {
    Motor_EMode currentMode = Motor_getMode();
    return (currentMode == Motor_EMode_OFF);
}

bool Motor_isOff(void) {
    return (Motor_mode == Motor_EMode_OFF);
}

bool Motor_isMode(Motor_EMode checkMode) {
    return (Motor_mode == checkMode);
}

EGlobalState Motor_getGlobalState(void) {
    return EGlobalState_IDLE;
}

void Motor_criticalEnumUpdate(void) {
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        Motor_mode = Motor_EMode_HIGH;
        __cnx_set_PRIMASK(__primask);
    }
}

// === SECOND SCOPE (for cross-scope testing) ===
/* Scope: Controller */
static Controller_EStatus Controller_status = Controller_EStatus_OK;

void Controller_setMotorMode(void) {
    Motor_setMode(Motor_EMode_HIGH);
}

Controller_EStatus Controller_getStatus(void) {
    return Controller_status;
}

// === MAIN TEST FUNCTION ===
int main(void) {
    uint32_t errors = 0U;
    EGlobalState state = EGlobalState_IDLE;
    if (state != EGlobalState_IDLE) {
        errors = errors + 1U;
    }
    state = EGlobalState_RUNNING;
    if (state != EGlobalState_RUNNING) {
        errors = errors + 2U;
    }
    if (state != EGlobalState_RUNNING) {
        errors = errors + 4U;
    }
    Motor_setMode(Motor_EMode_LOW);
    Motor_EMode motorMode = Motor_getMode();
    if (motorMode != Motor_EMode_LOW) {
        errors = errors + 8U;
    }
    bool isOff = Motor_isOff();
    if (isOff) {
        errors = errors + 16U;
    }
    bool isLow = Motor_isMode(Motor_EMode_LOW);
    if (!isLow) {
        errors = errors + 32U;
    }
    Motor_setAtomicMode(Motor_EMode_HIGH);
    Motor_EMode atomicResult = Motor_getAtomicMode();
    if (atomicResult != Motor_EMode_HIGH) {
        errors = errors + 64U;
    }
    Motor_criticalEnumUpdate();
    Motor_EMode afterCritical = Motor_getMode();
    if (afterCritical != Motor_EMode_HIGH) {
        errors = errors + 128U;
    }
    Controller_setMotorMode();
    EGlobalState loopState = EGlobalState_IDLE;
    uint32_t i = 0U;
    while (i < 3) {
        if (loopState == EGlobalState_IDLE) {
            loopState = EGlobalState_RUNNING;
        } else {
            loopState = EGlobalState_STOPPED;
        }
        i = i + 1U;
    }
    if (loopState != EGlobalState_STOPPED) {
        errors = errors + 256U;
    }
    EGlobalState fromScope = Motor_getGlobalState();
    if (fromScope != EGlobalState_IDLE) {
        errors = errors + 512U;
    }
    Controller_EStatus ctrlStatus = Controller_getStatus();
    if (ctrlStatus != Controller_EStatus_OK) {
        errors = errors + 1024U;
    }
    return errors;
}
