/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// Postfix Chain Test: Boundary Conditions
// Tests: Edge cases at type boundaries, max indices, etc.
typedef struct Data {
    uint8_t byte;
    uint16_t word;
    uint32_t dword;
    uint64_t qword;
} Data;

Data items[16] = {0};

// Max reasonable array size for testing
int main(void) {
    items[0].byte = 0xFF;
    items[0].byte = (items[0].byte & ~(1 << 0)) | (1 << 0);
    items[0].byte = (items[0].byte & ~(1 << 7)) | (0 << 7);
    bool b0 = ((items[0].byte >> 0) & 1);
    bool b7 = ((items[0].byte >> 7) & 1);
    items[0].word = 0xFFFF;
    items[0].word = (items[0].word & ~(1 << 0)) | (1 << 0);
    items[0].word = (items[0].word & ~(1 << 15)) | (0 << 15);
    bool w0 = ((items[0].word >> 0) & 1);
    bool w15 = ((items[0].word >> 15) & 1);
    items[0].dword = 0xFFFFFFFF;
    items[0].dword = (items[0].dword & ~(1 << 0)) | (1 << 0);
    items[0].dword = (items[0].dword & ~(1 << 31)) | (0 << 31);
    bool d0 = ((items[0].dword >> 0) & 1);
    bool d31 = ((items[0].dword >> 31) & 1);
    items[0].qword = 0;
    items[0].qword = (items[0].qword & ~(1ULL << 0)) | (1 << 0);
    items[0].qword = (items[0].qword & ~(1ULL << 30)) | (1 << 30);
    bool q0 = ((items[0].qword >> 0) & 1);
    bool q30 = ((items[0].qword >> 30) & 1);
    items[15].byte = 0xAA;
    uint8_t lastByte = items[15U].byte;
    uint8_t test8 = 0U;
    test8 = (test8 & ~(0xFFU << 0)) | ((0xFF & 0xFFU) << 0);
    uint8_t all8 = ((test8 >> 0U) & 0xFFU);
    uint16_t test16 = 0U;
    test16 = (test16 & ~(0xFFFFU << 0)) | ((0xFFFF & 0xFFFFU) << 0);
    uint16_t all16 = ((test16 >> 0U) & 0xFFFFU);
    uint32_t test32 = 0U;
    test32 = (test32 & ~(0xFFFFFFFFU << 0)) | ((0xFFFFFFFF & 0xFFFFFFFFU) << 0);
    uint32_t all32 = ((test32 >> 0U) & 0xFFFFFFFFU);
    uint32_t maxBitTest = 0U;
    maxBitTest = (maxBitTest & ~(1 << 31)) | (1 << 31);
    bool maxBit = ((maxBitTest >> 31) & 1);
    items[15].dword = 0xFFFFFFFF;
    items[15].dword = (items[15].dword & ~(1 << 31)) | (0 << 31);
    bool complexMax = ((items[15].dword >> 31) & 1);
    items[0].byte = (items[0].byte & ~(1 << 0)) | (1 << 0);
    bool zeroIdx = ((items[0].byte >> 0) & 1);
    uint8_t consecutive = 0xFFU;
    consecutive = (consecutive & ~(1 << 0)) | (0 << 0);
    consecutive = (consecutive & ~(1 << 1)) | (0 << 1);
    consecutive = (consecutive & ~(1 << 2)) | (0 << 2);
    consecutive = (consecutive & ~(1 << 3)) | (0 << 3);
    consecutive = (consecutive & ~(1 << 4)) | (0 << 4);
    consecutive = (consecutive & ~(1 << 5)) | (0 << 5);
    consecutive = (consecutive & ~(1 << 6)) | (0 << 6);
    consecutive = (consecutive & ~(1 << 7)) | (0 << 7);
    bool c0 = ((consecutive >> 0) & 1);
    bool c1 = ((consecutive >> 1) & 1);
    bool c2 = ((consecutive >> 2) & 1);
    bool c3 = ((consecutive >> 3) & 1);
    bool c4 = ((consecutive >> 4) & 1);
    bool c5 = ((consecutive >> 5) & 1);
    bool c6 = ((consecutive >> 6) & 1);
    bool c7 = ((consecutive >> 7) & 1);
}
