/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-coverage: 33.1-multiple-operators-same-precedence
// test-execution
// Tests: multiple operators with same precedence (left-to-right associativity)
// Coverage: Section 33.1 - Nested/Complex Expressions
// Helper functions to get boolean values (prevents static analysis false positives)
bool getTrue(uint32_t x) {
    return x > 0;
}

bool getFalse(uint32_t x) {
    return x > 1000;
}

int main(void) {
    uint32_t a = 10U;
    uint32_t b = 20U;
    uint32_t c = 30U;
    uint32_t d = 40U;
    uint32_t result = a + b + c + d;
    if (result != 100) return 1;
    result = 100U - 30U - 20U - 10U;
    if (result != 40) return 2;
    result = 100U - 60U - 30U;
    if (result != 10) return 3;
    result = 2U * 3U * 4U * 5U;
    if (result != 120) return 4;
    result = 120U / 2U / 3U / 4U;
    if (result != 5) return 5;
    result = 100U / 10U / 2U;
    if (result != 5) return 6;
    result = 100U % 30U % 7U;
    if (result != 3) return 7;
    uint32_t x = 0xFFU;
    uint32_t y = 0x0FU;
    uint32_t z = 0x07U;
    result = x & y & z;
    if (result != 0x07) return 8;
    result = 0x01U | 0x02U | 0x04U | 0x08U;
    if (result != 0x0F) return 9;
    result = 0xFFU ^ 0x0FU ^ 0x03U;
    if (result != 0xF3) return 10;
    result = 1U << 2U << 3U;
    if (result != 32) return 11;
    result = 256U >> 2U >> 3U;
    if (result != 8) return 12;
    bool cmp1 = 5 < 10;
    bool cmp2 = 10 < 15;
    bool both = cmp1 && cmp2;
    if (both != true) return 13;
    bool eq1 = 10 == 10;
    bool eq2 = 20 == 20;
    bool eq3 = 30 == 30;
    if (eq1 != true) return 14;
    if (eq2 != true) return 15;
    if (eq3 != true) return 16;
    bool t1 = getTrue(1U);
    bool t2 = getTrue(2U);
    bool t3 = getTrue(3U);
    bool t4 = getTrue(4U);
    bool andResult = t1 && t2 && t3 && t4;
    if (andResult != true) return 17;
    bool f1 = getFalse(0U);
    andResult = t1 && t2 && f1 && t4;
    if (andResult != false) return 18;
    bool f2 = getFalse(0U);
    bool f3 = getFalse(0U);
    bool f4 = getFalse(0U);
    bool orResult = f1 || f2 || f3 || t1;
    if (orResult != true) return 19;
    orResult = f1 || f2 || f3 || f4;
    if (orResult != false) return 20;
    result = (10U + 20U) * 3U;
    if (result != 90) return 21;
    result = ((100U - 50U) * 2U);
    if (result != 100) return 22;
    result = 10U - 5U + 3U;
    if (result != 8) return 23;
    result = 20U - 10U - 3U;
    if (result != 7) return 24;
    result = 50U + 20U - 10U + 5U;
    if (result != 65) return 25;
    result = 100U * 2U / 4U;
    if (result != 50) return 26;
    result = 240U / 4U / 3U / 2U;
    if (result != 10) return 27;
    return 0;
}
