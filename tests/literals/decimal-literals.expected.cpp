/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 32.1-decimal-literals
// test-execution
// Tests: Unsuffixed decimal integer literals with type inference
// Validates that plain integers work correctly when type is inferred from context
int main(void) {
    uint8_t byte = 200U;
    if (byte != 200) return 1;
    uint16_t word = 50000U;
    if (word != 50000) return 2;
    uint32_t dword = 3000000000U;
    if (dword != 3000000000) return 3;
    int8_t sbyte = 100;
    if (sbyte != 100) return 4;
    int16_t sword = 30000;
    if (sword != 30000) return 5;
    int32_t sdword = 2000000000;
    if (sdword != 2000000000) return 6;
    uint8_t zero = 0U;
    if (zero != 0) return 7;
    uint8_t one = 1U;
    if (one != 1) return 8;
    uint8_t nine = 9U;
    if (nine != 9) return 9;
    uint8_t ninetynine = 99U;
    if (ninetynine != 99) return 10;
    uint8_t u8Max = 255U;
    if (u8Max != 255) return 11;
    uint16_t u16Max = 65535U;
    if (u16Max != 65535) return 12;
    int8_t i8Max = 127;
    if (i8Max != 127) return 13;
    int16_t i16Max = 32767;
    if (i16Max != 32767) return 14;
    uint16_t sum = 100U + 200U;
    if (sum != 300) return 15;
    uint16_t diff = 500U - 123U;
    if (diff != 377) return 16;
    uint32_t product = 1000U * 1000U;
    if (product != 1000000) return 17;
    uint16_t quotient = 100U / 4U;
    if (quotient != 25) return 18;
    uint16_t remainder = 17U % 5U;
    if (remainder != 2) return 19;
    uint16_t values[5] = {10U, 20U, 30U, 40U, 50U};
    if (values[0] != 10) return 20;
    if (values[1] != 20) return 21;
    if (values[2] != 30) return 22;
    if (values[3] != 40) return 23;
    if (values[4] != 50) return 24;
    uint32_t val = 12345U;
    if (val != 12345) return 25;
    if (100 >= 200) return 26;
    if (500 <= 400) return 27;
    if (100 > 100) return 28;
    if (100 < 100) return 29;
    return 0;
}
