/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-execution */
// Tests: wrap modifier for u64 type (0 to 18446744073709551615)
// Validates: overflow wraps to 0, underflow wraps to max
// Issue #19: Add wrap modifier tests for all integer types
uint32_t main(void) {
    uint64_t val = 18446744073709551615;
    val += 1;
    if (val != 0) return 1;
    uint64_t val2 = 18446744073709551610;
    val2 += 10;
    if (val2 != 4) return 2;
    val = 10000000000000000000;
    val += 10000000000000000000;
    if (val != 1553255926290448384) return 3;
    val = 18446744073709551615;
    val += 1;
    if (val != 0) return 4;
    val += 18446744073709551615;
    if (val != 18446744073709551615) return 5;
    val = 0;
    val -= 1;
    if (val != 18446744073709551615) return 6;
    val = 5;
    val -= 10;
    if (val != 18446744073709551611) return 7;
    val = 100;
    val -= 1000;
    if (val != 18446744073709550716) return 8;
    val = 5;
    val -= 10;
    if (val != 18446744073709551611) return 9;
    val -= 18446744073709551611;
    if (val != 0) return 10;
    val = 1000000000000;
    val += 2000000000000;
    if (val != 3000000000000) return 11;
    val = 5000000000000;
    val -= 2000000000000;
    if (val != 3000000000000) return 12;
    val = 0;
    val += 9999999999999999999;
    if (val != 9999999999999999999) return 13;
    val = 1000000000000;
    val -= 1000000000000;
    if (val != 0) return 14;
    val = 18446744073709551614;
    val += 1;
    if (val != 18446744073709551615) return 15;
    val = 1;
    val -= 1;
    if (val != 0) return 16;
    val = 9223372036854775808;
    val += 0;
    if (val != 9223372036854775808) return 17;
    val = 9223372036854775808;
    val -= 0;
    if (val != 9223372036854775808) return 18;
    val = 1;
    val -= 1;
    if (val != 0) return 19;
    val -= 1;
    if (val != 18446744073709551615) return 20;
    val += 1;
    if (val != 0) return 21;
    return 0;
}
