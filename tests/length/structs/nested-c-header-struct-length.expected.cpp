/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// test-execution
// Tests: .length property on nested C header struct members
// Regression test for issue #103/#196 - .length on nested struct member access
#include "../../include/NestedTestConfig.h"

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

int main(void) {
    struct OuterConfig config = {0};
    config.directField = 0;
    config.single.byteField = 0;
    config.single.shortField = 0;
    config.single.intField = 0;
    config.single.floatField = 0.0;
    for (uint32_t init = 0; init < 4; init += 1) {
        config.array[init].byteField = 0;
        config.array[init].shortField = 0;
        config.array[init].intField = 0;
        config.array[init].floatField = 0.0;
    }
    if (32 != 32) return 1;
    if (8 != 8) return 2;
    if (16 != 16) return 3;
    if (32 != 32) return 4;
    if (32 != 32) return 5;
    if (8 != 8) return 6;
    if (16 != 16) return 7;
    if (32 != 32) return 8;
    if (32 != 32) return 9;
    for (uint32_t i = 0; i < 4; i += 1) {
        if (32 != 32) return 10;
        if (8 != 8) return 11;
    }
    struct DeepConfig deep = {0};
    deep.timestamp = 0;
    deep.outer.directField = 0;
    deep.outer.single.byteField = 0;
    deep.outer.single.shortField = 0;
    deep.outer.single.intField = 0;
    deep.outer.single.floatField = 0.0;
    for (uint32_t k = 0; k < 4; k += 1) {
        deep.outer.array[k].shortField = 0;
    }
    if (8 != 8) return 12;
    if (16 != 16) return 13;
    if (32 != 32) return 14;
    if (32 != 32) return 15;
    if (16 != 16) return 16;
    if (32 != 32) return 17;
    if (64 != 64) return 18;
    uint32_t bytes = 32 / 8U;
    if (bytes != 4) return 19;
    uint32_t total = 24;
    if (total != 24) return 20;
    uint32_t bitSum = 0U;
    for (uint32_t j = 0; j < 4; j += 1) {
        bitSum = cnx_clamp_add_u32(bitSum, 8);
    }
    if (bitSum != 32) return 21;
    return 0;
}
