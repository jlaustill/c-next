// test-execution
// Tests: Multiple sequential slice assignments to same buffer
// Validates non-overlapping regions with compile-time constant offsets
// Simulates real-world buffer building with explicit layout

u32 main() {
    u8[256] buffer;

    // Sequential writes building a protocol packet
    // Packet format: [magic:4][version:2][length:2][flags:1][reserved:3][data:8]
    // Using compile-time constant offsets for bounds safety

    // Write magic number at offset 0
    u32 magic <- 0x50415255;
    buffer[0, 4] <- magic;

    // Write version at offset 4
    u16 version <- 0x0100;
    buffer[4, 2] <- version;

    // Write length at offset 6
    u16 length <- 20;
    buffer[6, 2] <- length;

    // Write flags at offset 8
    u8 flags <- 0x0F;
    buffer[8, 1] <- flags;

    // Write reserved bytes at offsets 9, 10, 11
    u8 reserved <- 0;
    buffer[9, 1] <- reserved;
    buffer[10, 1] <- reserved;
    buffer[11, 1] <- reserved;

    // Write data payload at offset 12
    u64 data <- 0x0102030405060708;
    buffer[12, 8] <- data;

    // Validate magic (bytes 0-3)
    if (buffer[0] != 0x55) return 1;
    if (buffer[1] != 0x52) return 2;
    if (buffer[2] != 0x41) return 3;
    if (buffer[3] != 0x50) return 4;

    // Validate version (bytes 4-5)
    if (buffer[4] != 0x00) return 5;
    if (buffer[5] != 0x01) return 6;

    // Validate length (bytes 6-7)
    if (buffer[6] != 20) return 7;
    if (buffer[7] != 0) return 8;

    // Validate flags (byte 8)
    if (buffer[8] != 0x0F) return 9;

    // Validate reserved (bytes 9-11)
    if (buffer[9] != 0) return 10;
    if (buffer[10] != 0) return 11;
    if (buffer[11] != 0) return 12;

    // Validate data (bytes 12-19)
    if (buffer[12] != 0x08) return 13;
    if (buffer[13] != 0x07) return 14;
    if (buffer[14] != 0x06) return 15;
    if (buffer[15] != 0x05) return 16;
    if (buffer[16] != 0x04) return 17;
    if (buffer[17] != 0x03) return 18;
    if (buffer[18] != 0x02) return 19;
    if (buffer[19] != 0x01) return 20;

    // Test overwriting specific region
    u32 newMagic <- 0x44434241;
    buffer[0, 4] <- newMagic;

    if (buffer[0] != 0x41) return 21;
    if (buffer[1] != 0x42) return 22;
    if (buffer[2] != 0x43) return 23;
    if (buffer[3] != 0x44) return 24;

    // Verify other bytes unchanged
    if (buffer[4] != 0x00) return 25;
    if (buffer[8] != 0x0F) return 26;

    return 0;
}
