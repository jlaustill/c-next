// test-transpile-only
// Tests: Edge cases for C++ namespace function calls (Issue #516)
// Comprehensive regression prevention tests

#include "CppNamespace.hpp"

// Global variable with namespace type
SeaDash.Parse.ParseResult globalResult;

scope EdgeCases {
    // Scope member with namespace type
    SeaDash.Config scopeConfig;

    public void testAssignmentTarget() {
        // Test: Assignment target (left side) with namespace type
        SeaDash.Parse.ParseResult result;
        result <- SeaDash.Parse.parse("test", ',');
    }

    public void testNestedAccess() {
        // Test: Namespace function call followed by struct member access
        SeaDash.Parse.ParseResult result <- SeaDash.Parse.parse("1,2,3", ',');
        // Access struct members of the result
        i32 count <- result.count;
        bool ok <- result.success;
    }

    public void testMultipleCallsInSequence() {
        // Test: Multiple namespace calls in same function
        SeaDash.Parse.ParseResult r1 <- SeaDash.Parse.parse("a", ',');
        SeaDash.Parse.ParseResult r2 <- SeaDash.Parse.parse("b", ';');
        SeaDash.Config c1 <- SeaDash.getDefaultConfig();
        Deep.Level1.Level2.DeepType d1 <- Deep.Level1.Level2.create(1);
        Deep.Level1.Level2.DeepType d2 <- Deep.Level1.Level2.create(2);
    }

    public void testGlobalPrefixStillWorks() {
        // Test: Existing global. prefix should still work
        global.globalResult <- global.SeaDash.Parse.parse("global", ',');
    }

    public void testThisMemberWithNamespaceType() {
        // Test: this. access with namespace-typed member
        this.scopeConfig <- SeaDash.getDefaultConfig();
        i32 timeout <- this.scopeConfig.timeout;
    }
}
