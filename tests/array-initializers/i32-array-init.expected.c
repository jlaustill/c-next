/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int32_t cnx_clamp_add_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a + b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

// test-execution
// Tests: i32 as array element type
// Coverage: Section 1.2 i32 array element type
int main(void) {
    int32_t values[5] = {-2147483648, -100000, 0, 100000, 2147483647};
    if (values[0] != -2147483648) return 1;
    if (values[1] != -100000) return 2;
    if (values[2] != 0) return 3;
    if (values[3] != 100000) return 4;
    if (values[4] != 2147483647) return 5;
    int32_t data[4] = {0};
    data[0] = -500000;
    data[1] = 500000;
    data[2] = -1000000;
    data[3] = 1000000;
    if (data[0] != -500000) return 6;
    if (data[1] != 500000) return 7;
    if (data[2] != -1000000) return 8;
    if (data[3] != 1000000) return 9;
    int32_t inferred[3] = {10000, 20000, 30000};
    if (inferred[0] != 10000) return 10;
    if (inferred[1] != 20000) return 11;
    if (inferred[2] != 30000) return 12;
    int32_t loop_arr[3] = {1000, 2000, 3000};
    int32_t sum = 0;
    for (uint32_t i = 0; i < 3; i += 1) {
        sum = cnx_clamp_add_i32(sum, loop_arr[i]);
    }
    if (sum != 6000) return 13;
    int32_t modify[2] = {10000, 20000};
    modify[0] = -10000;
    modify[1] = -20000;
    if (modify[0] != -10000) return 14;
    if (modify[1] != -20000) return 15;
    return 0;
}
