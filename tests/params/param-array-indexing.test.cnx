// test-c-only
// test-execution
// Tests: Issue #579 - Array indexing on parameter should generate array access, not bit manipulation
// When a function parameter is declared as `u8 buf` (without explicit array syntax)
// but used with array indexing, it becomes a pointer in C (ADR-006), so buf[i] is array access.

u32 result <- 0;

// Test 1: Write to parameter with variable index
void writeToParam(u8 buf, u32 idx) {
    buf[idx] <- 42;
}

// Test 2: Read from parameter with variable index
u8 readFromParam(u8 buf, u32 idx) {
    return buf[idx];
}

// Test 3: Both read and write in same function
void copyElement(u8 src, u8 dst, u32 idx) {
    dst[idx] <- src[idx];
}

// Test 4: Constant index on parameter
u8 readFirst(u8 buf) {
    return buf[0];
}

// Test 5: Multiple index operations
void swapElements(u8 buf, u32 i, u32 j) {
    u8 temp <- buf[i];
    buf[i] <- buf[j];
    buf[j] <- temp;
}

// Test 6: With explicit array syntax (should still work)
void writeExplicit(u8[8] buf, u32 idx) {
    buf[idx] <- 99;
}

// Test 7: Bit range on parameter should still be bit extraction (NOT array access)
// This ensures we don't over-correct and treat value[0, 8] as array access
u8 getLowByte(u16 value) {
    return value[0, 8];
}

u8 getHighByte(u16 value) {
    return value[8, 8];
}

// Test 8: Local array with bit access after consuming all dimensions
// This tests the currentStructType fix for primitive array elements
// matrix[i][j] is array access, then [BIT] should be bit access
u8 getArrayBit(u8[2][2] matrix, u32 row, u32 col, u32 bit) {
    return matrix[row][col][bit];
}

void setArrayBit(u8[2][2] matrix, u32 row, u32 col, u32 bit, bool val) {
    matrix[row][col][bit] <- val;
}

u32 main() {
    u8[8] buffer <- [0, 0, 0, 0, 0, 0, 0, 0];
    u8[4] source <- [10, 20, 30, 40];
    u8[4] dest <- [0, 0, 0, 0];

    // Test 1: Write with variable index
    writeToParam(buffer, 3);
    if (buffer[3] != 42) return 1;

    // Test 2: Read with variable index
    u8 val <- readFromParam(source, 2);
    if (val != 30) return 2;

    // Test 3: Copy element
    copyElement(source, dest, 1);
    if (dest[1] != 20) return 3;

    // Test 4: Constant index
    val <- readFirst(source);
    if (val != 10) return 4;

    // Test 5: Swap elements
    buffer[0] <- 5;
    buffer[1] <- 7;
    swapElements(buffer, 0, 1);
    if (buffer[0] != 7) return 5;
    if (buffer[1] != 5) return 6;

    // Test 6: Explicit array syntax
    writeExplicit(buffer, 4);
    if (buffer[4] != 99) return 7;

    // Test 7: Bit range extraction (should NOT become array access)
    u16 testWord <- 0x1234;
    u8 low <- getLowByte(testWord);
    if (low != 0x34) return 8;
    u8 high <- getHighByte(testWord);
    if (high != 0x12) return 9;

    // Test 8: Local array bit access (tests currentStructType fix)
    u8[2] matrix[2] <- [[0xFF, 0x00], [0xAA, 0x55]];

    // Read bit 0 of matrix[0][0] (0xFF) - should be 1
    u8 bit0 <- getArrayBit(matrix, 0, 0, 0);
    if (bit0 != 1) return 10;

    // Read bit 0 of matrix[0][1] (0x00) - should be 0
    u8 bit1 <- getArrayBit(matrix, 0, 1, 0);
    if (bit1 != 0) return 11;

    // Set bit 0 of matrix[0][1] to 1
    setArrayBit(matrix, 0, 1, 0, true);
    if (matrix[0][1] != 0x01) return 12;

    // Clear bit 7 of matrix[0][0] (0xFF -> 0x7F)
    setArrayBit(matrix, 0, 0, 7, false);
    if (matrix[0][0] != 0x7F) return 13;

    return 0;
}
