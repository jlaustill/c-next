/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "enum-all-scenarios.test.h"

#include <stdint.h>
#include <stdbool.h>

// ADR-050: IRQ wrappers to avoid macro collisions with platform headers
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }

// test-execution
// Tests: Comprehensive enum scenarios - global, scope, cross-scope, loops, atomic, critical
// === GLOBAL ENUM ===
// === GLOBAL ENUM VARIABLE ===
EGlobalState globalState = EGlobalState_IDLE;

// === SCOPE WITH ENUM ===
/* Scope: Motor */
static Motor_EMode Motor_mode = Motor_EMode_OFF;
static Motor_EMode Motor_atomicMode = Motor_EMode_OFF;

Motor_EMode Motor_getMode(void) {
    return Motor_mode;
}

Motor_EMode Motor_getAtomicMode(void) {
    return Motor_atomicMode;
}

void Motor_setMode(Motor_EMode newMode) {
    Motor_mode = newMode;
}

void Motor_setAtomicMode(Motor_EMode newMode) {
    Motor_atomicMode = newMode;
}

bool Motor_testThisMethodEnum(void) {
    Motor_EMode currentMode = Motor_getMode();
    return (currentMode == Motor_EMode_OFF);
}

bool Motor_isOff(void) {
    return (Motor_mode == Motor_EMode_OFF);
}

bool Motor_isMode(Motor_EMode checkMode) {
    return (Motor_mode == checkMode);
}

EGlobalState Motor_getGlobalState(void) {
    return EGlobalState_IDLE;
}

void Motor_criticalEnumUpdate(void) {
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        Motor_mode = Motor_EMode_HIGH;
        __cnx_set_PRIMASK(__primask);
    }
}

// === SECOND SCOPE (for cross-scope testing) ===
/* Scope: Controller */
static Controller_EStatus Controller_status = Controller_EStatus_OK;

void Controller_setMotorMode(void) {
    Motor_setMode(Motor_EMode_HIGH);
}

Controller_EStatus Controller_getStatus(void) {
    return Controller_status;
}

// === MAIN TEST FUNCTION ===
int main(void) {
    uint32_t errors = 0;
    EGlobalState state = EGlobalState_IDLE;
    if (state != EGlobalState_IDLE) {
        errors = errors + 1;
    }
    state = EGlobalState_RUNNING;
    if (state != EGlobalState_RUNNING) {
        errors = errors + 2;
    }
    if (state != EGlobalState_RUNNING) {
        errors = errors + 4;
    }
    Motor_setMode(Motor_EMode_LOW);
    Motor_EMode motorMode = Motor_getMode();
    if (motorMode != Motor_EMode_LOW) {
        errors = errors + 8;
    }
    bool isOff = Motor_isOff();
    if (isOff) {
        errors = errors + 16;
    }
    bool isLow = Motor_isMode(Motor_EMode_LOW);
    if (!isLow) {
        errors = errors + 32;
    }
    Motor_setAtomicMode(Motor_EMode_HIGH);
    Motor_EMode atomicResult = Motor_getAtomicMode();
    if (atomicResult != Motor_EMode_HIGH) {
        errors = errors + 64;
    }
    Motor_criticalEnumUpdate();
    Motor_EMode afterCritical = Motor_getMode();
    if (afterCritical != Motor_EMode_HIGH) {
        errors = errors + 128;
    }
    Controller_setMotorMode();
    EGlobalState loopState = EGlobalState_IDLE;
    uint32_t i = 0;
    while (i < 3) {
        if (loopState == EGlobalState_IDLE) {
            loopState = EGlobalState_RUNNING;
        } else {
            loopState = EGlobalState_STOPPED;
        }
        i = i + 1;
    }
    if (loopState != EGlobalState_STOPPED) {
        errors = errors + 256;
    }
    EGlobalState fromScope = Motor_getGlobalState();
    if (fromScope != EGlobalState_IDLE) {
        errors = errors + 512;
    }
    Controller_EStatus ctrlStatus = Controller_getStatus();
    if (ctrlStatus != Controller_EStatus_OK) {
        errors = errors + 1024;
    }
    return errors;
}
