/**
 * Generated by C-Next Transpiler from: boundary-conditions.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// Postfix Chain Test: Boundary Conditions
// Tests: Edge cases at type boundaries, max indices, etc.
typedef struct Data {
    uint8_t byte;
    uint16_t word;
    uint32_t dword;
    uint64_t qword;
} Data;

Data items[16] = {0};

// Max reasonable array size for testing
int main(void) {
    items[0].byte = 0xFFU;
    items[0].byte = (items[0].byte & ~(1U << 0)) | (1U << 0);
    items[0].byte = (items[0].byte & ~(1U << 7)) | (0U << 7);
    bool b0 = ((((items[0U].byte) & 1)) != 0U);
    bool b7 = ((((items[0U].byte >> 7U) & 1)) != 0U);
    items[0].word = 0xFFFFU;
    items[0].word = (items[0].word & ~(1U << 0)) | (1U << 0);
    items[0].word = (items[0].word & ~(1U << 15)) | (0U << 15);
    bool w0 = ((((items[0U].word) & 1)) != 0U);
    bool w15 = ((((items[0U].word >> 15U) & 1)) != 0U);
    items[0].dword = 0xFFFFFFFFU;
    items[0].dword = (items[0].dword & ~(1U << 0)) | (1U << 0);
    items[0].dword = (items[0].dword & ~(1U << 31)) | (0U << 31);
    bool d0 = ((((items[0U].dword) & 1)) != 0U);
    bool d31 = ((((items[0U].dword >> 31U) & 1)) != 0U);
    items[0].qword = 0ULL;
    items[0].qword = (items[0].qword & ~(1ULL << 0)) | (1U << 0);
    items[0].qword = (items[0].qword & ~(1ULL << 30)) | (1U << 30);
    bool q0 = ((((items[0U].qword) & 1)) != 0U);
    bool q30 = ((((items[0U].qword >> 30U) & 1)) != 0U);
    items[15].byte = 0xAAU;
    uint8_t lastByte = items[15U].byte;
    uint8_t test8 = 0U;
    test8 = (uint8_t)((test8 & ~(0xFFU << 0)) | ((0xFF & 0xFFU) << 0));
    uint8_t all8 = (uint8_t)((test8) & 0xFFU);
    uint16_t test16 = 0U;
    test16 = (uint16_t)((test16 & ~(0xFFFFU << 0)) | ((0xFFFF & 0xFFFFU) << 0));
    uint16_t all16 = (uint16_t)((test16) & 0xFFFFU);
    uint32_t test32 = 0U;
    test32 = (test32 & ~(0xFFFFFFFFU << 0)) | ((0xFFFFFFFF & 0xFFFFFFFFU) << 0);
    uint32_t all32 = ((test32) & 0xFFFFFFFFU);
    uint32_t maxBitTest = 0U;
    maxBitTest = (maxBitTest & ~(1U << 31)) | (1U << 31);
    bool maxBit = ((((maxBitTest >> 31U) & 1)) != 0U);
    items[15].dword = 0xFFFFFFFFU;
    items[15].dword = (items[15].dword & ~(1U << 31)) | (0U << 31);
    bool complexMax = ((((items[15U].dword >> 31U) & 1)) != 0U);
    items[0].byte = (items[0].byte & ~(1U << 0)) | (1U << 0);
    bool zeroIdx = ((((items[0U].byte) & 1)) != 0U);
    uint8_t consecutive = 0xFFU;
    consecutive = (uint8_t)((consecutive & ~(1U << 0)) | (0U << 0));
    consecutive = (uint8_t)((consecutive & ~(1U << 1)) | (0U << 1));
    consecutive = (uint8_t)((consecutive & ~(1U << 2)) | (0U << 2));
    consecutive = (uint8_t)((consecutive & ~(1U << 3)) | (0U << 3));
    consecutive = (uint8_t)((consecutive & ~(1U << 4)) | (0U << 4));
    consecutive = (uint8_t)((consecutive & ~(1U << 5)) | (0U << 5));
    consecutive = (uint8_t)((consecutive & ~(1U << 6)) | (0U << 6));
    consecutive = (uint8_t)((consecutive & ~(1U << 7)) | (0U << 7));
    bool c0 = ((((consecutive) & 1)) != 0U);
    bool c1 = ((((consecutive >> 1U) & 1)) != 0U);
    bool c2 = ((((consecutive >> 2U) & 1)) != 0U);
    bool c3 = ((((consecutive >> 3U) & 1)) != 0U);
    bool c4 = ((((consecutive >> 4U) & 1)) != 0U);
    bool c5 = ((((consecutive >> 5U) & 1)) != 0U);
    bool c6 = ((((consecutive >> 6U) & 1)) != 0U);
    bool c7 = ((((consecutive >> 7U) & 1)) != 0U);
}
