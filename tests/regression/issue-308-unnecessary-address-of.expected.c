/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

/* test-execution */
// Tests: Issue #308 - Unnecessary & added to array access and struct member arrays
// NOTE: Uses cpp mode because C++ has stricter type checking that catches this error
// The .hpp include triggers C++ mode automatically
#include "issue-308-unnecessary-address-of.hpp"

#include <stdint.h>

// Bug: The transpiler incorrectly adds & (address-of) in two scenarios:
// 1. Array element access: data[3] becomes &data[3] (wrong - we want the value)
// 2. Struct member arrays: result.data becomes &result.data (wrong - array should decay)
// Struct with array member to test scenario 2
typedef struct DataResult {
    uint8_t errorCode;
    uint8_t data[6];
    uint8_t dataLen;
} DataResult;

// ============================================================
// Scenario 1: Array element access
// Function expects VALUES (u8), not pointers
// ============================================================
uint32_t sumFourBytes(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    return b0 + b1 + b2 + b3;
}

// ============================================================
// Scenario 2: Struct member array
// Function expects array pointer (via decay), not pointer-to-array
// ============================================================
uint8_t sumArray(const uint8_t arr[6], uint8_t len) {
    uint8_t sum = 0;
    uint8_t i = 0;
    while (i < len) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum;
}

int main(void) {
    uint8_t data[8] = {0};
    data[0] = 0x12;
    data[1] = 0x34;
    data[2] = 0x56;
    data[3] = 0x78;
    uint32_t sum = sumFourBytes(data[0], data[1], data[2], data[3]);
    if (sum != 276) return 1;
    DataResult result = {0};
    result.errorCode = 0;
    result.data[0] = 10;
    result.data[1] = 20;
    result.data[2] = 30;
    result.data[3] = 40;
    result.data[4] = 50;
    result.data[5] = 60;
    result.dataLen = 6;
    uint8_t total = sumArray(result.data, result.dataLen);
    if (total != 210) return 2;
    return 0;
}
