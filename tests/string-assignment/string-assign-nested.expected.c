/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

/* test-execution */
// Issue #139: Test string assignment in deeply nested blocks
char nested[33] = "";

void deepNest(uint32_t* depth) {
    if ((*depth) > 0) {
        if ((*depth) > 1) {
            if ((*depth) > 2) {
                strncpy(nested, "DeepNest", 32); nested[32] = '\0';
            }
        }
    }
}

void mixedNest(uint32_t* count) {
    if ((*count) > 0) {
        uint32_t i = 0;
        while (i < (*count)) {
            if (i == 0) {
                strncpy(nested, "Mixed", 32); nested[32] = '\0';
            }
            i = cnx_clamp_add_u32(i, 1);
        }
    }
}

int main(void) {
    deepNest(&(uint32_t){3});
    if (strlen(nested) != 8) return 1;
    mixedNest(&(uint32_t){1});
    if (strlen(nested) != 5) return 2;
    {
        {
            {
                strncpy(nested, "Blocks", 32); nested[32] = '\0';
            }
        }
    }
    if (strlen(nested) != 6) return 3;
    return 0;
}
