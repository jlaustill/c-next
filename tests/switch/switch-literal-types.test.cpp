/**
 * Generated by C-Next Transpiler from: switch-literal-types.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// ADR-025: Switch with different literal formats
// Tests: hex, binary, and char literals in case labels
// Coverage: Section 7 (Control Flow) - case label literal types
uint32_t result = 0;

// Hex literal cases
void testHexCases(uint8_t val) {
    switch (val) {
        case 0x00: {
            result = 1U;
            break;
        }
        case 0x0F: {
            result = 2U;
            break;
        }
        case 0x10: {
            result = 3U;
            break;
        }
        case 0x7F: {
            result = 4U;
            break;
        }
        case 0x80: {
            result = 5U;
            break;
        }
        case 0xFF: {
            result = 6U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Binary literal cases
void testBinaryCases(uint8_t val) {
    switch (val) {
        case 0x0: {
            result = 10U;
            break;
        }
        case 0x1: {
            result = 11U;
            break;
        }
        case 0xF: {
            result = 12U;
            break;
        }
        case 0x7F: {
            result = 13U;
            break;
        }
        case 0x80: {
            result = 14U;
            break;
        }
        case 0xFF: {
            result = 15U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Char literal cases
void testCharCases(uint8_t val) {
    switch (val) {
        case 'A': {
            result = 20U;
            break;
        }
        case 'Z': {
            result = 21U;
            break;
        }
        case 'a': {
            result = 22U;
            break;
        }
        case 'z': {
            result = 23U;
            break;
        }
        case '0': {
            result = 24U;
            break;
        }
        case '9': {
            result = 25U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Mixed literal types in same switch
void testMixedLiterals(uint8_t val) {
    switch (val) {
        case 0: {
            result = 30U;
            break;
        }
        case 0x0A: {
            result = 31U;
            break;
        }
        case 0x14: {
            result = 32U;
            break;
        }
        case 'X': {
            result = 33U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Large hex values (u16)
void testLargeHex(uint16_t val) {
    switch (val) {
        case 0x0000: {
            result = 40U;
            break;
        }
        case 0x00FF: {
            result = 41U;
            break;
        }
        case 0x0100: {
            result = 42U;
            break;
        }
        case 0x7FFF: {
            result = 43U;
            break;
        }
        case 0x8000: {
            result = 44U;
            break;
        }
        case 0xFFFF: {
            result = 45U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

int main(void) {
    uint8_t h00 = 0x00U;
    uint8_t h0F = 0x0FU;
    uint8_t h10 = 0x10U;
    uint8_t h7F = 0x7FU;
    uint8_t h80 = 0x80U;
    uint8_t hFF = 0xFFU;
    uint8_t hOther = 0x50U;
    testHexCases(h00);
    if (result != 1) return 1;
    testHexCases(h0F);
    if (result != 2) return 2;
    testHexCases(h10);
    if (result != 3) return 3;
    testHexCases(h7F);
    if (result != 4) return 4;
    testHexCases(h80);
    if (result != 5) return 5;
    testHexCases(hFF);
    if (result != 6) return 6;
    testHexCases(hOther);
    if (result != 99) return 7;
    uint8_t b00 = 0b00000000U;
    uint8_t b01 = 0b00000001U;
    uint8_t b0F = 0b00001111U;
    uint8_t b7F = 0b01111111U;
    uint8_t b80 = 0b10000000U;
    uint8_t bFF = 0b11111111U;
    uint8_t bOther = 0b00100000U;
    testBinaryCases(b00);
    if (result != 10) return 8;
    testBinaryCases(b01);
    if (result != 11) return 9;
    testBinaryCases(b0F);
    if (result != 12) return 10;
    testBinaryCases(b7F);
    if (result != 13) return 11;
    testBinaryCases(b80);
    if (result != 14) return 12;
    testBinaryCases(bFF);
    if (result != 15) return 13;
    testBinaryCases(bOther);
    if (result != 99) return 14;
    uint8_t cA = static_cast<uint8_t>('A');
    uint8_t cZ = static_cast<uint8_t>('Z');
    uint8_t ca = static_cast<uint8_t>('a');
    uint8_t cz = static_cast<uint8_t>('z');
    uint8_t c0 = static_cast<uint8_t>('0');
    uint8_t c9 = static_cast<uint8_t>('9');
    uint8_t cOther = static_cast<uint8_t>('X');
    testCharCases(cA);
    if (result != 20) return 15;
    testCharCases(cZ);
    if (result != 21) return 16;
    testCharCases(ca);
    if (result != 22) return 17;
    testCharCases(cz);
    if (result != 23) return 18;
    testCharCases(c0);
    if (result != 24) return 19;
    testCharCases(c9);
    if (result != 25) return 20;
    testCharCases(cOther);
    if (result != 99) return 21;
    uint8_t m0 = 0U;
    uint8_t m10 = 10U;
    uint8_t m20 = 20U;
    uint8_t mX = static_cast<uint8_t>('X');
    uint8_t mOther = 100U;
    testMixedLiterals(m0);
    if (result != 30) return 22;
    testMixedLiterals(m10);
    if (result != 31) return 23;
    testMixedLiterals(m20);
    if (result != 32) return 24;
    testMixedLiterals(mX);
    if (result != 33) return 25;
    testMixedLiterals(mOther);
    if (result != 99) return 26;
    uint16_t l0000 = 0x0000U;
    uint16_t l00FF = 0x00FFU;
    uint16_t l0100 = 0x0100U;
    uint16_t l7FFF = 0x7FFFU;
    uint16_t l8000 = 0x8000U;
    uint16_t lFFFF = 0xFFFFU;
    uint16_t lOther = 0x1234U;
    testLargeHex(l0000);
    if (result != 40) return 27;
    testLargeHex(l00FF);
    if (result != 41) return 28;
    testLargeHex(l0100);
    if (result != 42) return 29;
    testLargeHex(l7FFF);
    if (result != 43) return 30;
    testLargeHex(l8000);
    if (result != 44) return 31;
    testLargeHex(lFFFF);
    if (result != 45) return 32;
    testLargeHex(lOther);
    if (result != 99) return 33;
    return 0;
}
