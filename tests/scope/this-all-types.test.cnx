// test-execution
// Test: ADR-016 this. accessor with all primitive types
// Verifies that this. works correctly with every C-Next primitive type inside scope methods

scope AllTypesTest {
    // Unsigned integers
    u8 valU8 <- 255;
    u16 valU16 <- 65535;
    u32 valU32 <- 4294967295;
    u64 valU64 <- 18446744073709551615;

    // Signed integers
    i8 valI8 <- -128;
    i16 valI16 <- -32768;
    i32 valI32 <- -2147483648;
    i64 valI64 <- -9223372036854775808;

    // Floating point
    f32 valF32 <- 3.14;
    f64 valF64 <- 3.141592653589793;

    // Boolean
    bool valBool <- true;

    // Getters using this. accessor - Unsigned integers
    public u8 getU8() {
        return this.valU8;
    }

    public u16 getU16() {
        return this.valU16;
    }

    public u32 getU32() {
        return this.valU32;
    }

    public u64 getU64() {
        return this.valU64;
    }

    // Getters using this. accessor - Signed integers
    public i8 getI8() {
        return this.valI8;
    }

    public i16 getI16() {
        return this.valI16;
    }

    public i32 getI32() {
        return this.valI32;
    }

    public i64 getI64() {
        return this.valI64;
    }

    // Getters using this. accessor - Floating point
    public f32 getF32() {
        return this.valF32;
    }

    public f64 getF64() {
        return this.valF64;
    }

    // Getter using this. accessor - Boolean
    public bool getBool() {
        return this.valBool;
    }

    // Setters using this. accessor to test assignment
    public void setU8(u8 val) {
        this.valU8 <- val;
    }

    public void setBool(bool val) {
        this.valBool <- val;
    }

    public void setF32(f32 val) {
        this.valF32 <- val;
    }

    public void setF64(f64 val) {
        this.valF64 <- val;
    }
}

i32 main() {

// Test all getter methods using this. accessor - verify returned values
    // Each validation uses a unique error code for debugging

    // Unsigned integers
    u8 resultU8 <- AllTypesTest.getU8();
    if (resultU8 != 255) {
        return 1;
    }
    u16 resultU16 <- AllTypesTest.getU16();
    if (resultU16 != 65535) {
        return 2;
    }
    u32 resultU32 <- AllTypesTest.getU32();
    if (resultU32 != 4294967295) {
        return 3;
    }
    u64 resultU64 <- AllTypesTest.getU64();
    if (resultU64 != 18446744073709551615) {
        return 4;
    }

    // Signed integers
    i8 resultI8 <- AllTypesTest.getI8();
    if (resultI8 != -128) {
        return 5;
    }
    i16 resultI16 <- AllTypesTest.getI16();
    if (resultI16 != -32768) {
        return 6;
    }
    i32 resultI32 <- AllTypesTest.getI32();
    if (resultI32 != -2147483648) {
        return 7;
    }
    i64 resultI64 <- AllTypesTest.getI64();
    if (resultI64 != -9223372036854775808) {
        return 8;
    }

    // Floating point - test via setter/getter roundtrip to avoid literal comparison issues
    // Direct comparison of float to double literals has precision issues (see Issue #26)
    f32 testF32 <- 99.5;
    AllTypesTest.setF32(testF32);
    f32 resultF32 <- AllTypesTest.getF32();
    if (resultF32 != testF32) {
        return 9;
    }

    f64 testF64 <- 123.456789012345;
    AllTypesTest.setF64(testF64);
    f64 resultF64 <- AllTypesTest.getF64();
    if (resultF64 != testF64) {
        return 10;
    }

    // Boolean
    bool resultBool <- AllTypesTest.getBool();
    if (resultBool != true) {
        return 11;
    }


// Test setters - modify and verify
    u8 newU8Value <- 100;
    AllTypesTest.setU8(newU8Value);
    resultU8 <- AllTypesTest.getU8();
    if (resultU8 != 100) {
        return 12;
    }

    bool newBoolValue <- false;
    AllTypesTest.setBool(newBoolValue);
    resultBool <- AllTypesTest.getBool();
    if (resultBool != false) {
        return 13;
    }

    // All tests passed (13 validations total)
    return 0;
}
