/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int8_t cnx_clamp_add_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a + b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline int8_t cnx_clamp_mul_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a * b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline int8_t cnx_clamp_sub_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a - b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

// test-execution
// Tests: i8 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: -128 to 127
int main(void) {
    int8_t val = 50;
    val = cnx_clamp_add_i8(val, 25);
    if (val != 75) return 1;
    val = -50;
    val = cnx_clamp_add_i8(val, 25);
    if (val != -25) return 2;
    val = -50;
    val = cnx_clamp_add_i8(val, -25);
    if (val != -75) return 3;
    val = 100;
    val = cnx_clamp_add_i8(val, 0);
    if (val != 100) return 4;
    val = -100;
    val = cnx_clamp_add_i8(val, 100);
    if (val != 0) return 5;
    val = 126;
    val = cnx_clamp_add_i8(val, 1);
    if (val != 127) return 6;
    int8_t sub = 75;
    sub = cnx_clamp_sub_i8(sub, 25);
    if (sub != 50) return 10;
    sub = 25;
    sub = cnx_clamp_sub_i8(sub, 75);
    if (sub != -50) return 11;
    sub = -50;
    sub = cnx_clamp_sub_i8(sub, 25);
    if (sub != -75) return 12;
    sub = -50;
    sub = cnx_clamp_sub_i8(sub, -25);
    if (sub != -25) return 13;
    sub = 100;
    sub = cnx_clamp_sub_i8(sub, 0);
    if (sub != 100) return 14;
    sub = -127;
    sub = cnx_clamp_sub_i8(sub, 1);
    if (sub != -128) return 15;
    int8_t mul = 10;
    mul = cnx_clamp_mul_i8(mul, 10);
    if (mul != 100) return 20;
    mul = -10;
    mul = cnx_clamp_mul_i8(mul, 10);
    if (mul != -100) return 21;
    mul = -10;
    mul = cnx_clamp_mul_i8(mul, -10);
    if (mul != 100) return 22;
    mul = 50;
    mul = cnx_clamp_mul_i8(mul, 1);
    if (mul != 50) return 23;
    mul = 50;
    mul = cnx_clamp_mul_i8(mul, -1);
    if (mul != -50) return 24;
    mul = 100;
    mul = cnx_clamp_mul_i8(mul, 0);
    if (mul != 0) return 25;
    int8_t div = 100;
    div = static_cast<int8_t>((div / 10));
    if (div != 10) return 30;
    div = -100;
    div = static_cast<int8_t>((div / 10));
    if (div != -10) return 31;
    div = -100;
    div = static_cast<int8_t>((div / -10));
    if (div != 10) return 32;
    div = 50;
    div = static_cast<int8_t>((div / 1));
    if (div != 50) return 33;
    div = -50;
    div = static_cast<int8_t>((div / -1));
    if (div != 50) return 34;
    div = 127;
    div = static_cast<int8_t>((div / 127));
    if (div != 1) return 35;
    int8_t mod = 107;
    mod = static_cast<int8_t>((mod % 10));
    if (mod != 7) return 40;
    mod = -107;
    mod = static_cast<int8_t>((mod % 10));
    if (mod != -7) return 41;
    mod = 17;
    mod = static_cast<int8_t>((mod % 5));
    if (mod != 2) return 42;
    mod = 100;
    mod = static_cast<int8_t>((mod % 100));
    if (mod != 0) return 43;
    mod = -128;
    mod = static_cast<int8_t>((mod % 127));
    if (mod != -1) return 44;
    int8_t andVal = 0x7F;
    andVal = static_cast<int8_t>((andVal & 0x0F));
    if (andVal != 0x0F) return 50;
    andVal = -1;
    andVal = static_cast<int8_t>((andVal & 0x0F));
    if (andVal != 0x0F) return 51;
    andVal = 0x55;
    andVal = static_cast<int8_t>((andVal & 0xAA));
    if (andVal != 0) return 52;
    andVal = 0x7F;
    andVal = static_cast<int8_t>((andVal & 0x7F));
    if (andVal != 0x7F) return 53;
    int8_t orVal = 0x0F;
    orVal = static_cast<int8_t>((orVal | 0x70));
    if (orVal != 0x7F) return 60;
    orVal = 0x12;
    orVal = static_cast<int8_t>((orVal | 0x00));
    if (orVal != 0x12) return 61;
    orVal = 0x55;
    orVal = static_cast<int8_t>((orVal | 0x2A));
    if (orVal != 0x7F) return 62;
    int8_t xorVal = 0x55;
    xorVal = static_cast<int8_t>((xorVal ^ 0x55));
    if (xorVal != 0) return 70;
    xorVal = 0x0F;
    xorVal = static_cast<int8_t>((xorVal ^ 0x70));
    if (xorVal != 0x7F) return 71;
    xorVal = -1;
    xorVal = static_cast<int8_t>((xorVal ^ -1));
    if (xorVal != 0) return 72;
    xorVal = 0x55;
    xorVal = static_cast<int8_t>((xorVal ^ 0x2A));
    if (xorVal != 0x7F) return 73;
    int8_t shl = 1;
    shl = static_cast<int8_t>((shl << 0));
    if (shl != 1) return 80;
    shl = 1;
    shl = static_cast<int8_t>((shl << 1));
    if (shl != 2) return 81;
    shl = 1;
    shl = static_cast<int8_t>((shl << 4));
    if (shl != 16) return 82;
    shl = 1;
    shl = static_cast<int8_t>((shl << 6));
    if (shl != 64) return 83;
    shl = -1;
    shl = static_cast<int8_t>((shl << 2));
    if (shl != -4) return 84;
    int8_t shr = 64;
    shr = static_cast<int8_t>((shr >> 0));
    if (shr != 64) return 90;
    shr = 64;
    shr = static_cast<int8_t>((shr >> 1));
    if (shr != 32) return 91;
    shr = 64;
    shr = static_cast<int8_t>((shr >> 6));
    if (shr != 1) return 92;
    shr = -8;
    shr = static_cast<int8_t>((shr >> 2));
    if (shr != -2) return 93;
    shr = -1;
    shr = static_cast<int8_t>((shr >> 4));
    if (shr != -1) return 94;
    return 0;
}
