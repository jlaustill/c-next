{
  "file_path": "tests/scope/scope-atomic-modifier.expected.c",
  "main_branch_history": [],
  "task_views": {
    "001-100-scope-testing-coverage": {
      "task_id": "001-100-scope-testing-coverage",
      "branch_point": {
        "commit_hash": "6085a00ee4bff6129a6503c31d4280591d7eb497",
        "content": "",
        "timestamp": "2026-01-09T22:16:23.113589"
      },
      "worktree_state": {
        "content": "/**\n * Generated by C-Next Transpiler\n * A safer C for embedded systems\n */\n\n// Test: ADR-016 + ADR-049 Atomic variables inside scopes\n// Verifies that atomic modifier works correctly with integer types inside scope methods\n// Tests: atomic variables accessed via this. accessor with compound assignment operators\n\n#include <stdint.h>\n#include <cmsis_gcc.h>\n\n// ADR-044: Overflow helper functions\n#include <limits.h>\n\nstatic inline uint8_t cnx_clamp_add_u8(uint8_t a, uint8_t b) {\n    if (a > UINT8_MAX - b) return UINT8_MAX;\n    return a + b;\n}\n\nstatic inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint8_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\nstatic inline uint16_t cnx_clamp_add_u16(uint16_t a, uint16_t b) {\n    if (a > UINT16_MAX - b) return UINT16_MAX;\n    return a + b;\n}\n\nstatic inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint16_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\nstatic inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {\n    if (a > UINT32_MAX - b) return UINT32_MAX;\n    return a + b;\n}\n\n/* Scope: AtomicTest */\nvolatile uint8_t AtomicTest_counterU8 = 0;\nvolatile uint16_t AtomicTest_counterU16 = 0;\nvolatile uint32_t AtomicTest_counterU32 = 0;\nvolatile uint8_t AtomicTest_brightness = 100;\nvolatile uint16_t AtomicTest_position = 500;\nvolatile uint32_t AtomicTest_ticks = 0;\n\nuint8_t AtomicTest_getCounterU8(void) {\n    return AtomicTest_counterU8;\n}\n\nuint16_t AtomicTest_getCounterU16(void) {\n    return AtomicTest_counterU16;\n}\n\nuint32_t AtomicTest_getCounterU32(void) {\n    return AtomicTest_counterU32;\n}\n\nuint8_t AtomicTest_getBrightness(void) {\n    return AtomicTest_brightness;\n}\n\nuint16_t AtomicTest_getPosition(void) {\n    return AtomicTest_position;\n}\n\nuint32_t AtomicTest_getTicks(void) {\n    return AtomicTest_ticks;\n}\n\nvoid AtomicTest_incrementU8(void) {\n    do {\n        uint8_t __old = __LDREXB(&AtomicTest_counterU8);\n        uint8_t __new = cnx_clamp_add_u8(__old, 1);\n        if (__STREXB(__new, &AtomicTest_counterU8) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_incrementU16(void) {\n    do {\n        uint16_t __old = __LDREXH(&AtomicTest_counterU16);\n        uint16_t __new = cnx_clamp_add_u16(__old, 1);\n        if (__STREXH(__new, &AtomicTest_counterU16) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_incrementU32(void) {\n    do {\n        uint32_t __old = __LDREXW(&AtomicTest_counterU32);\n        uint32_t __new = cnx_clamp_add_u32(__old, 1);\n        if (__STREXW(__new, &AtomicTest_counterU32) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_decrementBrightness(void) {\n    do {\n        uint8_t __old = __LDREXB(&AtomicTest_brightness);\n        uint8_t __new = cnx_clamp_sub_u8(__old, 10);\n        if (__STREXB(__new, &AtomicTest_brightness) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_decrementPosition(void) {\n    do {\n        uint16_t __old = __LDREXH(&AtomicTest_position);\n        uint16_t __new = cnx_clamp_sub_u16(__old, 50);\n        if (__STREXH(__new, &AtomicTest_position) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_maskTicks(void) {\n    do {\n        uint32_t __old = __LDREXW(&AtomicTest_ticks);\n        uint32_t __new = __old & 0xFFFF;\n        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_setTickFlag(void) {\n    do {\n        uint32_t __old = __LDREXW(&AtomicTest_ticks);\n        uint32_t __new = __old | 0x80000000;\n        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;\n    } while (1);\n}\n\nvoid AtomicTest_incrementAll(void) {\n    do {\n        uint8_t __old = __LDREXB(&AtomicTest_counterU8);\n        uint8_t __new = cnx_clamp_add_u8(__old, 1);\n        if (__STREXB(__new, &AtomicTest_counterU8) == 0) break;\n    } while (1);\n    do {\n        uint16_t __old = __LDREXH(&AtomicTest_counterU16);\n        uint16_t __new = cnx_clamp_add_u16(__old, 1);\n        if (__STREXH(__new, &AtomicTest_counterU16) == 0) break;\n    } while (1);\n    do {\n        uint32_t __old = __LDREXW(&AtomicTest_counterU32);\n        uint32_t __new = cnx_clamp_add_u32(__old, 1);\n        if (__STREXW(__new, &AtomicTest_counterU32) == 0) break;\n    } while (1);\n    do {\n        uint32_t __old = __LDREXW(&AtomicTest_ticks);\n        uint32_t __new = cnx_clamp_add_u32(__old, 1);\n        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;\n    } while (1);\n}\n\nvoid main(void) {\n    AtomicTest_getCounterU8();\n    AtomicTest_getCounterU16();\n    AtomicTest_getCounterU32();\n    AtomicTest_getBrightness();\n    AtomicTest_getPosition();\n    AtomicTest_getTicks();\n    AtomicTest_incrementU8();\n    AtomicTest_incrementU16();\n    AtomicTest_incrementU32();\n    AtomicTest_decrementBrightness();\n    AtomicTest_decrementPosition();\n    AtomicTest_maskTicks();\n    AtomicTest_setTickFlag();\n    AtomicTest_incrementAll();\n}\n",
        "last_modified": "2026-01-10T07:02:20.265501"
      },
      "task_intent": {
        "title": "100% Scope Testing Coverage",
        "description": "Expand the C-Next test suite to achieve comprehensive coverage of scope-related functionality including this./global. accessors with all data types, modifier permutations, and error cases.",
        "from_plan": true
      },
      "commits_behind_main": 1,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-09T22:16:23.126155",
  "last_updated": "2026-01-09T22:16:23.127756"
}