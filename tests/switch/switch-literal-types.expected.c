/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// ADR-025: Switch with different literal formats
// Tests: hex, binary, and char literals in case labels
// Coverage: Section 7 (Control Flow) - case label literal types
uint32_t result = 0;

// Hex literal cases
void testHexCases(const uint8_t* val) {
    switch ((*val)) {
        case 0x00: {
            result = 1;
            break;
        }
        case 0x0F: {
            result = 2;
            break;
        }
        case 0x10: {
            result = 3;
            break;
        }
        case 0x7F: {
            result = 4;
            break;
        }
        case 0x80: {
            result = 5;
            break;
        }
        case 0xFF: {
            result = 6;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Binary literal cases
void testBinaryCases(const uint8_t* val) {
    switch ((*val)) {
        case 0x0: {
            result = 10;
            break;
        }
        case 0x1: {
            result = 11;
            break;
        }
        case 0xF: {
            result = 12;
            break;
        }
        case 0x7F: {
            result = 13;
            break;
        }
        case 0x80: {
            result = 14;
            break;
        }
        case 0xFF: {
            result = 15;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Char literal cases
void testCharCases(const uint8_t* val) {
    switch ((*val)) {
        case 'A': {
            result = 20;
            break;
        }
        case 'Z': {
            result = 21;
            break;
        }
        case 'a': {
            result = 22;
            break;
        }
        case 'z': {
            result = 23;
            break;
        }
        case '0': {
            result = 24;
            break;
        }
        case '9': {
            result = 25;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Mixed literal types in same switch
void testMixedLiterals(const uint8_t* val) {
    switch ((*val)) {
        case 0: {
            result = 30;
            break;
        }
        case 0x0A: {
            result = 31;
            break;
        }
        case 0x14: {
            result = 32;
            break;
        }
        case 'X': {
            result = 33;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Large hex values (u16)
void testLargeHex(const uint16_t* val) {
    switch ((*val)) {
        case 0x0000: {
            result = 40;
            break;
        }
        case 0x00FF: {
            result = 41;
            break;
        }
        case 0x0100: {
            result = 42;
            break;
        }
        case 0x7FFF: {
            result = 43;
            break;
        }
        case 0x8000: {
            result = 44;
            break;
        }
        case 0xFFFF: {
            result = 45;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

int main(void) {
    uint8_t h00 = 0x00;
    uint8_t h0F = 0x0F;
    uint8_t h10 = 0x10;
    uint8_t h7F = 0x7F;
    uint8_t h80 = 0x80;
    uint8_t hFF = 0xFF;
    uint8_t hOther = 0x50;
    testHexCases(&h00);
    if (result != 1) return 1;
    testHexCases(&h0F);
    if (result != 2) return 2;
    testHexCases(&h10);
    if (result != 3) return 3;
    testHexCases(&h7F);
    if (result != 4) return 4;
    testHexCases(&h80);
    if (result != 5) return 5;
    testHexCases(&hFF);
    if (result != 6) return 6;
    testHexCases(&hOther);
    if (result != 99) return 7;
    uint8_t b00 = 0b00000000;
    uint8_t b01 = 0b00000001;
    uint8_t b0F = 0b00001111;
    uint8_t b7F = 0b01111111;
    uint8_t b80 = 0b10000000;
    uint8_t bFF = 0b11111111;
    uint8_t bOther = 0b00100000;
    testBinaryCases(&b00);
    if (result != 10) return 8;
    testBinaryCases(&b01);
    if (result != 11) return 9;
    testBinaryCases(&b0F);
    if (result != 12) return 10;
    testBinaryCases(&b7F);
    if (result != 13) return 11;
    testBinaryCases(&b80);
    if (result != 14) return 12;
    testBinaryCases(&bFF);
    if (result != 15) return 13;
    testBinaryCases(&bOther);
    if (result != 99) return 14;
    uint8_t cA = 'A';
    uint8_t cZ = 'Z';
    uint8_t ca = 'a';
    uint8_t cz = 'z';
    uint8_t c0 = '0';
    uint8_t c9 = '9';
    uint8_t cOther = 'X';
    testCharCases(&cA);
    if (result != 20) return 15;
    testCharCases(&cZ);
    if (result != 21) return 16;
    testCharCases(&ca);
    if (result != 22) return 17;
    testCharCases(&cz);
    if (result != 23) return 18;
    testCharCases(&c0);
    if (result != 24) return 19;
    testCharCases(&c9);
    if (result != 25) return 20;
    testCharCases(&cOther);
    if (result != 99) return 21;
    uint8_t m0 = 0;
    uint8_t m10 = 10;
    uint8_t m20 = 20;
    uint8_t mX = 'X';
    uint8_t mOther = 100;
    testMixedLiterals(&m0);
    if (result != 30) return 22;
    testMixedLiterals(&m10);
    if (result != 31) return 23;
    testMixedLiterals(&m20);
    if (result != 32) return 24;
    testMixedLiterals(&mX);
    if (result != 33) return 25;
    testMixedLiterals(&mOther);
    if (result != 99) return 26;
    uint16_t l0000 = 0x0000;
    uint16_t l00FF = 0x00FF;
    uint16_t l0100 = 0x0100;
    uint16_t l7FFF = 0x7FFF;
    uint16_t l8000 = 0x8000;
    uint16_t lFFFF = 0xFFFF;
    uint16_t lOther = 0x1234;
    testLargeHex(&l0000);
    if (result != 40) return 27;
    testLargeHex(&l00FF);
    if (result != 41) return 28;
    testLargeHex(&l0100);
    if (result != 42) return 29;
    testLargeHex(&l7FFF);
    if (result != 43) return 30;
    testLargeHex(&l8000);
    if (result != 44) return 31;
    testLargeHex(&lFFFF);
    if (result != 45) return 32;
    testLargeHex(&lOther);
    if (result != 99) return 33;
    return 0;
}
