/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: Auto-const with compound assignments
// Coverage: Parameters modified via compound assignment operators
// Compound add - should NOT get const
void addToValue(uint32_t* val, uint32_t amount) {
    (*val) += amount;
}

// Compound subtract - should NOT get const
void subtractFromValue(int32_t* val, int32_t amount) {
    (*val) -= amount;
}

// Compound multiply - should NOT get const
void multiplyValue(uint32_t* val, uint32_t factor) {
    (*val) *= factor;
}

// Read then compound - should NOT get const
uint32_t readAndAdd(uint32_t* val, uint32_t amount) {
    uint32_t original = (*val);
    (*val) += amount;
    return original;
}

// Multiple compound ops - should NOT get const
void multipleCompound(uint32_t* val) {
    (*val) += 10U;
    (*val) *= 2U;
    (*val) -= 5U;
}

// Only reads with arithmetic - SHOULD get const
uint32_t onlyReads(uint32_t a, uint32_t b) {
    return a + b * 2;
}

int main(void) {
    uint32_t x = 100U;
    addToValue(&x, 50U);
    if (x != 150) return 1;
    int32_t y = 100;
    subtractFromValue(&y, 30);
    if (y != 70) return 2;
    uint32_t z = 10U;
    multiplyValue(&z, 5U);
    if (z != 50) return 3;
    uint32_t w = 25U;
    uint32_t original = readAndAdd(&w, 10U);
    if (original != 25) return 4;
    if (w != 35) return 5;
    uint32_t m = 10U;
    multipleCompound(&m);
    if (m != 35) return 6;
    uint32_t a = 5U;
    uint32_t b = 3U;
    uint32_t result = onlyReads(a, b);
    if (result != 11) return 7;
    if (a != 5) return 8;
    if (b != 3) return 9;
    return 0;
}
