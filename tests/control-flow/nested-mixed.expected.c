/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

// test-execution
// Tests: mixed break and continue in nested loops
// Validates: break and continue work correctly together in complex scenarios
int main(void) {
    uint32_t outerProcessed = 0;
    uint32_t innerBreaks = 0;
    for (uint32_t i = 0; i < 10; i += 1) {
        if (i % 2 == 0) {
            continue;
        }
        outerProcessed = cnx_clamp_add_u32(outerProcessed, 1);
        for (uint32_t j = 0; j < 20; j += 1) {
            if (j == 5) {
                innerBreaks = cnx_clamp_add_u32(innerBreaks, 1);
                break;
            }
        }
    }
    if (outerProcessed != 5) return 1;
    if (innerBreaks != 5) return 2;
    uint32_t totalSum = 0;
    uint32_t outerBreakAt = 0;
    for (uint32_t a = 0; a < 100; a += 1) {
        uint32_t innerSum = 0;
        for (uint32_t b = 0; b < 10; b += 1) {
            innerSum = cnx_clamp_add_u32(innerSum, b);
        }
        totalSum = cnx_clamp_add_u32(totalSum, innerSum);
        if (totalSum >= 200) {
            outerBreakAt = a;
            break;
        }
    }
    if (outerBreakAt != 4) return 3;
    if (totalSum != 225) return 4;
    uint32_t validCount = 0;
    uint32_t breakOuter = 0;
    for (uint32_t c = 0; c < 10; c += 1) {
        uint32_t validInner = 0;
        for (uint32_t d = 0; d < 8; d += 1) {
            if (d % 2 == 0) {
                continue;
            }
            validInner = cnx_clamp_add_u32(validInner, 1);
        }
        validCount = cnx_clamp_add_u32(validCount, validInner);
        if (validCount >= 12) {
            breakOuter = c;
            break;
        }
    }
    if (breakOuter != 2) return 5;
    if (validCount != 12) return 6;
    uint32_t foundRow = 99;
    uint32_t foundCol = 99;
    bool found = false;
    for (uint32_t row = 0; row < 5; row += 1) {
        if (found) {
            break;
        }
        for (uint32_t col = 0; col < 5; col += 1) {
            if (row == 3 && col == 2) {
                foundRow = row;
                foundCol = col;
                found = true;
                break;
            }
        }
    }
    if (foundRow != 3) return 7;
    if (foundCol != 2) return 8;
    if (!found) return 9;
    uint32_t processed = 0;
    uint32_t broken = 0;
    for (uint32_t e = 0; e < 4; e += 1) {
        for (uint32_t f = 0; f < 10; f += 1) {
            if (f % 3 == 0) {
                continue;
            }
            if (f >= 7) {
                broken = cnx_clamp_add_u32(broken, 1);
                break;
            }
            processed = cnx_clamp_add_u32(processed, 1);
        }
    }
    if (processed != 16) return 10;
    if (broken != 4) return 11;
    return 0;
}
