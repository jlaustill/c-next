/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <limits.h>

// test-execution
// Issue #107: Negative Case Labels - i64 Type
// Tests: negative literals with i64 switch expressions
// Note: Avoids INT64_MIN/MAX due to JS parseInt precision limits in duplicate detection
int32_t result = 0;

// Test i64 with various negative values (within JS safe integer range)
void testI64Values(int64_t val) {
    switch (val) {
        case -9007199254740991: {
            result = 1;
            break;
        }
        case -1000000000000000: {
            result = 2;
            break;
        }
        case -1000000000000: {
            result = 3;
            break;
        }
        case -2147483649: {
            result = 4;
            break;
        }
        case -2147483648: {
            result = 5;
            break;
        }
        case -1: {
            result = 6;
            break;
        }
        case 0: {
            result = 7;
            break;
        }
        case 2147483647: {
            result = 8;
            break;
        }
        case 2147483648: {
            result = 9;
            break;
        }
        case 1000000000000: {
            result = 10;
            break;
        }
        case 1000000000000000: {
            result = 11;
            break;
        }
        case 9007199254740991: {
            result = 12;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Test negative hex with i64 values
// Note: Avoids -0x80000000 due to C's unsigned hex literal interpretation
void testI64Hex(int64_t val) {
    switch (val) {
        case -0x100000000: {
            result = 20;
            break;
        }
        case -0x7FFFFFFF: {
            result = 21;
            break;
        }
        case -0x1000000: {
            result = 22;
            break;
        }
        case -0xFF: {
            result = 23;
            break;
        }
        case 0x00: {
            result = 24;
            break;
        }
        case 0x100000000: {
            result = 25;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

int main(void) {
    int64_t minSafe = -9007199254740991;
    int64_t negQuad = -1000000000000000;
    int64_t negTrillion = -1000000000000;
    int64_t negBeyondI32 = -2147483649;
    int64_t negI32Min = (int32_t)INT32_MIN;
    int64_t negOne = -1;
    int64_t zero = 0;
    int64_t posI32Max = 2147483647;
    int64_t posBeyondI32 = 2147483648;
    int64_t posTrillion = 1000000000000;
    int64_t posQuad = 1000000000000000;
    int64_t maxSafe = 9007199254740991;
    int64_t other = 123456789;
    testI64Values(minSafe);
    if (result != 1) return 1;
    testI64Values(negQuad);
    if (result != 2) return 2;
    testI64Values(negTrillion);
    if (result != 3) return 3;
    testI64Values(negBeyondI32);
    if (result != 4) return 4;
    testI64Values(negI32Min);
    if (result != 5) return 5;
    testI64Values(negOne);
    if (result != 6) return 6;
    testI64Values(zero);
    if (result != 7) return 7;
    testI64Values(posI32Max);
    if (result != 8) return 8;
    testI64Values(posBeyondI32);
    if (result != 9) return 9;
    testI64Values(posTrillion);
    if (result != 10) return 10;
    testI64Values(posQuad);
    if (result != 11) return 11;
    testI64Values(maxSafe);
    if (result != 12) return 12;
    testI64Values(other);
    if (result != 99) return 13;
    int64_t negBeyondU32 = -4294967296;
    testI64Hex(negBeyondU32);
    if (result != 20) return 14;
    int64_t negI32Max = -2147483647;
    testI64Hex(negI32Max);
    if (result != 21) return 15;
    int64_t neg16M = -16777216;
    testI64Hex(neg16M);
    if (result != 22) return 16;
    int64_t neg255 = -255;
    testI64Hex(neg255);
    if (result != 23) return 17;
    testI64Hex(zero);
    if (result != 24) return 18;
    int64_t posBeyondU32 = 4294967296;
    testI64Hex(posBeyondU32);
    if (result != 25) return 19;
    return 0;
}
