// test-execution
// Tests: Struct parameters are always pass-by-reference (ADR-006)
// Coverage: Struct modification visible to caller

struct Point {
    i32 x;
    i32 y;
}

struct Counter {
    u32 value;
    u32 maxValue;
}

// Struct params are ALWAYS pass-by-reference in C-Next
// Modifications are visible to caller
void movePoint(Point p, i32 dx, i32 dy) {
    p.x +<- dx;
    p.y +<- dy;
}

void resetPoint(Point p) {
    p.x <- 0;
    p.y <- 0;
}

void incrementCounter(Counter c) {
    if (c.value < c.maxValue) {
        c.value +<- 1;
    }
}

void setCounterMax(Counter c, u32 newMax) {
    c.maxValue <- newMax;
}

// Read-only struct access (still pass-by-reference, but const)
i32 getPointSum(Point p) {
    return p.x + p.y;
}

u32 getCounterValue(Counter c) {
    return c.value;
}

bool isCounterAtMax(Counter c) {
    return c.value = c.maxValue;
}

u32 main() {
    // Test struct modification visible to caller
    Point pt <- {x: 10, y: 20};
    movePoint(pt, 5, -3);
    if (pt.x != 15) return 1;
    if (pt.y != 17) return 2;

    // Test struct reset
    resetPoint(pt);
    if (pt.x != 0) return 3;
    if (pt.y != 0) return 4;

    // Test counter increment
    Counter cnt <- {value: 0, maxValue: 5};
    incrementCounter(cnt);
    if (cnt.value != 1) return 5;

    incrementCounter(cnt);
    incrementCounter(cnt);
    if (cnt.value != 3) return 6;

    // Test counter max limit
    cnt.value <- 5;
    incrementCounter(cnt);
    if (cnt.value != 5) return 7;

    // Test setting counter max
    setCounterMax(cnt, 10);
    if (cnt.maxValue != 10) return 8;

    // Now can increment again
    incrementCounter(cnt);
    if (cnt.value != 6) return 9;

    // Test read-only struct functions
    Point readPt <- {x: 100, y: 200};
    i32 sum <- getPointSum(readPt);
    if (sum != 300) return 10;
    if (readPt.x != 100) return 11;
    if (readPt.y != 200) return 12;

    Counter readCnt <- {value: 42, maxValue: 100};
    u32 val <- getCounterValue(readCnt);
    if (val != 42) return 13;

    bool atMax <- isCounterAtMax(readCnt);
    if (atMax != false) return 14;

    readCnt.value <- 100;
    atMax <- isCounterAtMax(readCnt);
    if (atMax != true) return 15;

    return 0;
}
