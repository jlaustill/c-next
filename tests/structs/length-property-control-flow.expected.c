/**
 * Generated by C-Next Transpiler from: length-property-control-flow.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-execution
// Regression test: .length in control flow expressions
// Tests if, while, for, and switch with .length property
typedef struct Packet {
    uint32_t header;
    uint16_t pktLength;
    uint8_t type;
    uint64_t payload;
} Packet;

int main(void) {
    Packet pkt = {0};
    pkt.header = 0xDEADBEEFU;
    pkt.pktLength = 256U;
    pkt.type = 1U;
    pkt.payload = 0x123456789ABCDEFULL;
    if (32 != 32) {
        return 1;
    }
    if (32 != 32) return 2;
    if (8 != 8) return 3;
    uint32_t counter = 0U;
    uint32_t maxBits = 32;
    while ((counter < maxBits) != false) {
        counter = cnx_clamp_add_u32(counter, 8U);
    }
    if (counter != 32) return 4;
    uint32_t totalBits = 0U;
    for (uint32_t i = 0; (i < 4) != false; i += 1) {
        totalBits = cnx_clamp_add_u32(totalBits, 8);
    }
    if (totalBits != 32) return 5;
    uint32_t fieldSize = ((32 > 16U) != false) ? 4U : 2U;
    if (fieldSize != 4) return 6;
    uint32_t headerBytes = 32 / 8U;
    if (headerBytes != 4) {
        return 7;
    }
    if (32 != 32) {
        return 8;
    }
    if (64 != 64) {
        return 9;
    }
    return 0;
}
