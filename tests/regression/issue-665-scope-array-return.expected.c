/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "issue-665-scope-array-return.test.h"

#include <stdint.h>

// test-execution
// Tests: Scope array return with enum index
// Issue #665: Returning this.values[idx] from scope generates bit extraction
// instead of array access when array is sized by enum
// Test 1: Basic enum-sized array with enum index (original bug)
/* Scope: Test */
static float Test_values[EIndex_COUNT] = {0};

void Test_set(EIndex idx, float value) {
    Test_values[idx] = value;
}

float Test_get(EIndex idx) {
    return Test_values[idx];
}

// Test 2: Enum-sized array with integer index
/* Scope: TestIntIndex */
static int32_t TestIntIndex_data[EIndex_COUNT] = {0};

void TestIntIndex_set(uint8_t idx, int32_t value) {
    TestIntIndex_data[idx] = value;
}

int32_t TestIntIndex_get(uint8_t idx) {
    return TestIntIndex_data[idx];
}

// Test 3: Literal-sized array (regression check - should still work)
/* Scope: TestLiteral */
static uint16_t TestLiteral_items[4] = {0};

void TestLiteral_set(uint8_t idx, uint16_t value) {
    TestLiteral_items[idx] = value;
}

uint16_t TestLiteral_get(uint8_t idx) {
    return TestLiteral_items[idx];
}

// Test 4: Multiple arrays in same scope
/* Scope: TestMultiple */
static uint8_t TestMultiple_first[EIndex_COUNT] = {0};
static uint8_t TestMultiple_second[EIndex_COUNT] = {0};

void TestMultiple_setFirst(EIndex idx, uint8_t value) {
    TestMultiple_first[idx] = value;
}

uint8_t TestMultiple_getFirst(EIndex idx) {
    return TestMultiple_first[idx];
}

void TestMultiple_setSecond(EIndex idx, uint8_t value) {
    TestMultiple_second[idx] = value;
}

uint8_t TestMultiple_getSecond(EIndex idx) {
    return TestMultiple_second[idx];
}

// Test 5: Return with index arithmetic
/* Scope: TestArithmetic */
static int32_t TestArithmetic_arr[EIndex_COUNT] = {0};

void TestArithmetic_set(uint8_t idx, int32_t value) {
    TestArithmetic_arr[idx] = value;
}

int32_t TestArithmetic_getNext(uint8_t idx) {
    return TestArithmetic_arr[idx + 1U];
}

int32_t TestArithmetic_getPrev(uint8_t idx) {
    return TestArithmetic_arr[idx - 1U];
}

int main(void) {
    Test_set(EIndex_FIRST, 1.0);
    Test_set(EIndex_SECOND, 2.0);
    Test_set(EIndex_THIRD, 3.0);
    float v1 = Test_get(EIndex_FIRST);
    float v2 = Test_get(EIndex_SECOND);
    float v3 = Test_get(EIndex_THIRD);
    if (v1 != 1.0) return 1;
    if (v2 != 2.0) return 2;
    if (v3 != 3.0) return 3;
    TestIntIndex_set(0U, 100);
    TestIntIndex_set(1U, 200);
    TestIntIndex_set(2U, 300);
    int32_t d1 = TestIntIndex_get(0U);
    int32_t d2 = TestIntIndex_get(1U);
    int32_t d3 = TestIntIndex_get(2U);
    if (d1 != 100) return 4;
    if (d2 != 200) return 5;
    if (d3 != 300) return 6;
    TestLiteral_set(0U, 1000U);
    TestLiteral_set(1U, 2000U);
    TestLiteral_set(2U, 3000U);
    TestLiteral_set(3U, 4000U);
    uint16_t l1 = TestLiteral_get(0U);
    uint16_t l2 = TestLiteral_get(1U);
    uint16_t l3 = TestLiteral_get(2U);
    uint16_t l4 = TestLiteral_get(3U);
    if (l1 != 1000) return 7;
    if (l2 != 2000) return 8;
    if (l3 != 3000) return 9;
    if (l4 != 4000) return 10;
    TestMultiple_setFirst(EIndex_FIRST, 10U);
    TestMultiple_setFirst(EIndex_SECOND, 20U);
    TestMultiple_setSecond(EIndex_FIRST, 30U);
    TestMultiple_setSecond(EIndex_SECOND, 40U);
    uint8_t m1 = TestMultiple_getFirst(EIndex_FIRST);
    uint8_t m2 = TestMultiple_getFirst(EIndex_SECOND);
    uint8_t m3 = TestMultiple_getSecond(EIndex_FIRST);
    uint8_t m4 = TestMultiple_getSecond(EIndex_SECOND);
    if (m1 != 10) return 11;
    if (m2 != 20) return 12;
    if (m3 != 30) return 13;
    if (m4 != 40) return 14;
    TestArithmetic_set(0U, 111);
    TestArithmetic_set(1U, 222);
    TestArithmetic_set(2U, 333);
    int32_t a1 = TestArithmetic_getNext(0U);
    int32_t a2 = TestArithmetic_getNext(1U);
    int32_t a3 = TestArithmetic_getPrev(1U);
    int32_t a4 = TestArithmetic_getPrev(2U);
    if (a1 != 222) return 15;
    if (a2 != 333) return 16;
    if (a3 != 111) return 17;
    if (a4 != 222) return 18;
    return 0;
}
