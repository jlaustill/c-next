/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// test-execution
// Tests: Slice assignment with different array types
// Validates that slice assignment works with u8[], u16[], u32[], u64[], and string buffers
// Ensures type-agnostic byte copying behavior
int main(void) {
    uint8_t arr8[32] = {0};
    uint32_t value1 = 0x11223344U;
    memcpy(&arr8[0], &value1, 4);
    if (arr8[0U] != 0x44) return 1;
    if (arr8[1U] != 0x33) return 2;
    if (arr8[2U] != 0x22) return 3;
    if (arr8[3U] != 0x11) return 4;
    uint16_t arr16[16] = {0};
    uint64_t value2 = 0x0102030405060708ULL;
    memcpy(&arr16[0], &value2, 8);
    if (arr16[0U] != 0x0708) return 5;
    if (arr16[1U] != 0x0506) return 6;
    if (arr16[2U] != 0x0304) return 7;
    if (arr16[3U] != 0x0102) return 8;
    uint32_t arr32[16] = {0};
    uint32_t value3 = 0xAABBCCDDU;
    memcpy(&arr32[0], &value3, 4);
    if (arr32[0U] != 0xAABBCCDD) return 9;
    uint64_t arr64[8] = {0};
    uint64_t value4 = 0x123456789ABCDEF0ULL;
    memcpy(&arr64[0], &value4, 8);
    if (arr64[0U] != 0x123456789ABCDEF0) return 10;
    uint8_t buffer[64] = {0};
    uint32_t value5 = 0x55667788U;
    memcpy(&buffer[0], &value5, 4);
    if (buffer[0U] != 0x88) return 11;
    if (buffer[1U] != 0x77) return 12;
    if (buffer[2U] != 0x66) return 13;
    if (buffer[3U] != 0x55) return 14;
    uint8_t multiArr[32] = {0};
    uint32_t val1 = 0x11111111U;
    uint32_t val2 = 0x22222222U;
    uint32_t val3 = 0x33333333U;
    memcpy(&multiArr[0], &val1, 4);
    memcpy(&multiArr[4], &val2, 4);
    memcpy(&multiArr[8], &val3, 4);
    if (multiArr[0U] != 0x11) return 15;
    if (multiArr[4U] != 0x22) return 16;
    if (multiArr[8U] != 0x33) return 17;
    return 0;
}
