/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "scope-call-no-auto-const.test.h"

#include <stdint.h>
#include <stdbool.h>

// test-execution
// Tests: Issue #365 - scope-qualified calls should prevent auto-const
// When a parameter is passed to a scope method that modifies it,
// the parameter should NOT get const in the generated header.
// Simulates a storage manager that modifies the config it receives
/* Scope: Storage */

void Storage_load(AppConfig* config) {
    config->value = 42U;
    config->enabled = true;
}

void Storage_save(const AppConfig* config) {
    uint32_t temp = config->value;
}

// Function that passes its parameter to Storage.load()
// Since Storage.load() modifies its param, this param should NOT get const
void loadConfig(AppConfig* config) {
    Storage_load(config);
}

// Function that passes its parameter to Storage.save()
// Since Storage.save() only reads, this param SHOULD get const
void saveConfig(const AppConfig* config) {
    Storage_save(config);
}

// Direct call to scope method that modifies - should NOT get const
void directLoad(AppConfig* config) {
    Storage_load(config);
}

int main(void) {
    AppConfig cfg = {0};
    cfg.value = 0U;
    cfg.enabled = false;
    loadConfig(&cfg);
    if (cfg.value != 42) return 1;
    if (cfg.enabled != true) return 2;
    cfg.value = 100U;
    cfg.enabled = false;
    directLoad(&cfg);
    if (cfg.value != 42) return 3;
    if (cfg.enabled != true) return 4;
    cfg.value = 999U;
    saveConfig(&cfg);
    if (cfg.value != 999) return 5;
    return 0;
}
