// test-coverage: 5.1-i32-and, 5.2-i32-or, 5.3-i32-xor, 5.4-i32-not
// test-execution
// Test i32 bitwise operations: AND, OR, XOR, NOT
// Coverage: Section 5.1-5.4 for i32 type
u32 main() {
    // AND operations with positive values
    i32 a <- 0x7FFF0000; // 2147418112
    i32 b <- 0x55555555; // 1431655765
    i32 and_result <- a & b; // 0x55550000 = 1431633920

    // AND with negative values
    i32 neg_a <- -65536; // 0xFFFF0000
    i32 neg_b <- -1; // 0xFFFFFFFF
    i32 neg_and <- neg_a & neg_b; // -65536

    // OR operations
    i32 or_result <- a | b; // 0x7FFF5555 = 2147439957

    // XOR operations
    i32 xor_result <- a ^ b; // 0x2AAA5555 = 715806037

    // NOT operations - positive to negative
    i32 c <- 2147483647; // 0x7FFFFFFF (max positive)
    i32 not_pos <- ~c; // 0x80000000 = -2147483648

    // NOT operations - negative to positive
    i32 d <- -2147483648; // 0x80000000 (min negative)
    i32 not_neg <- ~d; // 0x7FFFFFFF = 2147483647

    // Edge case: NOT of -1
    i32 minus_one <- -1;
    i32 not_minus_one <- ~minus_one; // 0

   
// Test with smaller values
    i32 small_a <- 0xFFA0;
    i32 small_b <- 0xAA;
    i32 small_and <- small_a & small_b; // 0xA0 = 160

    // Verify results
    if (and_result = 1431633920 && or_result = 2147439957) {
        if (not_pos = -2147483648 && not_neg = 2147483647 && not_minus_one = 0) {
            if (neg_and = -65536 && small_and = 160) {
                return 0;
            }
        }
    }
    return 1;
}
