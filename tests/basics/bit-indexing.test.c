/**
 * Generated by C-Next Transpiler from: bit-indexing.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: Bit indexing syntax (C-Next specific)
// Demonstrates: value[start, width] for bit extraction
int main(void) {
    uint32_t value = 0xDEADBEEFU;
    uint8_t lowByte = (uint8_t)((value) & 0xFFU);
    if (lowByte != 0xEF) return 1;
    uint8_t byte1 = (uint8_t)((value >> 8U) & 0xFFU);
    if (byte1 != 0xBE) return 2;
    uint8_t byte2 = (uint8_t)((value >> 16U) & 0xFFU);
    if (byte2 != 0xAD) return 3;
    uint8_t highByte = (uint8_t)((value >> 24U) & 0xFFU);
    if (highByte != 0xDE) return 4;
    uint8_t lowNibble = (uint8_t)((value) & ((1U << 4U) - 1));
    if (lowNibble != 0x0F) return 5;
    uint8_t highNibble = (uint8_t)((value >> 4U) & ((1U << 4U) - 1));
    if (highNibble != 0x0E) return 6;
    uint16_t lowWord = (uint16_t)((value) & 0xFFFFU);
    if (lowWord != 0xBEEF) return 7;
    uint16_t highWord = (uint16_t)((value >> 16U) & 0xFFFFU);
    if (highWord != 0xDEAD) return 8;
    uint8_t testVal = 0b10101010U;
    uint8_t bit0 = (uint8_t)((testVal) & ((1U << 1U) - 1));
    if (bit0 != 0) return 9;
    uint8_t bit1 = (uint8_t)((testVal >> 1U) & ((1U << 1U) - 1));
    if (bit1 != 1) return 10;
    uint8_t bit7 = (uint8_t)((testVal >> 7U) & ((1U << 1U) - 1));
    if (bit7 != 1) return 11;
    return 0;
}
