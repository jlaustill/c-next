/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (a > UINT64_MAX - b) return UINT64_MAX;
    return a + b;
}

/* test-execution */
// Tests: u64 comparison operations (<, >, <=, >=, =, !=)
// Validates all comparison operators with u64 type
// Includes edge cases with zero, max values, and typical embedded use cases
bool result = false;

void test_equality(void) {
    uint64_t a = 1000000000000;
    uint64_t b = 1000000000000;
    uint64_t c = 2000000000000;
    result = (a == b);
    result = (a == c);
    result = (a != c);
    result = (a != b);
    uint64_t zero = 0;
    result = (zero == 0);
    result = (zero != 1);
}

void test_less_than(void) {
    uint64_t small = 1000;
    uint64_t large = 1000000000000;
    result = (small < large);
    result = (large < small);
    result = (small < small);
    result = (small <= large);
    result = (small <= small);
    result = (large <= small);
    uint64_t zero = 0;
    result = (zero < 1);
    result = (zero <= 0);
}

void test_greater_than(void) {
    uint64_t small = 1000;
    uint64_t large = 1000000000000;
    result = (large > small);
    result = (small > large);
    result = (small > small);
    result = (large >= small);
    result = (small >= small);
    result = (small >= large);
    uint64_t zero = 0;
    result = (1 > zero);
    result = (zero >= 0);
}

void test_literal_comparison(void) {
    uint64_t val = 1000000000000;
    result = (val == 1000000000000);
    result = (val != 1000000000000);
    result = (val < 2000000000000);
    result = (val < 500000000000);
    result = (val > 500000000000);
    result = (val > 2000000000000);
    result = (val <= 1000000000000);
    result = (val <= 2000000000000);
    result = (val >= 1000000000000);
    result = (val >= 500000000000);
}

void test_in_control_flow(void) {
    uint64_t counter = 0;
    if (counter < 1000000) {
        result = true;
    }
    while (counter < 100) {
        counter = cnx_clamp_add_u64(counter, 1);
        if (counter >= 50) {
            counter = 100;
        }
    }
    if (counter == 100) {
        result = true;
    }
    uint64_t threshold = 1000000000;
    if (counter > 0) {
        if (counter < threshold) {
            result = true;
        }
    }
}

void test_edge_cases(void) {
    uint64_t zero = 0;
    uint64_t max = 18446744073709551615;
    uint64_t near_max = 18446744073709551614;
    result = (zero < 1);
    result = (zero == 0);
    result = (0 <= zero);
    result = (zero < max);
    result = (max > zero);
    result = (max >= max);
    result = (max == max);
    result = (near_max < max);
    result = (near_max != max);
    result = (near_max <= max);
    uint64_t timestamp_2020 = 1577836800000;
    uint64_t timestamp_2021 = 1609459200000;
    result = (timestamp_2021 > timestamp_2020);
    result = (timestamp_2021 != timestamp_2020);
}

void test_comparison_chains(void) {
    uint64_t a = 1000;
    uint64_t b = 5000;
    uint64_t c = 10000;
    if (a < b) {
        if (b < c) {
            result = true;
        }
    }
    if ((a < b) == true) {
        result = true;
    }
    bool less = (a < b);
    bool greater = (c > b);
    result = less;
    result = greater;
}

uint32_t main(void) {
    test_equality();
    test_less_than();
    test_greater_than();
    test_literal_comparison();
    test_in_control_flow();
    test_edge_cases();
    test_comparison_chains();
    return 0;
}
