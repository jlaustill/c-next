/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int8_t cnx_clamp_add_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a + b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline uint16_t cnx_clamp_add_u16(uint16_t a, uint32_t b) {
    if (b > UINT16_MAX - a) return UINT16_MAX;
    return a + (uint16_t)b;
}

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint32_t b) {
    if (b > UINT8_MAX - a) return UINT8_MAX;
    return a + (uint8_t)b;
}

static inline uint8_t cnx_clamp_mul_u8(uint8_t a, uint32_t b) {
    if (b != 0 && a > UINT8_MAX / b) return UINT8_MAX;
    return a * (uint8_t)b;
}

static inline int16_t cnx_clamp_sub_i16(int16_t a, int32_t b) {
    int32_t result = (int32_t)a - b;
    if (result > INT16_MAX) return INT16_MAX;
    if (result < INT16_MIN) return INT16_MIN;
    return (int16_t)result;
}

static inline int8_t cnx_clamp_sub_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a - b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint32_t b) {
    if (b >= (uint32_t)a) return 0;
    return a - (uint16_t)b;
}

static inline uint32_t cnx_clamp_sub_u32(uint32_t a, uint64_t b) {
    if (b >= (uint64_t)a) return 0;
    return a - (uint32_t)b;
}

static inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint32_t b) {
    if (b >= (uint32_t)a) return 0;
    return a - (uint8_t)b;
}

// test-execution
// Tests: clamp with operands larger than target type range
// Issue #94: Prevents silent truncation when operand exceeds type bounds
// ADR-044: Per-variable overflow semantics
int main(void) {
    uint8_t val8 = 200;
    val8 = cnx_clamp_sub_u8(val8, 300);
    if (val8 != 0) return 1;
    val8 = 100;
    val8 = cnx_clamp_add_u8(val8, 300);
    if (val8 != 255) return 2;
    val8 = 10;
    val8 = cnx_clamp_mul_u8(val8, 300);
    if (val8 != 255) return 3;
    val8 = 100;
    val8 = cnx_clamp_sub_u8(val8, 256);
    if (val8 != 0) return 4;
    uint16_t val16 = 1000;
    val16 = cnx_clamp_sub_u16(val16, 70000);
    if (val16 != 0) return 5;
    val16 = 1000;
    val16 = cnx_clamp_add_u16(val16, 70000);
    if (val16 != 65535) return 6;
    uint32_t val32 = 1000;
    val32 = cnx_clamp_sub_u32(val32, 5000000000);
    if (val32 != 0) return 7;
    val32 = 4000000000;
    val32 = cnx_clamp_add_u32(val32, 5000000000);
    if (val32 != 4294967295) return 8;
    int8_t vali8 = 50;
    vali8 = cnx_clamp_sub_i8(vali8, 200);
    if (vali8 != -128) return 9;
    vali8 = 50;
    vali8 = cnx_clamp_add_i8(vali8, 200);
    if (vali8 != 127) return 10;
    int16_t vali16 = 1000;
    vali16 = cnx_clamp_sub_i16(vali16, 40000);
    if (vali16 != -32768) return 11;
    val8 = 10;
    val8 = cnx_clamp_add_u8(val8, 255);
    if (val8 != 255) return 12;
    val8 = 100;
    val8 = cnx_clamp_add_u8(val8, 50);
    if (val8 != 150) return 13;
    val8 = 100;
    val8 = cnx_clamp_sub_u8(val8, 0);
    if (val8 != 100) return 14;
    val8 = 100;
    val8 = cnx_clamp_sub_u8(val8, 256);
    if (val8 != 0) return 15;
    val8 = 50;
    val8 = cnx_clamp_sub_u8(val8, 512);
    if (val8 != 0) return 16;
    val8 = 100;
    val8 = cnx_clamp_sub_u8(val8, 257);
    if (val8 != 0) return 17;
    val8 = 200;
    val8 = cnx_clamp_sub_u8(val8, 300);
    if (val8 != 0) return 18;
    val8 = 100;
    val8 = cnx_clamp_add_u8(val8, 256);
    if (val8 != 255) return 19;
    val16 = 1000;
    val16 = cnx_clamp_sub_u16(val16, 65536);
    if (val16 != 0) return 20;
    val16 = 1000;
    val16 = cnx_clamp_sub_u16(val16, 65537);
    if (val16 != 0) return 21;
    return 0;
}
