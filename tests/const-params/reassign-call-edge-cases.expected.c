/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "reassign-call-edge-cases.test.h"

#include <stdint.h>
#include <stdbool.h>

// ADR-050: IRQ wrappers to avoid macro collisions with platform headers
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-execution
// Tests: Issue #565 edge cases - comprehensive coverage for reassignment const inference
// Covers: nested conditionals, switch, do-while, critical, compound assignments,
// this.method calls, nested calls, multiple params
/* Scope: Handler */

uint8_t Handler_setValue(Config* cfg, uint32_t val) {
    cfg->value = val;
    return 0;
}

uint8_t Handler_setSecond(uint32_t dummy, Config* cfg) {
    cfg->value = 999;
    return 0;
}

uint32_t Handler_getValue(const Config* cfg) {
    return cfg->value;
}

uint8_t Handler_wrapSetValue(Config* cfg, uint32_t val) {
    return Handler_setValue(cfg, val);
}

// Edge case 1: Nested conditionals
void handleNestedIf(Config* config) {
    uint8_t errorCode = 0;
    bool a = true;
    bool b = true;
    if (a) {
        if (b) {
            errorCode = Handler_setValue(config, 10);
        }
    }
}

// Edge case 2: Switch statement
void handleSwitch(Config* config) {
    uint8_t errorCode = 0;
    uint32_t choice = 1;
    switch (choice) {
        case 0: {
            errorCode = 0;
            break;
        }
        case 1: {
            errorCode = Handler_setValue(config, 20);
            break;
        }
        default: {
            errorCode = 2;
            break;
        }
    }
}

// Edge case 3: do-while loop
void handleDoWhile(Config* config) {
    uint8_t errorCode = 0;
    uint32_t count = 0;
    do {
        errorCode = Handler_setValue(config, 30);
        count = count + 1;
    } while (count < 1);
}

// Edge case 4: Critical block
void handleCritical(Config* config) {
    uint8_t errorCode = 0;
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        errorCode = Handler_setValue(config, 40);
        __cnx_set_PRIMASK(__primask);
    }
}

// Edge case 5: this.method() call in reassignment (within a scope)
/* Scope: Processor */

static uint8_t Processor_helper(Config* cfg) {
    cfg->value = 50;
    return 0;
}

void Processor_process(Config* config) {
    uint8_t errorCode = 0;
    errorCode = Processor_helper(config);
}

// Edge case 6: Second parameter is modified (not first)
void handleSecondParam(Config* config) {
    uint8_t errorCode = 0;
    uint32_t dummy = 0;
    errorCode = Handler_setSecond(dummy, config);
}

// Edge case 7: Nested function call in RHS
void handleNestedCall(const Config* config) {
    uint32_t result = 0;
    result = Handler_getValue(config);
}

// Edge case 8: Transitive modification via wrapper
void handleTransitive(Config* config) {
    uint8_t errorCode = 0;
    errorCode = Handler_wrapSetValue(config, 60);
}

// Edge case 9: Multiple reassignments, only one modifies
void handleMultipleReassign(Config* config) {
    uint8_t errorCode = 0;
    uint32_t readVal = 0;
    readVal = Handler_getValue(config);
    errorCode = Handler_setValue(config, 70);
}

// Edge case 10: Compound assignment with modifying call
// Note: compound assignment like a +<- b is equivalent to a <- a + b
// The RHS here is an expression, so we need to ensure it's walked
void handleCompoundAssign(const Config* config) {
    uint32_t total = 0;
    total = cnx_clamp_add_u32(total, Handler_getValue(config));
}

// Edge case 11: Compound assignment where the call modifies
void handleCompoundModify(Config* config) {
    uint32_t total = 0;
    uint8_t code = Handler_setValue(config, 80);
    total = cnx_clamp_add_u32(total, code);
}

int main(void) {
    Config cfg = {0};
    cfg.value = 0;
    handleNestedIf(&cfg);
    if (cfg.value != 10) return 1;
    cfg.value = 0;
    handleSwitch(&cfg);
    if (cfg.value != 20) return 2;
    cfg.value = 0;
    handleDoWhile(&cfg);
    if (cfg.value != 30) return 3;
    cfg.value = 0;
    handleCritical(&cfg);
    if (cfg.value != 40) return 4;
    cfg.value = 0;
    Processor_process(&cfg);
    if (cfg.value != 50) return 5;
    cfg.value = 0;
    handleSecondParam(&cfg);
    if (cfg.value != 999) return 6;
    cfg.value = 123;
    handleNestedCall(&cfg);
    if (cfg.value != 123) return 7;
    cfg.value = 0;
    handleTransitive(&cfg);
    if (cfg.value != 60) return 8;
    cfg.value = 0;
    handleMultipleReassign(&cfg);
    if (cfg.value != 70) return 9;
    cfg.value = 100;
    handleCompoundAssign(&cfg);
    if (cfg.value != 100) return 10;
    cfg.value = 0;
    handleCompoundModify(&cfg);
    if (cfg.value != 80) return 11;
    return 0;
}
