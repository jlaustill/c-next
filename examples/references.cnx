// references.cnx - Demonstrates simplified reference model (ADR-006)
// All parameters pass by reference, assignment updates values

namespace Console {
    void printInt(i32 value) {
        // Print implementation...
    }

    void printHex(u32 value) {
        // Print hex implementation...
    }
}

// Function that modifies its parameter
// No * or & needed - parameters always receive the address
void increment(i32 x) {
    x <- x + 1;  // Updates the original variable
}

// Swap function - clean and simple
void swap(i32 a, i32 b) {
    i32 temp <- a;
    a <- b;
    b <- temp;
}

// Calculate with multiple "output" parameters
void divmod(i32 dividend, i32 divisor, i32 quotient, i32 remainder) {
    quotient <- dividend / divisor;
    remainder <- dividend % divisor;
}

// Process an array (arrays naturally pass by reference)
void zeroArray(u8 buffer[], u32 size) {
    u32 i <- 0;
    while (i < size) {
        buffer[i] <- 0;
        i <- i + 1;
    }
}

// Struct example
struct Point {
    i32 x;
    i32 y;
};

// Move a point (struct passes by reference)
void movePoint(Point p, i32 dx, i32 dy) {
    p.x <- p.x + dx;
    p.y <- p.y + dy;
}

// Main demonstration
void main() {
    // Simple increment
    i32 counter <- 5;
    increment(counter);
    Console.printInt(counter);  // Prints 6

    // Swap
    i32 x <- 10;
    i32 y <- 20;
    swap(x, y);
    Console.printInt(x);  // Prints 20
    Console.printInt(y);  // Prints 10

    // Multiple outputs
    i32 q;
    i32 r;
    divmod(17, 5, q, r);
    Console.printInt(q);  // Prints 3
    Console.printInt(r);  // Prints 2

    // Array
    u8 data[16];
    zeroArray(data, 16);

    // Point
    Point cursor;
    cursor.x <- 0;
    cursor.y <- 0;
    movePoint(cursor, 5, 10);
    Console.printInt(cursor.x);  // Prints 5
    Console.printInt(cursor.y);  // Prints 10

    // Address-of operator (read-only)
    u32 addr <- &counter;
    Console.printHex(addr);  // Prints memory address
}
