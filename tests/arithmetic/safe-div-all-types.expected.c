/**
 * Generated by C-Next Transpiler from: safe-div-all-types.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-051: Safe division helper functions
#include <stdbool.h>

static inline bool cnx_safe_div_u8(uint8_t* output, uint8_t numerator, uint8_t divisor, uint8_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_mod_u8(uint8_t* output, uint8_t numerator, uint8_t divisor, uint8_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator % divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_u16(uint16_t* output, uint16_t numerator, uint16_t divisor, uint16_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_mod_u16(uint16_t* output, uint16_t numerator, uint16_t divisor, uint16_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator % divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_u32(uint32_t* output, uint32_t numerator, uint32_t divisor, uint32_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_mod_u32(uint32_t* output, uint32_t numerator, uint32_t divisor, uint32_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator % divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_u64(uint64_t* output, uint64_t numerator, uint64_t divisor, uint64_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_i8(int8_t* output, int8_t numerator, int8_t divisor, int8_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_i16(int16_t* output, int16_t numerator, int16_t divisor, int16_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_i32(int32_t* output, int32_t numerator, int32_t divisor, int32_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

static inline bool cnx_safe_mod_i32(int32_t* output, int32_t numerator, int32_t divisor, int32_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator % divisor;
    return false;  // Success
}

static inline bool cnx_safe_div_i64(int64_t* output, int64_t numerator, int64_t divisor, int64_t defaultValue) {
    if (divisor == 0) {
        *output = defaultValue;
        return true;  // Error occurred
    }
    *output = numerator / divisor;
    return false;  // Success
}

// ADR-051: Safe division - all integer types
// Verifies safe_div() and safe_mod() work with all integer types
void testSafeDivUnsignedTypes(void) {
    bool err = false;
    uint8_t result_u8 = 0U;
    err = cnx_safe_div_u8(&result_u8, 10, 2, 0);
    uint16_t result_u16 = 0U;
    err = cnx_safe_div_u16(&result_u16, 1000, 10, 0);
    uint32_t result_u32 = 0U;
    err = cnx_safe_div_u32(&result_u32, 100000, 1000, 0);
    uint64_t result_u64 = 0ULL;
    err = cnx_safe_div_u64(&result_u64, 10000000, 1000, 0);
}

void testSafeDivSignedTypes(void) {
    bool err = false;
    int8_t result_i8 = 0;
    err = cnx_safe_div_i8(&result_i8, -10, 2, 0);
    int16_t result_i16 = 0;
    err = cnx_safe_div_i16(&result_i16, -1000, 10, 0);
    int32_t result_i32 = 0;
    err = cnx_safe_div_i32(&result_i32, -100000, 1000, 0);
    int64_t result_i64 = 0;
    err = cnx_safe_div_i64(&result_i64, -10000000, 1000, 0);
}

void testSafeModAllTypes(void) {
    bool err = false;
    uint8_t mod_u8 = 0U;
    err = cnx_safe_mod_u8(&mod_u8, 10, 3, 0);
    uint16_t mod_u16 = 0U;
    err = cnx_safe_mod_u16(&mod_u16, 1000, 7, 0);
    uint32_t mod_u32 = 0U;
    err = cnx_safe_mod_u32(&mod_u32, 100000, 97, 0);
    int32_t mod_i32 = 0;
    err = cnx_safe_mod_i32(&mod_i32, -10, 3, 0);
}

void testSafeDivZeroAllTypes(void) {
    bool err = false;
    uint8_t r8 = 1U;
    err = cnx_safe_div_u8(&r8, 10, 0, r8);
    uint16_t r16 = 2U;
    err = cnx_safe_div_u16(&r16, 10, 0, r16);
    uint32_t r32 = 3U;
    err = cnx_safe_div_u32(&r32, 10, 0, r32);
    uint64_t r64 = 4ULL;
    err = cnx_safe_div_u64(&r64, 10, 0, r64);
}
