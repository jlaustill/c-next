// tests/functions/named-typedef-struct-array.test.cnx
// test-execution
// Tests: Issue #355 - Array member via pointer generates invalid static_cast in C++ mode
// This test reproduces the EXACT pattern from issue #355:
// A scope method calls another scope method, passing a const struct array member.

#include "named-typedef-struct-array.h"

scope Handler {
    // Method that takes an array parameter (target of the call)
    public u32 processBuffer(const u8[8] data, u8 len) {
        u32 sum <- 0;
        u8 i <- 0;
        while (i < len) {
            sum <- sum + data[i];
            i <- i + 1;
        }
        return sum;
    }

    // Method that takes a larger array
    public u32 processData(const u8[16] data, u8 len) {
        u32 sum <- 0;
        u8 i <- 0;
        while (i < len) {
            sum <- sum + data[i];
            i <- i + 1;
        }
        return sum;
    }

    // TEST 1: Named typedef struct with const parameter (the exact #355 bug)
    // The const CAN_message_t msg becomes const CAN_message_t* msg
    // Calling this.processBuffer(msg.buf, msg.len) should generate:
    //   Handler_processBuffer(msg->buf, msg->len)
    // NOT:
    //   uint8_t _cnx_tmp = static_cast<uint8_t>(msg->buf);
    //   Handler_processBuffer(&_cnx_tmp, msg->len);
    public u32 handleMessage(const CAN_message_t msg) {
        return this.processBuffer(msg.buf, msg.len);
    }

    // TEST 2: Multiple array members
    public u32 processMultiArray(const MultiArray_t multi) {
        u32 headerSum <- this.processBuffer(multi.header, 4);
        u32 bodySum <- this.processData(multi.body, multi.sizes[1]);
        return headerSum + bodySum;
    }

    // TEST 3: Non-const struct parameter (should also work)
    public u32 handleMutableMessage(CAN_message_t msg) {
        return this.processBuffer(msg.buf, msg.len);
    }
}

u32 testNamedTypedefConstArrayMember() {
    CAN_message_t msg;
    msg.id <- 1234;
    msg.buf[0] <- 10;
    msg.buf[1] <- 20;
    msg.buf[2] <- 30;
    msg.buf[3] <- 40;
    msg.buf[4] <- 0;
    msg.buf[5] <- 0;
    msg.buf[6] <- 0;
    msg.buf[7] <- 0;
    msg.len <- 4;

    u32 result <- Handler.handleMessage(msg);
    return result;
}

u32 testMultipleArrayMembers() {
    MultiArray_t multi;

    multi.header[0] <- 1;
    multi.header[1] <- 2;
    multi.header[2] <- 3;
    multi.header[3] <- 4;

    multi.body[0] <- 10;
    multi.body[1] <- 20;

    multi.sizes[0] <- 4;
    multi.sizes[1] <- 2;
    multi.sizes[2] <- 2;

    u32 result <- Handler.processMultiArray(multi);
    return result;
}

u32 testNonConstArrayMember() {
    CAN_message_t msg;
    msg.id <- 999;
    msg.buf[0] <- 100;
    msg.buf[1] <- 50;
    msg.len <- 2;

    u32 result <- Handler.handleMutableMessage(msg);
    return result;
}

u32 main() {
    // Test 1: Named typedef struct with const parameter (THE BUG FROM #355)
    u32 result1 <- testNamedTypedefConstArrayMember();
    if (result1 != 100) return 1;

    // Test 2: Multiple array members from same const struct
    u32 result2 <- testMultipleArrayMembers();
    if (result2 != 40) return 2;

    // Test 3: Non-const struct parameter with array member
    u32 result3 <- testNonConstArrayMember();
    if (result3 != 150) return 3;

    return 0;
}
