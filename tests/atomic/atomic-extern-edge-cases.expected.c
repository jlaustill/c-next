/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// test-c-only
// test-coverage: atomic-extern-edge-cases
// Tests: edge cases for atomic volatile qualifier in extern declarations
// Bug #468: Comprehensive coverage to prevent regression

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <cmsis_gcc.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int64_t cnx_clamp_add_i64(int64_t a, int64_t b) {
    if (b > 0 && a > INT64_MAX - b) return INT64_MAX;
    if (b < 0 && a < INT64_MIN - b) return INT64_MIN;
    return a + b;
}

static inline int8_t cnx_clamp_add_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a + b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)(UINT64_MAX - a)) return UINT64_MAX;
    uint64_t result;
    if (__builtin_add_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

// Edge case 1: atomic + const combination
extern const volatile uint32_t CONFIG = 42U;

// Edge case 2: atomic 2D array
volatile uint8_t matrix[4][4] = {0};

// Edge case 3: atomic i64 (signed 64-bit)
volatile int64_t bigSignedCounter = 0;

// Edge case 4: atomic u64 (unsigned 64-bit)
volatile uint64_t bigUnsignedCounter = 0ULL;

// Edge case 5: atomic string type
char statusMessage[17] = "";

// Edge case 6: atomic struct (non-array)
typedef struct TStatus {
    uint32_t code;
    bool active;
} TStatus;

volatile TStatus currentStatus = {0};

// Edge case 7: atomic with wrap + const (multiple modifiers)
volatile uint16_t sequence = 0U;

// Edge case 8: atomic with clamp (saturation)
volatile int8_t temperature = 0;

int main(void) {
    matrix[0][0] = 1;
    {
        uint32_t __primask = __get_PRIMASK();
        __disable_irq();
        bigSignedCounter = cnx_clamp_add_i64(bigSignedCounter, 1);
        __set_PRIMASK(__primask);
    }
    {
        uint32_t __primask = __get_PRIMASK();
        __disable_irq();
        bigUnsignedCounter = cnx_clamp_add_u64(bigUnsignedCounter, 1ULL);
        __set_PRIMASK(__primask);
    }
    currentStatus.active = true;
    do {
        uint16_t __old = __LDREXH(&sequence);
        uint16_t __new = __old + 1U;
        if (__STREXH(__new, &sequence) == 0) break;
    } while (1);
    do {
        int8_t __old = __LDREXB(&temperature);
        int8_t __new = cnx_clamp_add_i8(__old, 10);
        if (__STREXB(__new, &temperature) == 0) break;
    } while (1);
}
