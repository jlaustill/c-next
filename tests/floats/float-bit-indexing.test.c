/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

_Static_assert(sizeof(float) == 4, "Float bit indexing requires 32-bit float");
_Static_assert(sizeof(double) == 8, "Float bit indexing requires 64-bit double");

// test-execution
// Tests: f32/f64 bit indexing read/write operations
// Helper to build f32 from LE bytes (like the user's use case)
float fromBytesLE(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    float result = 0.0;
    result = (result & ~(0xFFU << 0)) | ((b0 & 0xFFU) << 0);
    result = (result & ~(0xFFU << 8)) | ((b1 & 0xFFU) << 8);
    result = (result & ~(0xFFU << 16)) | ((b2 & 0xFFU) << 16);
    result = (result & ~(0xFFU << 24)) | ((b3 & 0xFFU) << 24);
    return result;
}

int main(void) {
    float one = fromBytesLE(0x00, 0x00, 0x80, 0x3F);
    if (one != 1.0) return 1;
    float negOne = fromBytesLE(0x00, 0x00, 0x80, 0xBF);
    if (negOne != -1.0) return 2;
    float two = fromBytesLE(0x00, 0x00, 0x00, 0x40);
    if (two != 2.0) return 3;
    float testVal = 1.0;
    uint32_t __bits_testVal;
    uint8_t byte3 = (memcpy(&__bits_testVal, &testVal, sizeof(testVal)), ((__bits_testVal >> 24) & 0xFFU));
    if (byte3 != 0x3F) return 4;
    uint8_t byte2 = ((__bits_testVal >> 16) & 0xFFU);
    if (byte2 != 0x80) return 5;
    uint8_t byte1 = ((__bits_testVal >> 8) & 0xFFU);
    if (byte1 != 0x00) return 6;
    uint8_t byte0 = (__bits_testVal & 0xFFU);
    if (byte0 != 0x00) return 7;
    float val = 0.0;
    val = (val & ~(0xFFU << 24)) | ((0x3F & 0xFFU) << 24);
    val = (val & ~(0xFFU << 16)) | ((0x80 & 0xFFU) << 16);
    if (val != 1.0) return 8;
    return 0;
}
