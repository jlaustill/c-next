/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 5.5-i64-left-shift, 5.6-i64-right-shift-arithmetic
// test-execution
// Test i64 shift operations: arithmetic right shift preserves sign
// Coverage: Section 5.5-5.6 for i64 type
int main(void) {
    int64_t a = 1;
    int64_t left1 = a << 1;
    int64_t left32 = a << 32;
    int64_t left62 = a << 62;
    int64_t b = 4611686018427387904;
    int64_t right1 = b >> 1;
    int64_t right32 = b >> 32;
    int64_t right62 = b >> 62;
    int64_t c = -4611686018427387904;
    int64_t neg_right1 = c >> 1;
    int64_t neg_right32 = c >> 32;
    int64_t neg_right62 = c >> 62;
    int64_t minus_one = -1;
    int64_t shift_minus_one = minus_one >> 32;
    int64_t d = 256;
    int64_t shift_amount = 4;
    int64_t left_var = d << shift_amount;
    int64_t right_var = d >> shift_amount;
    int64_t e = -4294967296;
    int64_t neg_shift = e >> 16;
    if (left1 == 2 && left32 == 4294967296 && right62 == 1) {
        if (right32 == 1073741824 && neg_right32 == -1073741824 && neg_right62 == -1) {
            if (shift_minus_one == -1 && left_var == 4096 && right_var == 16) {
                if (neg_shift == -65536) {
                    return 0;
                }
            }
        }
    }
    return 1;
}
