/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 32.1-hex-literals
// test-execution
// Tests: Unsuffixed hex literals with type inference
// Validates that 0x... literals work correctly when type is inferred from context
int main(void) {
    uint8_t byte = 0xFFU;
    if (byte != 255) return 1;
    uint16_t word = 0xABCDU;
    if (word != 43981) return 2;
    uint32_t dword = 0xDEADBEEFU;
    if (dword != 3735928559) return 3;
    uint8_t lower = 0xffU;
    if (lower != 255) return 4;
    uint8_t upper = 0XFFU;
    if (upper != 255) return 5;
    uint32_t mixed = 0xAbCdEfU;
    if (mixed != 11259375) return 6;
    uint8_t zero = 0x0U;
    if (zero != 0) return 7;
    uint8_t single = 0xAU;
    if (single != 10) return 8;
    uint8_t two = 0x1FU;
    if (two != 31) return 9;
    uint16_t sum = 0x10U + 0x20U;
    if (sum != 48) return 10;
    uint16_t diff = 0xFFU - 0x0FU;
    if (diff != 240) return 11;
    uint32_t product = 0x10U * 0x10U;
    if (product != 256) return 12;
    uint8_t andResult = 0xFFU & 0x0FU;
    if (andResult != 15) return 13;
    uint8_t orResult = 0xF0U | 0x0FU;
    if (orResult != 255) return 14;
    uint8_t bytes[4] = {0x48U, 0x65U, 0x6CU, 0x6CU};
    if (bytes[0U] != 72) return 15;
    if (bytes[1U] != 101) return 16;
    if (bytes[2U] != 108) return 17;
    if (bytes[3U] != 108) return 18;
    uint8_t val = 0x42U;
    if (val != 0x42) return 19;
    if (0x10 >= 0x20) return 20;
    if (0xFF <= 0xFE) return 21;
    return 0;
}
