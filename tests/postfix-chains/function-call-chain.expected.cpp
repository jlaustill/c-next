/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// Postfix Chain Test: Function Calls in Chains
// Tests: Function calls with complex chained parameters
// HIGH RISK: Float parameters in postfix chains (line 6260 in CodeGenerator.ts)
typedef struct Vec3 {
    float x;
    float y;
    float z;
} Vec3;

typedef struct Transform {
    Vec3 position;
    Vec3 scale;
} Transform;

Transform transforms[4] = {0};

// Functions with various parameter types
uint32_t addU32(uint32_t a, uint32_t b) {
    return a + b;
}

float addF32(float a, float b) {
    return a + b;
}

float multiplyF32(float a, float b) {
    return a * b;
}

Vec3 scaleVec3(const Vec3& v, float scale) {
    Vec3 result = {0};
    result.x = v.x * scale;
    result.y = v.y * scale;
    result.z = v.z * scale;
    return result;
}

bool isGreater(float a, float b) {
    return a > b;
}

void setTransform(const Transform& t, uint32_t index) {
    transforms[index] = t;
}

int main(void) {
    transforms[0].position.x = 1.0;
    transforms[0].position.y = 2.0;
    transforms[0].position.z = 3.0;
    transforms[0].scale.x = 1.0;
    transforms[0].scale.y = 1.0;
    transforms[0].scale.z = 1.0;
    float sumX = addF32(transforms[0U].position.x, transforms[0U].scale.x);
    float sumY = addF32(transforms[0U].position.y, transforms[0U].scale.y);
    float sumZ = addF32(transforms[0U].position.z, transforms[0U].scale.z);
    float product = multiplyF32(transforms[1U].position.x, transforms[1U].scale.x);
    float nestedSum = addF32(multiplyF32(transforms[0U].position.x, 2.0), transforms[0U].position.y);
    Vec3 scaled = scaleVec3(transforms[0U].position, 2.0);
    float scaledX = scaled.x;
    bool result = isGreater(transforms[0U].position.x, transforms[1U].position.x);
    Transform temp = {0};
    temp.position = transforms[0U].position;
    temp.scale = transforms[0U].scale;
    setTransform(temp, 2U);
    transforms[2].position = scaleVec3(transforms[0U].position, 3.0);
    uint32_t idx = addU32(1U, 1U);
    transforms[idx].position.x = 5.0;
}
