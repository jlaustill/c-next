// ADR-004: Write-only register operations test
// Tests: Valid write-only register bit operations with various index types
// Coverage: Section 12 - Register Declaration (write-only bit access)
// Extracted from: write-only-register-chain.test.cnx.skip
register GPIO @ 0x42000000 {
    DR: u32 rw @ 0x00,
    DR_SET: u32 wo @ 0x84,
    DR_CLEAR: u32 wo @ 0x88,
    DR_TOGGLE: u32 wo @ 0x8C,
}

const u32 LED_BIT <- 3;

const u32 BUTTON_BIT <- 7;

u32 dynamicBit <- 5;

void main() {
    // Write-only register with literal bit index
    GPIO.DR_SET[0] <- true;
    GPIO.DR_SET[31] <- true;

    // Write-only register with const bit index
    GPIO.DR_SET[LED_BIT] <- true;
    GPIO.DR_CLEAR[LED_BIT] <- true;
    GPIO.DR_TOGGLE[LED_BIT] <- true;

    // Write-only register with multiple const indices
    GPIO.DR_SET[BUTTON_BIT] <- true;
    GPIO.DR_CLEAR[BUTTON_BIT] <- true;

    // Write-only register with variable bit index
    GPIO.DR_SET[dynamicBit] <- true;
    GPIO.DR_CLEAR[dynamicBit] <- true;

    // Write-only register with expression bit index
    GPIO.DR_SET[LED_BIT + 1] <- true;
    GPIO.DR_CLEAR[LED_BIT * 2] <- true;

    // Chained access to write-only registers
    u32 targetBit <- LED_BIT;
    GPIO.DR_TOGGLE[targetBit] <- true;

    // Write to read-write register for comparison
    GPIO.DR[LED_BIT] <- true;
    GPIO.DR[BUTTON_BIT] <- false;

    // Read from read-write, write to write-only based on condition
    bool state <- GPIO.DR[LED_BIT];
    if (state = true) {
        GPIO.DR_CLEAR[LED_BIT] <- true;
    } else {
        GPIO.DR_SET[LED_BIT] <- true;
    }
}
