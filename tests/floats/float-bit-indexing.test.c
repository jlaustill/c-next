/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

_Static_assert(sizeof(float) == 4, "Float bit indexing requires 32-bit float");
_Static_assert(sizeof(double) == 8, "Float bit indexing requires 64-bit double");

// test-execution
// Tests: f32/f64 bit indexing read/write operations
// Helper to build f32 from LE bytes (like the user's use case)
float fromBytesLE(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    float result = 0.0;
    union { float f; uint32_t u; } __bits_result;
    __bits_result.f = result;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 0)) | (((uint32_t)b0 & 0xFFU) << 0);
    result = __bits_result.f;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 8)) | (((uint32_t)b1 & 0xFFU) << 8);
    result = __bits_result.f;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 16)) | (((uint32_t)b2 & 0xFFU) << 16);
    result = __bits_result.f;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 24)) | (((uint32_t)b3 & 0xFFU) << 24);
    result = __bits_result.f;
    return result;
}

int main(void) {
    float one = fromBytesLE(0x00U, 0x00U, 0x80U, 0x3FU);
    if (one != 1.0) return 1;
    float negOne = fromBytesLE(0x00U, 0x00U, 0x80U, 0xBFU);
    if (negOne != -1.0) return 2;
    float two = fromBytesLE(0x00U, 0x00U, 0x00U, 0x40U);
    if (two != 2.0) return 3;
    float testVal = 1.0;
    union { float f; uint32_t u; } __bits_testVal;
    __bits_testVal.f = testVal;
    uint8_t byte3 = ((__bits_testVal.u >> 24U) & 0xFFU);
    if (byte3 != 0x3F) return 4;
    uint8_t byte2 = ((__bits_testVal.u >> 16U) & 0xFFU);
    if (byte2 != 0x80) return 5;
    uint8_t byte1 = ((__bits_testVal.u >> 8U) & 0xFFU);
    if (byte1 != 0x00) return 6;
    uint8_t byte0 = (__bits_testVal.u & 0xFFU);
    if (byte0 != 0x00) return 7;
    float val = 0.0;
    union { float f; uint32_t u; } __bits_val;
    __bits_val.f = val;
    __bits_val.u = (__bits_val.u & ~(0xFFU << 24)) | (((uint32_t)0x3F & 0xFFU) << 24);
    val = __bits_val.f;
    __bits_val.u = (__bits_val.u & ~(0xFFU << 16)) | (((uint32_t)0x80 & 0xFFU) << 16);
    val = __bits_val.f;
    if (val != 1.0) return 8;
    return 0;
}
