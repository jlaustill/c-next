/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-coverage: 5.5-i16-left-shift, 5.6-i16-right-shift-arithmetic */
/* test-execution */
// Test i16 shift operations: arithmetic right shift preserves sign
// Coverage: Section 5.5-5.6 for i16 type
uint32_t main(void) {
    int16_t a = 1;
    int16_t left1 = a << 1;
    int16_t left8 = a << 8;
    int16_t left14 = a << 14;
    int16_t b = 16384;
    int16_t right1 = b >> 1;
    int16_t right8 = b >> 8;
    int16_t right14 = b >> 14;
    int16_t c = -16384;
    int16_t neg_right1 = c >> 1;
    int16_t neg_right8 = c >> 8;
    int16_t neg_right14 = c >> 14;
    int16_t minus_one = -1;
    int16_t shift_minus_one = minus_one >> 8;
    int16_t d = 256;
    int16_t shift_amount = 4;
    int16_t left_var = d << shift_amount;
    int16_t right_var = d >> shift_amount;
    int16_t e = -1024;
    int16_t neg_shift = e >> 2;
    if (left1 == 2 && left8 == 256 && left14 == 16384) {
        if (right1 == 8192 && right8 == 64 && right14 == 1) {
            if (neg_right1 == -8192 && neg_right8 == -64 && neg_right14 == -1) {
                if (shift_minus_one == -1 && left_var == 4096 && right_var == 16) {
                    if (neg_shift == -256) {
                        return 0;
                    }
                }
            }
        }
    }
    return 1;
}
