/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint32_t cnx_clamp_mul_u32(uint32_t a, uint64_t b) {
    if (b != 0 && a > UINT32_MAX / b) return UINT32_MAX;
    uint32_t result;
    if (__builtin_mul_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// Coverage: Section 7.4 - for loop inside scope
// Tests: for loops inside scope declarations
uint32_t globalSum = 0;

/* Scope: Calculator */
static uint32_t Calculator_result = 0;

void Calculator_sumToN(uint32_t* n) {
    Calculator_result = 0;
    for (uint32_t i = 1; i <= (*n); i = i + 1) {
        Calculator_result = cnx_clamp_add_u32(Calculator_result, i);
    }
}

void Calculator_factorial(uint32_t* n) {
    Calculator_result = 1;
    for (uint32_t i = 2; i <= (*n); i = i + 1) {
        Calculator_result = cnx_clamp_mul_u32(Calculator_result, i);
    }
}

uint32_t Calculator_getResult(void) {
    return Calculator_result;
}

/* Scope: ArrayOps */
static uint32_t ArrayOps_data[10] = {0};
static uint32_t ArrayOps_sum = 0;

void ArrayOps_initialize(void) {
    for (uint32_t i = 0; i < 10; i = i + 1) {
        ArrayOps_data[i] = i * 2;
    }
}

void ArrayOps_computeSum(void) {
    ArrayOps_sum = 0;
    for (uint32_t i = 0; i < 10; i = i + 1) {
        ArrayOps_sum = cnx_clamp_add_u32(ArrayOps_sum, ArrayOps_data[i]);
    }
}

uint32_t ArrayOps_getSum(void) {
    return ArrayOps_sum;
}

int main(void) {
    Calculator_sumToN(&(uint32_t){5});
    globalSum = Calculator_getResult();
    Calculator_factorial(&(uint32_t){5});
    ArrayOps_initialize();
    ArrayOps_computeSum();
}
