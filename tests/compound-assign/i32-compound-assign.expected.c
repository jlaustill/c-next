/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int32_t cnx_clamp_add_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a + b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

static inline int32_t cnx_clamp_mul_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a * b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

static inline int32_t cnx_clamp_sub_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a - b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

/* test-execution */
// Tests: i32 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: -2147483648 to 2147483647
int main(void) {
    int32_t val = 1000000000;
    val = cnx_clamp_add_i32(val, 500000000);
    if (val != 1500000000) return 1;
    val = -1000000000;
    val = cnx_clamp_add_i32(val, 500000000);
    if (val != -500000000) return 2;
    val = -1000000000;
    val = cnx_clamp_add_i32(val, -500000000);
    if (val != -1500000000) return 3;
    val = 1000000;
    val = cnx_clamp_add_i32(val, 0);
    if (val != 1000000) return 4;
    val = -1000000;
    val = cnx_clamp_add_i32(val, 1000000);
    if (val != 0) return 5;
    val = 2147483646;
    val = cnx_clamp_add_i32(val, 1);
    if (val != 2147483647) return 6;
    int32_t sub = 1500000000;
    sub = cnx_clamp_sub_i32(sub, 500000000);
    if (sub != 1000000000) return 10;
    sub = 500000000;
    sub = cnx_clamp_sub_i32(sub, 1000000000);
    if (sub != -500000000) return 11;
    sub = -1000000000;
    sub = cnx_clamp_sub_i32(sub, 500000000);
    if (sub != -1500000000) return 12;
    sub = -1000000000;
    sub = cnx_clamp_sub_i32(sub, -500000000);
    if (sub != -500000000) return 13;
    sub = 1000000;
    sub = cnx_clamp_sub_i32(sub, 0);
    if (sub != 1000000) return 14;
    sub = -2147483647;
    sub = cnx_clamp_sub_i32(sub, 1);
    if (sub != -2147483648) return 15;
    int32_t mul = 10000;
    mul = cnx_clamp_mul_i32(mul, 10000);
    if (mul != 100000000) return 20;
    mul = -10000;
    mul = cnx_clamp_mul_i32(mul, 10000);
    if (mul != -100000000) return 21;
    mul = -10000;
    mul = cnx_clamp_mul_i32(mul, -10000);
    if (mul != 100000000) return 22;
    mul = 1000000;
    mul = cnx_clamp_mul_i32(mul, 1);
    if (mul != 1000000) return 23;
    mul = 1000000;
    mul = cnx_clamp_mul_i32(mul, -1);
    if (mul != -1000000) return 24;
    mul = 123456;
    mul = cnx_clamp_mul_i32(mul, 0);
    if (mul != 0) return 25;
    int32_t div = 1000000000;
    div /= 1000;
    if (div != 1000000) return 30;
    div = -1000000000;
    div /= 1000;
    if (div != -1000000) return 31;
    div = -1000000000;
    div /= -1000;
    if (div != 1000000) return 32;
    div = 1000000;
    div /= 1;
    if (div != 1000000) return 33;
    div = -1000000;
    div /= -1;
    if (div != 1000000) return 34;
    div = 2147483647;
    div /= 2147483647;
    if (div != 1) return 35;
    int32_t mod = 1000000007;
    mod %= 1000000;
    if (mod != 7) return 40;
    mod = -1000000007;
    mod %= 1000000;
    if (mod != -7) return 41;
    mod = 12345;
    mod %= 7;
    if (mod != 4) return 42;
    mod = -12345;
    mod %= 7;
    if (mod != -4) return 43;
    mod = 1000000;
    mod %= 1000000;
    if (mod != 0) return 44;
    int32_t and = 0x7FFFFFFF;
    and &= 0x0000FFFF;
    if (and != 0x0000FFFF) return 50;
    and = -1;
    and &= 0x0000FFFF;
    if (and != 0x0000FFFF) return 51;
    and = 0x55555555;
    and &= 0xAAAAAAAA;
    if (and != 0) return 52;
    and = 0x0F0F0F0F;
    and &= 0xF0F0F0F0;
    if (and != 0) return 53;
    int32_t or = 0x0000FFFF;
    or |= 0x7FFF0000;
    if (or != 0x7FFFFFFF) return 60;
    or = 0x12340000;
    or |= 0x00005678;
    if (or != 0x12345678) return 61;
    or = 0x12345678;
    or |= 0x00000000;
    if (or != 0x12345678) return 62;
    int32_t xor = 0x55555555;
    xor ^= 0x55555555;
    if (xor != 0) return 70;
    xor = 0x0F0F0F0F;
    xor ^= 0x70707070;
    if (xor != 0x7F7F7F7F) return 71;
    xor = -1;
    xor ^= -1;
    if (xor != 0) return 72;
    xor = 0x55555555;
    xor ^= 0x2AAAAAAA;
    if (xor != 0x7FFFFFFF) return 73;
    int32_t shl = 1;
    shl <<= 0;
    if (shl != 1) return 80;
    shl = 1;
    shl <<= 1;
    if (shl != 2) return 81;
    shl = 1;
    shl <<= 16;
    if (shl != 65536) return 82;
    shl = 1;
    shl <<= 30;
    if (shl != 1073741824) return 83;
    shl = -1;
    shl <<= 4;
    if (shl != -16) return 84;
    int32_t shr = 65536;
    shr >>= 0;
    if (shr != 65536) return 90;
    shr = 65536;
    shr >>= 1;
    if (shr != 32768) return 91;
    shr = 65536;
    shr >>= 16;
    if (shr != 1) return 92;
    shr = -16;
    shr >>= 2;
    if (shr != -4) return 93;
    shr = -1;
    shr >>= 10;
    if (shr != -1) return 94;
    return 0;
}
