/**
 * Generated by C-Next Transpiler from: u16-arithmetic.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: u16 arithmetic operations (+, -, *, /, %)
// Coverage: Section 4.1-4.5 for u16 type
int main(void) {
    uint16_t a = 30000U;
    uint16_t b = 15000U;
    uint16_t sum = a + b;
    if (sum != 45000) return 1;
    uint16_t sum_zero = a + 0U;
    if (sum_zero != 30000) return 2;
    uint16_t c = 60000U;
    uint16_t d = 5535U;
    uint16_t sum_large = c + d;
    if (sum_large != 65535) return 3;
    uint16_t diff = a - b;
    if (diff != 15000) return 4;
    uint16_t e = 30000U;
    uint16_t f = 30000U;
    uint16_t diff_zero = e - f;
    if (diff_zero != 0) return 5;
    uint16_t diff_zero2 = a - 0U;
    if (diff_zero2 != 30000) return 6;
    uint16_t g = 100U;
    uint16_t h = 50U;
    uint16_t product = g * h;
    if (product != 5000) return 7;
    uint16_t product_zero = g * 0U;
    if (product_zero != 0) return 8;
    uint16_t product_one = g * 1U;
    if (product_one != 100) return 9;
    uint16_t i = 255U;
    uint16_t j = 257U;
    uint16_t product_large = i * j;
    if (product_large != 65535) return 10;
    uint16_t k = 10000U;
    uint16_t l = 50U;
    uint16_t quotient = k / l;
    if (quotient != 200) return 11;
    uint16_t quotient_one = k / 1U;
    if (quotient_one != 10000) return 12;
    uint16_t m = 10000U;
    uint16_t n = 7U;
    uint16_t quotient_trunc = m / n;
    if (quotient_trunc != 1428) return 13;
    uint16_t zero = 0U;
    uint16_t quotient_zero = zero / 5U;
    if (quotient_zero != 0) return 14;
    uint16_t o = 10000U;
    uint16_t p = 7U;
    uint16_t remainder = o % p;
    if (remainder != 4) return 15;
    uint16_t q = 10000U;
    uint16_t r = 50U;
    uint16_t remainder_zero = q % r;
    if (remainder_zero != 0) return 16;
    uint16_t s = 3U;
    uint16_t t = 100U;
    uint16_t remainder_small = s % t;
    if (remainder_small != 3) return 17;
    uint16_t remainder_zero2 = zero % 5U;
    if (remainder_zero2 != 0) return 18;
    uint16_t max_val = 65535U;
    uint16_t one = 1U;
    uint16_t max_div = max_val / max_val;
    if (max_div != 1) return 19;
    uint16_t max_mod = max_val % max_val;
    if (max_mod != 0) return 20;
    uint16_t max_minus_one = max_val - one;
    if (max_minus_one != 65534) return 21;
    uint16_t combined = (100U + 200U) * 20U;
    if (combined != 6000) return 22;
    return 0;
}
