/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: multi-dimensional f64 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: scientific calculations, high-precision measurements, astronomy
double matrix2d[4][8] = {0};

double cube3d[2][3][4] = {0};

int main(void) {
    matrix2d[0][0] = 3.14159265359;
    matrix2d[0][7] = -2.71828182846;
    matrix2d[1][3] = 1000.123456789;
    matrix2d[3][7] = 0.0;
    if (matrix2d[0][0] != 3.14159265359) return 1;
    if (matrix2d[0][7] != -2.71828182846) return 2;
    if (matrix2d[1][3] != 1000.123456789) return 3;
    if (matrix2d[3][7] != 0.0) return 4;
    cube3d[0][0][0] = 1.123456789012345;
    cube3d[0][0][3] = -10.987654321098765;
    cube3d[0][2][3] = 0.0;
    cube3d[1][0][0] = 999.999999999999;
    cube3d[1][2][3] = -0.000000000001;
    if (cube3d[0][0][0] != 1.123456789012345) return 5;
    if (cube3d[0][0][3] != -10.987654321098765) return 6;
    if (cube3d[0][2][3] != 0.0) return 7;
    if (cube3d[1][0][0] != 999.999999999999) return 8;
    if (cube3d[1][2][3] != -0.000000000001) return 9;
    if (4 != 4) return 10;
    if (8 != 8) return 11;
    if (64 != 64) return 12;
    if (2 != 2) return 13;
    if (3 != 3) return 14;
    if (4 != 4) return 15;
    if (64 != 64) return 16;
    for (uint32_t i = 0; i < 4; i += 1) {
        for (uint32_t j = 0; j < 8; j += 1) {
            matrix2d[i][j] = i * 2.5 + j * 0.5;
        }
    }
    if (matrix2d[0][0] != 0.0) return 17;
    if (matrix2d[0][7] != 3.5) return 18;
    if (matrix2d[1][3] != 4.0) return 19;
    if (matrix2d[3][7] != 11.0) return 20;
    double sum = 0.0;
    for (uint32_t i = 0; i < 2; i += 1) {
        for (uint32_t j = 0; j < 3; j += 1) {
            for (uint32_t k = 0; k < 4; k += 1) {
                cube3d[i][j][k] = i * 10.5 + j * 2.25 + k * 0.5;
                sum += cube3d[i][j][k];
            }
        }
    }
    if (sum != 198.0) return 21;
    matrix2d[2][4] = -999999.999999;
    if (matrix2d[2][4] != -999999.999999) return 22;
    matrix2d[4 - 1][8 - 1] = 42.123456789;
    if (matrix2d[3][7] != 42.123456789) return 23;
    double testArray[4][2] = {0};
    for (uint32_t ti = 0; ti < 4; ti += 1) {
        for (uint32_t tj = 0; tj < 2; tj += 1) {
            testArray[ti][tj] = 0.0;
        }
    }
    testArray[0][0] = 0.0;
    testArray[0][1] = -0.0;
    testArray[1][0] = 1.0;
    testArray[1][1] = -1.0;
    testArray[2][0] = 0.123456789012345;
    testArray[3][1] = -0.123456789012345;
    if (testArray[0][0] != 0.0) return 24;
    if (testArray[0][1] != -0.0) return 25;
    if (testArray[1][0] != 1.0) return 26;
    if (testArray[1][1] != -1.0) return 27;
    if (testArray[2][0] != 0.123456789012345) return 28;
    if (testArray[3][1] != -0.123456789012345) return 29;
    double constants[3][3] = {0};
    for (uint32_t coi = 0; coi < 3; coi += 1) {
        for (uint32_t coj = 0; coj < 3; coj += 1) {
            constants[coi][coj] = 0.0;
        }
    }
    constants[0][0] = 3.14159265358979;
    constants[0][1] = 2.71828182845905;
    constants[0][2] = 1.61803398874989;
    constants[1][0] = 6.62607015e-34;
    constants[1][1] = 299792458.0;
    constants[2][0] = 6.67430e-11;
    constants[2][1] = 9.80665;
    if (constants[0][0] != 3.14159265358979) return 30;
    if (constants[0][1] != 2.71828182845905) return 31;
    if (constants[0][2] != 1.61803398874989) return 32;
    if (constants[1][0] != 6.62607015e-34) return 33;
    if (constants[1][1] != 299792458.0) return 34;
    if (constants[2][0] != 6.67430e-11) return 35;
    if (constants[2][1] != 9.80665) return 36;
    double precise[2][2] = {0};
    for (uint32_t pi = 0; pi < 2; pi += 1) {
        for (uint32_t pj = 0; pj < 2; pj += 1) {
            precise[pi][pj] = 0.0;
        }
    }
    precise[0][0] = 0.123456789012345;
    precise[0][1] = 0.000000000000001;
    precise[1][0] = 999999.999999999;
    precise[1][1] = -123456.789012345;
    if (precise[0][0] != 0.123456789012345) return 37;
    if (precise[0][1] != 0.000000000000001) return 38;
    if (precise[1][0] != 999999.999999999) return 39;
    if (precise[1][1] != -123456.789012345) return 40;
    double calc[2][2] = {0};
    for (uint32_t ci = 0; ci < 2; ci += 1) {
        for (uint32_t cj = 0; cj < 2; cj += 1) {
            calc[ci][cj] = 0.0;
        }
    }
    calc[0][0] = 10.123456789;
    calc[0][1] = 5.987654321;
    double calcSum = calc[0][0] + calc[0][1];
    if (calcSum != 16.11111111) return 41;
    double distances[2][3] = {0};
    for (uint32_t di = 0; di < 2; di += 1) {
        for (uint32_t dj = 0; dj < 3; dj += 1) {
            distances[di][dj] = 0.0;
        }
    }
    distances[0][0] = 9.461e15;
    distances[0][1] = 1.496e11;
    distances[0][2] = 3.086e16;
    distances[1][0] = 4.0e26;
    distances[1][1] = 2.5e22;
    distances[1][2] = 1.0e21;
    if (distances[0][0] != 9.461e15) return 42;
    if (distances[0][1] != 1.496e11) return 43;
    if (distances[1][0] != 4.0e26) return 44;
    double quantum[2][2] = {0};
    for (uint32_t qi = 0; qi < 2; qi += 1) {
        for (uint32_t qj = 0; qj < 2; qj += 1) {
            quantum[qi][qj] = 0.0;
        }
    }
    quantum[0][0] = 1.0e-35;
    quantum[0][1] = 5.39e-44;
    quantum[1][0] = 1.616e-35;
    quantum[1][1] = 0.0;
    if (quantum[0][0] != 1.0e-35) return 45;
    if (quantum[0][1] != 5.39e-44) return 46;
    if (quantum[1][0] != 1.616e-35) return 47;
    return 0;
}
