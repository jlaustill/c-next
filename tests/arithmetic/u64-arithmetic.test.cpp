/**
 * Generated by C-Next Transpiler from: u64-arithmetic.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 1.1-u64-in-arithmetic-expression
// test-execution
// Tests: u64 arithmetic operations (+, -, *, /, %)
// Validates all basic arithmetic operations with u64 type
// Includes edge cases with large values relevant to embedded systems
int main(void) {
    uint64_t a = 1000000000000ULL;
    uint64_t b = 500000000000ULL;
    uint64_t result = a + b;
    if (result != 1500000000000) return 1;
    result = a + 1000ULL;
    if (result != 1000000001000) return 2;
    result = 5000ULL + a;
    if (result != 1000000005000) return 3;
    uint64_t large1 = 9000000000000000000ULL;
    uint64_t large2 = 1000000000000000000ULL;
    result = large1 + large2;
    if (result != 10000000000000000000) return 4;
    a = 1000000000000ULL;
    b = 300000000000ULL;
    result = a - b;
    if (result != 700000000000) return 5;
    result = a - 1000ULL;
    if (result != 999999999000) return 6;
    result = 2000000000000ULL - a;
    if (result != 1000000000000) return 7;
    uint64_t c = 1000ULL;
    uint64_t d = 999ULL;
    result = c - d;
    if (result != 1) return 8;
    uint64_t m1 = 1000000ULL;
    uint64_t m2 = 1000000ULL;
    result = m1 * m2;
    if (result != 1000000000000) return 9;
    result = m1 * 2ULL;
    if (result != 2000000) return 10;
    result = 1000ULL * m1;
    if (result != 1000000000) return 11;
    uint64_t m3 = 100000000ULL;
    uint64_t m4 = 10000ULL;
    result = m3 * m4;
    if (result != 1000000000000) return 12;
    uint64_t div1 = 1000000000000ULL;
    uint64_t div2 = 1000ULL;
    result = div1 / div2;
    if (result != 1000000000) return 13;
    result = div1 / 2ULL;
    if (result != 500000000000) return 14;
    result = 1000000000000ULL / 500ULL;
    if (result != 2000000000) return 15;
    uint64_t div3 = 9000000000000000000ULL;
    uint64_t div4 = 1000000ULL;
    result = div3 / div4;
    if (result != 9000000000000) return 16;
    uint64_t mod1 = 1000000000007ULL;
    uint64_t mod2 = 1000000ULL;
    result = mod1 % mod2;
    if (result != 7) return 17;
    result = mod1 % 100ULL;
    if (result != 7) return 18;
    result = 12345ULL % 7ULL;
    if (result != 4) return 19;
    uint64_t timestamp = 1609459200000ULL;
    result = timestamp % 1000ULL;
    if (result != 0) return 20;
    uint64_t e1 = 10000ULL;
    uint64_t e2 = 5000ULL;
    uint64_t e3 = 2000ULL;
    result = e1 + e2 * e3;
    if (result != 10010000) return 21;
    result = (e1 + e2) * e3;
    if (result != 30000000) return 22;
    result = e1 / e2 + e3;
    if (result != 2002) return 23;
    result = e1 - e2 / e3;
    if (result != 9998) return 24;
    result = (e1 * e2) / e3 + 1000ULL;
    if (result != 26000) return 25;
    result = (e1 + e2) / (e3 - 1000ULL);
    if (result != 15) return 26;
    uint64_t zero = 0ULL;
    uint64_t val = 1000000ULL;
    result = zero + val;
    if (result != 1000000) return 27;
    result = val - zero;
    if (result != 1000000) return 28;
    result = zero * val;
    if (result != 0) return 29;
    result = zero / 1ULL;
    if (result != 0) return 30;
    result = zero % 100ULL;
    if (result != 0) return 31;
    result = val * 1ULL;
    if (result != 1000000) return 32;
    result = val / 1ULL;
    if (result != 1000000) return 33;
    uint64_t timestamp1 = 1609459200000ULL;
    uint64_t timestamp2 = 1609545600000ULL;
    result = timestamp2 - timestamp1;
    if (result != 86400000) return 34;
    return 0;
}
