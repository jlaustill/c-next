/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-c-only
// test-execution
// Tests: Issue #579 - Array indexing on parameter should generate array access, not bit manipulation
// When a function parameter is declared as `u8 buf` (without explicit array syntax)
// but used with array indexing, it becomes a pointer in C (ADR-006), so buf[i] is array access.
uint32_t result = 0U;

// Test 1: Write to parameter with variable index
void writeToParam(uint8_t* buf, uint32_t idx) {
    buf[idx] = 42;
}

// Test 2: Read from parameter with variable index
uint8_t readFromParam(const uint8_t* buf, uint32_t idx) {
    return buf[idx];
}

// Test 3: Both read and write in same function
void copyElement(const uint8_t* src, uint8_t* dst, uint32_t idx) {
    dst[idx] = src[idx];
}

// Test 4: Constant index on parameter
uint8_t readFirst(const uint8_t* buf) {
    return buf[0];
}

// Test 5: Multiple index operations
void swapElements(uint8_t* buf, uint32_t i, uint32_t j) {
    uint8_t temp = buf[i];
    buf[i] = buf[j];
    buf[j] = temp;
}

// Test 6: With explicit array syntax (should still work)
void writeExplicit(uint8_t buf[8], uint32_t idx) {
    buf[idx] = 99;
}

// Test 7: Bit range on parameter should still be bit extraction (NOT array access)
// This ensures we don't over-correct and treat value[0, 8] as array access
uint8_t getLowByte(uint16_t value) {
    return ((value) & 0xFFU);
}

uint8_t getHighByte(uint16_t value) {
    return ((value >> 8) & 0xFFU);
}

// Test 8: Local array with bit access after consuming all dimensions
// This tests the currentStructType fix for primitive array elements
// matrix[i][j] is array access, then [BIT] should be bit access
uint8_t getArrayBit(const uint8_t matrix[2][2], uint32_t row, uint32_t col, uint32_t bit) {
    return ((matrix[row][col] >> bit) & 1);
}

void setArrayBit(uint8_t matrix[2][2], uint32_t row, uint32_t col, uint32_t bit, bool val) {
    matrix[row][col] = (matrix[row][col] & ~(1U << bit)) | ((val ? 1U : 0U) << bit);
}

int main(void) {
    uint8_t buffer[8] = {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U};
    uint8_t source[4] = {10U, 20U, 30U, 40U};
    uint8_t dest[4] = {0U, 0U, 0U, 0U};
    writeToParam(buffer, 3);
    if (buffer[3] != 42) return 1;
    uint8_t val = readFromParam(source, 2U);
    if (val != 30) return 2;
    copyElement(source, dest, 1);
    if (dest[1] != 20) return 3;
    val = readFirst(source);
    if (val != 10) return 4;
    buffer[0] = 5;
    buffer[1] = 7;
    swapElements(buffer, 0, 1);
    if (buffer[0] != 7) return 5;
    if (buffer[1] != 5) return 6;
    writeExplicit(buffer, 4);
    if (buffer[4] != 99) return 7;
    uint16_t testWord = 0x1234U;
    uint8_t low = getLowByte(testWord);
    if (low != 0x34) return 8;
    uint8_t high = getHighByte(testWord);
    if (high != 0x12) return 9;
    uint8_t matrix[2][2] = {{0xFFU, 0x00U}, {0xAAU, 0x55U}};
    uint8_t bit0 = getArrayBit(matrix, 0U, 0U, 0U);
    if (bit0 != 1) return 10;
    uint8_t bit1 = getArrayBit(matrix, 0U, 1U, 0U);
    if (bit1 != 0) return 11;
    setArrayBit(matrix, 0, 1, 0, true);
    if (matrix[0][1] != 0x01) return 12;
    setArrayBit(matrix, 0, 0, 7, false);
    if (matrix[0][0] != 0x7F) return 13;
    return 0;
}
