// Test: Compound assignment on 3D arrays
// Covers all compound operators on deeply indexed array elements
u32[3] cube[3][3];

i32 main() {
    // Initialize various positions in 3D array
    cube[0][0][0] <- 100;
    cube[1][1][1] <- 50;
    cube[2][2][2] <- 10;
    cube[0][1][2] <- 100;
    cube[2][1][0] <- 17;
    cube[1][0][2] <- 0b11110000;
    cube[0][2][1] <- 0b00001111;
    cube[2][0][1] <- 0b10101010;
    cube[1][2][0] <- 8;
    cube[1][1][0] <- 128;

   
// Test all compound assignment operators on 3D array elements
    cube[0][0][0] +<- 25; // 100 + 25 = 125
    cube[1][1][1] -<- 15; // 50 - 15 = 35
    cube[2][2][2] *<- 7; // 10 * 7 = 70
    cube[0][1][2] /<- 4; // 100 / 4 = 25
    cube[2][1][0] %<- 5; // 17 % 5 = 2
    cube[1][0][2] &<- 0b11001100; // 0b11110000 & 0b11001100 = 192
    cube[0][2][1] |<- 0b11110000; // 0b00001111 | 0b11110000 = 255
    cube[2][0][1] ^<- 0b11111111; // 0b10101010 ^ 0b11111111 = 85
    cube[1][2][0] <<<- 2; // 8 << 2 = 32
    cube[1][1][0] >><- 3; // 128 >> 3 = 16

    // Verify all results
    if (cube[0][0][0] != 125) {
        return 1;
    }
    if (cube[1][1][1] != 35) {
        return 2;
    }
    if (cube[2][2][2] != 70) {
        return 3;
    }
    if (cube[0][1][2] != 25) {
        return 4;
    }
    if (cube[2][1][0] != 2) {
        return 5;
    }
    if (cube[1][0][2] != 192) {
        return 6;
    }
    if (cube[0][2][1] != 255) {
        return 7;
    }
    if (cube[2][0][1] != 85) {
        return 8;
    }
    if (cube[1][2][0] != 32) {
        return 9;
    }
    if (cube[1][1][0] != 16) {
        return 10;
    }

    return 0;
}
