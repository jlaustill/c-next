/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: Structs containing array members of various types
// Coverage: u8, u16, u32, u64 arrays inside structs
typedef struct ByteBuffer {
    uint8_t data[8];
    uint32_t len;
} ByteBuffer;

typedef struct WordBuffer {
    uint16_t values[4];
    uint32_t count;
} WordBuffer;

typedef struct LongBuffer {
    uint32_t items[4];
    uint32_t cap;
} LongBuffer;

typedef struct WideBuffer {
    uint64_t entries[2];
    uint32_t used;
} WideBuffer;

int main(void) {
    ByteBuffer bytes = {0};
    bytes.len = 4U;
    bytes.data[0] = 0x10U;
    bytes.data[1] = 0x20U;
    bytes.data[2] = 0x30U;
    bytes.data[3] = 0x40U;
    if (bytes.len != 4) return 1;
    if (bytes.data[0U] != 0x10) return 2;
    if (bytes.data[1U] != 0x20) return 3;
    if (bytes.data[2U] != 0x30) return 4;
    if (bytes.data[3U] != 0x40) return 5;
    WordBuffer words = {0};
    words.count = 3U;
    words.values[0] = 1000U;
    words.values[1] = 2000U;
    words.values[2] = 3000U;
    if (words.count != 3) return 6;
    if (words.values[0U] != 1000) return 7;
    if (words.values[1U] != 2000) return 8;
    if (words.values[2U] != 3000) return 9;
    LongBuffer longs = {0};
    longs.cap = 2U;
    longs.items[0] = 100000U;
    longs.items[1] = 200000U;
    if (longs.cap != 2) return 10;
    if (longs.items[0U] != 100000) return 11;
    if (longs.items[1U] != 200000) return 12;
    WideBuffer wides = {0};
    wides.used = 2U;
    wides.entries[0] = 1000000000ULL;
    wides.entries[1] = 2000000000ULL;
    if (wides.used != 2) return 13;
    if (wides.entries[0U] != 1000000000) return 14;
    if (wides.entries[1U] != 2000000000) return 15;
    bytes.data[0] += 5U;
    if (bytes.data[0U] != 0x15) return 16;
    words.values[0] -= 100U;
    if (words.values[0U] != 900) return 17;
    return 0;
}
