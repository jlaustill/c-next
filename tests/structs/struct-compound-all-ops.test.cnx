// Test: All compound assignment operators on struct members
// Covers: +<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-
struct Data {
    u32 add_val;
    u32 sub_val;
    u32 mul_val;
    u32 div_val;
    u32 mod_val;
    u32 and_val;
    u32 or_val;
    u32 xor_val;
    u32 shl_val;
    u32 shr_val;
}

Data d;

i32 main() {
    // Initialize struct members
    d.add_val <- 100;
    d.sub_val <- 50;
    d.mul_val <- 10;
    d.div_val <- 100;
    d.mod_val <- 17;
    d.and_val <- 0b11110000;
    d.or_val <- 0b00001111;
    d.xor_val <- 0b10101010;
    d.shl_val <- 8;
    d.shr_val <- 128;

    // Test all compound assignment operators on struct members
    d.add_val +<- 25; // 100 + 25 = 125
    d.sub_val -<- 15; // 50 - 15 = 35
    d.mul_val *<- 7; // 10 * 7 = 70
    d.div_val /<- 4; // 100 / 4 = 25
    d.mod_val %<- 5; // 17 % 5 = 2
    d.and_val &<- 0b11001100; // 0b11110000 & 0b11001100 = 192
    d.or_val |<- 0b11110000; // 0b00001111 | 0b11110000 = 255
    d.xor_val ^<- 0b11111111; // 0b10101010 ^ 0b11111111 = 85
    d.shl_val <<<- 2; // 8 << 2 = 32
    d.shr_val >><- 3; // 128 >> 3 = 16

    // Verify all results
    if (d.add_val != 125) {
        return 1;
    }
    if (d.sub_val != 35) {
        return 2;
    }
    if (d.mul_val != 70) {
        return 3;
    }
    if (d.div_val != 25) {
        return 4;
    }
    if (d.mod_val != 2) {
        return 5;
    }
    if (d.and_val != 192) {
        return 6;
    }
    if (d.or_val != 255) {
        return 7;
    }
    if (d.xor_val != 85) {
        return 8;
    }
    if (d.shl_val != 32) {
        return 9;
    }
    if (d.shr_val != 16) {
        return 10;
    }

    return 0;
}
