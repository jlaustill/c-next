/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-execution
// Issue #269: Pass-by-value for small unmodified parameters
// Tests that unmodified small primitive types pass by value,
// while modified parameters still pass by pointer.
// --- Unmodified parameters: should pass by value ---
uint8_t getLowByte(uint16_t value) {
    return ((value) & 0xFFU);
}

uint8_t getHighByte(uint16_t value) {
    return ((value >> 8) & 0xFFU);
}

uint32_t addTwo(uint32_t a, uint32_t b) {
    return a + b;
}

bool invert(bool flag) {
    return !flag;
}

// --- Modified parameters: should still pass by pointer ---
void increment(uint32_t* x) {
    (*x) = (*x) + 1;
}

void doubleValue(uint16_t* val) {
    (*val) = (*val) * 2;
}

// --- Transitively modified: passed to function that modifies ---
// These should pass by pointer because increment() modifies its param
void incrementWrapper(uint32_t* x) {
    increment(x);
}

// --- Mixed: some params modified, some not ---
uint32_t addAndIncrement(uint32_t* a, uint32_t b) {
    (*a) = (*a) + 1;
    return (*a) + b;
}

// --- Main test ---
int main(void) {
    uint16_t testVal = 0x1234;
    uint8_t low = getLowByte(testVal);
    if (low != 0x34) return 1;
    uint8_t high = getHighByte(testVal);
    if (high != 0x12) return 2;
    uint32_t sum = addTwo(100, 200);
    if (sum != 300) return 3;
    bool result = invert(true);
    if (result != false) return 4;
    result = invert(false);
    if (result != true) return 5;
    uint32_t counter = 10;
    increment(&counter);
    if (counter != 11) return 6;
    uint16_t doubled = 50;
    doubleValue(&doubled);
    if (doubled != 100) return 7;
    uint32_t wrapped = 20;
    incrementWrapper(&wrapped);
    if (wrapped != 21) return 8;
    uint32_t mixedA = 5;
    uint32_t mixedB = 10;
    uint32_t mixedResult = addAndIncrement(&mixedA, mixedB);
    if (mixedResult != 16) return 9;
    if (mixedA != 6) return 10;
    return 0;
}
