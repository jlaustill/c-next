// test-execution
// Tests: Byte order verification for slice assignment
// Validates that bytes are copied in correct endianness
// Embedded systems typically use little-endian

u32 main() {
    u8 buffer[128];

   
// Test 1: u32 endianness - 0x12345678
    u32 value32 <- 0x12345678;
    buffer[0, 4] <- value32;

    // Little-endian: LSB first
    if (buffer[0] != 0x78) return 1;  // Least significant byte
    if (buffer[1] != 0x56) return 2;
    if (buffer[2] != 0x34) return 3;
    if (buffer[3] != 0x12) return 4;  // Most significant byte

   
// Test 2: u64 endianness - 0x0102030405060708
    u64 value64 <- 0x0102030405060708;
    buffer[10, 8] <- value64;

    // Little-endian: LSB first
    if (buffer[10] != 0x08) return 5;  // Least significant byte
    if (buffer[11] != 0x07) return 6;
    if (buffer[12] != 0x06) return 7;
    if (buffer[13] != 0x05) return 8;
    if (buffer[14] != 0x04) return 9;
    if (buffer[15] != 0x03) return 10;
    if (buffer[16] != 0x02) return 11;
    if (buffer[17] != 0x01) return 12;  // Most significant byte

   
// Test 3: u16 endianness - 0xABCD
    u16 value16 <- 0xABCD;
    buffer[20, 2] <- value16;

    // Little-endian: LSB first
    if (buffer[20] != 0xCD) return 13;  // Least significant byte
    if (buffer[21] != 0xAB) return 14;  // Most significant byte

   
// Test 4: Verify bit pattern preservation
    u32 bits <- 0x80000001;  // High bit and low bit set
    buffer[30, 4] <- bits;

    if (buffer[30] != 0x01) return 15;  // LSB with bit 0 set
    if (buffer[31] != 0x00) return 16;
    if (buffer[32] != 0x00) return 17;
    if (buffer[33] != 0x80) return 18;  // MSB with bit 31 set

    return 0;  // All tests passed
}
