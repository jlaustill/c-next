/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: wrap modifier for u16 type (0 to 65535)
// Validates: overflow wraps to 0, underflow wraps to 65535
// Issue #19: Add wrap modifier tests for all integer types
int main(void) {
    uint16_t val = 65535U;
    val = static_cast<uint16_t>((val + 1U));
    if (val != 0) return 1;
    uint16_t val2 = 65530U;
    val2 = static_cast<uint16_t>((val2 + 10U));
    if (val2 != 4) return 2;
    val = 60000U;
    val = static_cast<uint16_t>((val + 10000U));
    if (val != 4464) return 3;
    val = 32768U;
    val = static_cast<uint16_t>((val + 40000U));
    if (val != 7232) return 4;
    val = 65530U;
    val = static_cast<uint16_t>((val + 10U));
    if (val != 4) return 5;
    val = static_cast<uint16_t>((val + 65535U));
    if (val != 3) return 6;
    val = 0U;
    val = static_cast<uint16_t>((val - 1U));
    if (val != 65535) return 7;
    val = 5U;
    val = static_cast<uint16_t>((val - 10U));
    if (val != 65531) return 8;
    val = 100U;
    val = static_cast<uint16_t>((val - 1000U));
    if (val != 64636) return 9;
    val = 5U;
    val = static_cast<uint16_t>((val - 10U));
    if (val != 65531) return 10;
    val = static_cast<uint16_t>((val - 65535U));
    if (val != 65532) return 11;
    val = 30000U;
    val = static_cast<uint16_t>((val + 20000U));
    if (val != 50000) return 12;
    val = 50000U;
    val = static_cast<uint16_t>((val - 20000U));
    if (val != 30000) return 13;
    val = 0U;
    val = static_cast<uint16_t>((val + 10000U));
    if (val != 10000) return 14;
    val = 10000U;
    val = static_cast<uint16_t>((val - 10000U));
    if (val != 0) return 15;
    val = 65534U;
    val = static_cast<uint16_t>((val + 1U));
    if (val != 65535) return 16;
    val = 1U;
    val = static_cast<uint16_t>((val - 1U));
    if (val != 0) return 17;
    val = 32768U;
    val = static_cast<uint16_t>((val + 0U));
    if (val != 32768) return 18;
    val = 32768U;
    val = static_cast<uint16_t>((val - 0U));
    if (val != 32768) return 19;
    val = 1U;
    val = static_cast<uint16_t>((val - 1U));
    if (val != 0) return 20;
    val = static_cast<uint16_t>((val - 1U));
    if (val != 65535) return 21;
    val = static_cast<uint16_t>((val + 1U));
    if (val != 0) return 22;
    return 0;
}
