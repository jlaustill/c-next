{
  "file_path": "tests/scope/scope-method-contexts.expected.c",
  "main_branch_history": [],
  "task_views": {
    "001-100-scope-testing-coverage": {
      "task_id": "001-100-scope-testing-coverage",
      "branch_point": {
        "commit_hash": "6085a00ee4bff6129a6503c31d4280591d7eb497",
        "content": "",
        "timestamp": "2026-01-09T22:16:23.113589"
      },
      "worktree_state": {
        "content": "/**\n * Generated by C-Next Transpiler\n * A safer C for embedded systems\n */\n\n// Test: ADR-016 Modifiers in public and private method contexts\n// Verifies that this. and global. accessors work correctly in all method contexts\n// Tests: public methods, private methods, local variables with modifiers, combined access patterns\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// ADR-044: Overflow helper functions\n#include <limits.h>\n\nstatic inline uint8_t cnx_clamp_add_u8(uint8_t a, uint8_t b) {\n    if (a > UINT8_MAX - b) return UINT8_MAX;\n    return a + b;\n}\n\nstatic inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint8_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\nstatic inline uint16_t cnx_clamp_add_u16(uint16_t a, uint16_t b) {\n    if (a > UINT16_MAX - b) return UINT16_MAX;\n    return a + b;\n}\n\nstatic inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint16_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\n// Global variables for testing global. accessor in all method contexts\nconst uint8_t GLOBAL_MAX = 100;\nconst uint16_t GLOBAL_THRESHOLD = 1000;\nuint8_t globalCounter = 50;\nbool globalEnabled = true;\nint16_t globalOffset = -25;\nfloat globalScale = 2.5f;\n\n/* Scope: MethodContexts */\nuint8_t MethodContexts_privateValue = 10;\nuint8_t MethodContexts_privateClampValue = 200;\nuint8_t MethodContexts_privateWrapValue = 250;\nbool MethodContexts_privateFlag = false;\nint16_t MethodContexts_privateOffset = -50;\nuint8_t MethodContexts_publicValue = 20;\nuint16_t MethodContexts_publicClampValue = 60000;\nuint16_t MethodContexts_publicWrapValue = 65530;\nbool MethodContexts_publicFlag = true;\nint32_t MethodContexts_publicOffset = -1000;\n\nuint8_t MethodContexts_getPrivateValue(void) {\n    return MethodContexts_privateValue;\n}\n\nuint8_t MethodContexts_getPublicValueInternal(void) {\n    return MethodContexts_publicValue;\n}\n\nuint8_t MethodContexts_getPrivateClampValue(void) {\n    return MethodContexts_privateClampValue;\n}\n\nuint8_t MethodContexts_getPrivateWrapValue(void) {\n    return MethodContexts_privateWrapValue;\n}\n\nvoid MethodContexts_incrementPrivateClamp(void) {\n    MethodContexts_privateClampValue = cnx_clamp_add_u8(MethodContexts_privateClampValue, 100);\n}\n\nvoid MethodContexts_incrementPrivateWrap(void) {\n    MethodContexts_privateWrapValue += 10;\n}\n\nbool MethodContexts_getPrivateFlag(void) {\n    return MethodContexts_privateFlag;\n}\n\nint16_t MethodContexts_getPrivateOffset(void) {\n    return MethodContexts_privateOffset;\n}\n\nuint8_t MethodContexts_getGlobalMaxInternal(void) {\n    return GLOBAL_MAX;\n}\n\nuint8_t MethodContexts_getGlobalCounterInternal(void) {\n    return globalCounter;\n}\n\nbool MethodContexts_getGlobalEnabledInternal(void) {\n    return globalEnabled;\n}\n\nint16_t MethodContexts_getGlobalOffsetInternal(void) {\n    return globalOffset;\n}\n\nfloat MethodContexts_getGlobalScaleInternal(void) {\n    return globalScale;\n}\n\nuint8_t MethodContexts_computePrivateSum(void) {\n    return MethodContexts_privateValue + globalCounter;\n}\n\nbool MethodContexts_privateValueBelowMax(void) {\n    return MethodContexts_privateValue < GLOBAL_MAX;\n}\n\nint16_t MethodContexts_computePrivateWithOffset(void) {\n    return MethodContexts_privateOffset + globalOffset;\n}\n\nuint8_t MethodContexts_getPrivateValueExternal(void) {\n    return MethodContexts_privateValue;\n}\n\nuint8_t MethodContexts_getPublicValue(void) {\n    return MethodContexts_publicValue;\n}\n\nuint16_t MethodContexts_getPublicClampValue(void) {\n    return MethodContexts_publicClampValue;\n}\n\nuint16_t MethodContexts_getPublicWrapValue(void) {\n    return MethodContexts_publicWrapValue;\n}\n\nvoid MethodContexts_incrementPublicClamp(void) {\n    MethodContexts_publicClampValue = cnx_clamp_add_u16(MethodContexts_publicClampValue, 10000);\n}\n\nvoid MethodContexts_incrementPublicWrap(void) {\n    MethodContexts_publicWrapValue += 10;\n}\n\nbool MethodContexts_getPublicFlag(void) {\n    return MethodContexts_publicFlag;\n}\n\nint32_t MethodContexts_getPublicOffset(void) {\n    return MethodContexts_publicOffset;\n}\n\nvoid MethodContexts_setPrivateValue(uint8_t* val) {\n    MethodContexts_privateValue = (*val);\n}\n\nvoid MethodContexts_setPublicValue(uint8_t* val) {\n    MethodContexts_publicValue = (*val);\n}\n\nvoid MethodContexts_setPrivateFlag(bool* val) {\n    MethodContexts_privateFlag = (*val);\n}\n\nvoid MethodContexts_setPublicFlag(bool* val) {\n    MethodContexts_publicFlag = (*val);\n}\n\nuint8_t MethodContexts_getGlobalMax(void) {\n    return GLOBAL_MAX;\n}\n\nuint16_t MethodContexts_getGlobalThreshold(void) {\n    return GLOBAL_THRESHOLD;\n}\n\nuint8_t MethodContexts_getGlobalCounter(void) {\n    return globalCounter;\n}\n\nbool MethodContexts_getGlobalEnabled(void) {\n    return globalEnabled;\n}\n\nint16_t MethodContexts_getGlobalOffset(void) {\n    return globalOffset;\n}\n\nfloat MethodContexts_getGlobalScale(void) {\n    return globalScale;\n}\n\nuint8_t MethodContexts_computePublicSum(void) {\n    return MethodContexts_publicValue + globalCounter;\n}\n\nbool MethodContexts_publicValueBelowMax(void) {\n    return MethodContexts_publicValue < GLOBAL_MAX;\n}\n\nint32_t MethodContexts_computePublicWithOffset(void) {\n    return MethodContexts_publicOffset + globalOffset;\n}\n\nuint8_t MethodContexts_getPrivateSumViaInternal(void) {\n    return MethodContexts_computePrivateSum();\n}\n\nuint8_t MethodContexts_getGlobalCounterViaInternal(void) {\n    return MethodContexts_getGlobalCounterInternal();\n}\n\nuint8_t MethodContexts_getPrivateClampViaInternal(void) {\n    return MethodContexts_getPrivateClampValue();\n}\n\nvoid MethodContexts_modifyAllPrivate(void) {\n    MethodContexts_privateValue = MethodContexts_privateValue + 1;\n    MethodContexts_privateClampValue = cnx_clamp_add_u8(MethodContexts_privateClampValue, 10);\n    MethodContexts_privateWrapValue += 5;\n    MethodContexts_privateFlag = !MethodContexts_privateFlag;\n    MethodContexts_privateOffset = MethodContexts_privateOffset - 10;\n}\n\nvoid MethodContexts_modifyAllPublic(void) {\n    MethodContexts_publicValue = MethodContexts_publicValue + 1;\n    MethodContexts_publicClampValue = cnx_clamp_add_u16(MethodContexts_publicClampValue, 100);\n    MethodContexts_publicWrapValue += 5;\n    MethodContexts_publicFlag = !MethodContexts_publicFlag;\n    MethodContexts_publicOffset = MethodContexts_publicOffset - 100;\n}\n\nbool MethodContexts_checkThresholds(void) {\n    return MethodContexts_publicClampValue < GLOBAL_THRESHOLD && MethodContexts_privateValue < GLOBAL_MAX;\n}\n\nbool MethodContexts_getAllFlags(void) {\n    return MethodContexts_privateFlag && MethodContexts_publicFlag && globalEnabled;\n}\n\nvoid main(void) {\n    MethodContexts_getPrivateValueExternal();\n    MethodContexts_getPrivateSumViaInternal();\n    MethodContexts_getGlobalCounterViaInternal();\n    MethodContexts_getPrivateClampViaInternal();\n    MethodContexts_getPublicValue();\n    MethodContexts_getPublicClampValue();\n    MethodContexts_getPublicWrapValue();\n    MethodContexts_getPublicFlag();\n    MethodContexts_getPublicOffset();\n    MethodContexts_getGlobalMax();\n    MethodContexts_getGlobalThreshold();\n    MethodContexts_getGlobalCounter();\n    MethodContexts_getGlobalEnabled();\n    MethodContexts_getGlobalOffset();\n    MethodContexts_getGlobalScale();\n    MethodContexts_computePublicSum();\n    MethodContexts_publicValueBelowMax();\n    MethodContexts_computePublicWithOffset();\n    MethodContexts_setPrivateValue(42);\n    MethodContexts_setPublicValue(84);\n    MethodContexts_setPrivateFlag(true);\n    MethodContexts_setPublicFlag(false);\n    MethodContexts_incrementPublicClamp();\n    MethodContexts_incrementPublicWrap();\n    MethodContexts_modifyAllPrivate();\n    MethodContexts_modifyAllPublic();\n    MethodContexts_checkThresholds();\n    MethodContexts_getAllFlags();\n    MethodContexts_publicValue;\n    MethodContexts_publicClampValue;\n    MethodContexts_publicWrapValue;\n    MethodContexts_publicFlag;\n    MethodContexts_publicOffset;\n}\n",
        "last_modified": "2026-01-09T22:16:23.158806"
      },
      "task_intent": {
        "title": "100% Scope Testing Coverage",
        "description": "Expand the C-Next test suite to achieve comprehensive coverage of scope-related functionality including this./global. accessors with all data types, modifier permutations, and error cases.",
        "from_plan": true
      },
      "commits_behind_main": 1,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-09T22:16:23.137034",
  "last_updated": "2026-01-09T22:16:23.138616"
}