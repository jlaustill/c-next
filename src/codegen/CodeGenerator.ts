/**
 * C-Next Code Generator
 * Transforms C-Next AST to clean, readable C code
 */

import * as Parser from '../parser/grammar/CNextParser.js';

/**
 * Maps C-Next types to C types
 */
const TYPE_MAP: Record<string, string> = {
    'u8': 'uint8_t',
    'u16': 'uint16_t',
    'u32': 'uint32_t',
    'u64': 'uint64_t',
    'i8': 'int8_t',
    'i16': 'int16_t',
    'i32': 'int32_t',
    'i64': 'int64_t',
    'f32': 'float',
    'f64': 'double',
    'bool': 'bool',
    'void': 'void',
};

/**
 * Parameter info for ADR-006 pointer semantics
 */
interface ParameterInfo {
    name: string;
    isArray: boolean;
    isStruct: boolean;  // User-defined type (struct/class)
}

/**
 * Context for tracking current scope during code generation
 */
interface GeneratorContext {
    currentNamespace: string | null;
    currentClass: string | null;
    indentLevel: number;
    namespaceMembers: Map<string, Set<string>>; // namespace -> member names
    classMembers: Map<string, Set<string>>;     // class -> member names
    currentParameters: Map<string, ParameterInfo>; // ADR-006: track params for pointer semantics
    localArrays: Set<string>; // ADR-006: track local array variables (no & needed)
}

/**
 * Code Generator - Transpiles C-Next to C
 */
export default class CodeGenerator {
    private context: GeneratorContext = {
        currentNamespace: null,
        currentClass: null,
        indentLevel: 0,
        namespaceMembers: new Map(),
        classMembers: new Map(),
        currentParameters: new Map(),
        localArrays: new Set(),
    };

    private knownNamespaces: Set<string> = new Set();
    private knownClasses: Set<string> = new Set();
    private knownStructs: Set<string> = new Set();

    /**
     * Generate C code from a C-Next program
     */
    generate(tree: Parser.ProgramContext): string {
        // Reset state
        this.context = {
            currentNamespace: null,
            currentClass: null,
            indentLevel: 0,
            namespaceMembers: new Map(),
            classMembers: new Map(),
            currentParameters: new Map(),
            localArrays: new Set(),
        };
        this.knownNamespaces = new Set();
        this.knownClasses = new Set();
        this.knownStructs = new Set();

        // First pass: collect namespace and class members
        this.collectSymbols(tree);

        const output: string[] = [];

        // Add standard header
        output.push('/**');
        output.push(' * Generated by C-Next Transpiler');
        output.push(' * A safer C for embedded systems');
        output.push(' */');
        output.push('');
        output.push('#include <stdint.h>');
        output.push('#include <stdbool.h>');
        output.push('');

        // Visit all declarations
        for (const decl of tree.declaration()) {
            const code = this.generateDeclaration(decl);
            if (code) {
                output.push(code);
            }
        }

        return output.join('\n');
    }

    /**
     * First pass: collect all namespace and class member names
     */
    private collectSymbols(tree: Parser.ProgramContext): void {
        for (const decl of tree.declaration()) {
            if (decl.namespaceDeclaration()) {
                const ns = decl.namespaceDeclaration()!;
                const name = ns.IDENTIFIER().getText();
                this.knownNamespaces.add(name);

                const members = new Set<string>();
                for (const member of ns.namespaceMember()) {
                    if (member.variableDeclaration()) {
                        members.add(member.variableDeclaration()!.IDENTIFIER().getText());
                    }
                    if (member.functionDeclaration()) {
                        members.add(member.functionDeclaration()!.IDENTIFIER().getText());
                    }
                }
                this.context.namespaceMembers.set(name, members);
            }

            if (decl.classDeclaration()) {
                const cls = decl.classDeclaration()!;
                const name = cls.IDENTIFIER().getText();
                this.knownClasses.add(name);

                const members = new Set<string>();
                for (const member of cls.classMember()) {
                    if (member.fieldDeclaration()) {
                        members.add(member.fieldDeclaration()!.IDENTIFIER().getText());
                    }
                    if (member.methodDeclaration()) {
                        members.add(member.methodDeclaration()!.IDENTIFIER().getText());
                    }
                }
                this.context.classMembers.set(name, members);
            }

            if (decl.structDeclaration()) {
                const name = decl.structDeclaration()!.IDENTIFIER().getText();
                this.knownStructs.add(name);
            }
        }
    }

    /**
     * Check if a type name is a user-defined struct/class
     */
    private isStructType(typeName: string): boolean {
        return this.knownStructs.has(typeName) || this.knownClasses.has(typeName);
    }

    /**
     * Set up parameter tracking for a function
     */
    private setParameters(params: Parser.ParameterListContext | null): void {
        this.context.currentParameters.clear();

        if (!params) return;

        for (const param of params.parameter()) {
            const name = param.IDENTIFIER().getText();
            const isArray = param.arrayDimension() !== null;
            const typeCtx = param.type();

            // Determine if it's a struct type
            let isStruct = false;
            if (typeCtx.userType()) {
                const typeName = typeCtx.userType()!.getText();
                isStruct = this.isStructType(typeName);
            }

            this.context.currentParameters.set(name, { name, isArray, isStruct });
        }
    }

    /**
     * Clear parameter tracking when leaving a function
     */
    private clearParameters(): void {
        this.context.currentParameters.clear();
        this.context.localArrays.clear();
    }

    /**
     * Extract a simple identifier from an expression, if it is one.
     * Returns null for complex expressions.
     */
    private getSimpleIdentifier(ctx: Parser.ExpressionContext): string | null {
        // Navigate: expression -> orExpression -> andExpression -> equalityExpression
        // -> relationalExpression -> bitwiseOrExpression -> bitwiseXorExpression
        // -> bitwiseAndExpression -> shiftExpression -> additiveExpression
        // -> multiplicativeExpression -> unaryExpression -> postfixExpression
        // -> primaryExpression
        const or = ctx.orExpression();
        if (or.andExpression().length !== 1) return null;

        const and = or.andExpression()[0];
        if (and.equalityExpression().length !== 1) return null;

        const eq = and.equalityExpression()[0];
        if (eq.relationalExpression().length !== 1) return null;

        const rel = eq.relationalExpression()[0];
        if (rel.bitwiseOrExpression().length !== 1) return null;

        const bor = rel.bitwiseOrExpression()[0];
        if (bor.bitwiseXorExpression().length !== 1) return null;

        const bxor = bor.bitwiseXorExpression()[0];
        if (bxor.bitwiseAndExpression().length !== 1) return null;

        const band = bxor.bitwiseAndExpression()[0];
        if (band.shiftExpression().length !== 1) return null;

        const shift = band.shiftExpression()[0];
        if (shift.additiveExpression().length !== 1) return null;

        const add = shift.additiveExpression()[0];
        if (add.multiplicativeExpression().length !== 1) return null;

        const mult = add.multiplicativeExpression()[0];
        if (mult.unaryExpression().length !== 1) return null;

        const unary = mult.unaryExpression()[0];
        if (!unary.postfixExpression()) return null;

        const postfix = unary.postfixExpression()!;
        if (postfix.postfixOp().length !== 0) return null; // Has operators like . or []

        const primary = postfix.primaryExpression();
        if (!primary.IDENTIFIER()) return null;

        return primary.IDENTIFIER()!.getText();
    }

    /**
     * Generate a function argument with proper ADR-006 semantics.
     * - Local variables get & (address-of)
     * - Parameters are passed as-is (already pointers)
     * - Arrays are passed as-is (naturally decay to pointers)
     * - Literals and complex expressions are passed as-is
     */
    private generateFunctionArg(ctx: Parser.ExpressionContext): string {
        const id = this.getSimpleIdentifier(ctx);

        if (id) {
            // Check if it's a parameter (already a pointer)
            const paramInfo = this.context.currentParameters.get(id);
            if (paramInfo) {
                // Arrays are passed as-is, non-arrays are already pointers
                return id;
            }

            // Check if it's a local array (passed as-is, naturally decays to pointer)
            if (this.context.localArrays.has(id)) {
                return id;
            }

            // Check if it's a namespace member
            if (this.context.currentNamespace) {
                const members = this.context.namespaceMembers.get(this.context.currentNamespace);
                if (members && members.has(id)) {
                    return `&${this.context.currentNamespace}_${id}`;
                }
            }

            // Check if it's a class field
            if (this.context.currentClass) {
                const members = this.context.classMembers.get(this.context.currentClass);
                if (members && members.has(id)) {
                    return `&self->${id}`;
                }
            }

            // Local variable - add &
            return `&${id}`;
        }

        // Complex expression or literal - generate normally
        return this.generateExpression(ctx);
    }

    // ========================================================================
    // Declarations
    // ========================================================================

    private generateDeclaration(ctx: Parser.DeclarationContext): string {
        if (ctx.namespaceDeclaration()) {
            return this.generateNamespace(ctx.namespaceDeclaration()!);
        }
        if (ctx.classDeclaration()) {
            return this.generateClass(ctx.classDeclaration()!);
        }
        if (ctx.registerDeclaration()) {
            return this.generateRegister(ctx.registerDeclaration()!);
        }
        if (ctx.structDeclaration()) {
            return this.generateStruct(ctx.structDeclaration()!);
        }
        if (ctx.functionDeclaration()) {
            return this.generateFunction(ctx.functionDeclaration()!);
        }
        if (ctx.variableDeclaration()) {
            return this.generateVariableDecl(ctx.variableDeclaration()!) + '\n';
        }
        return '';
    }

    // ========================================================================
    // Namespace (ADR-002: Singleton services)
    // ========================================================================

    private generateNamespace(ctx: Parser.NamespaceDeclarationContext): string {
        const name = ctx.IDENTIFIER().getText();
        this.context.currentNamespace = name;

        const lines: string[] = [];
        lines.push(`/* Namespace: ${name} */`);

        for (const member of ctx.namespaceMember()) {
            const visibility = member.visibilityModifier()?.getText() || 'public';
            const isPrivate = visibility === 'private';

            if (member.variableDeclaration()) {
                const varDecl = member.variableDeclaration()!;
                const type = this.generateType(varDecl.type());
                const varName = varDecl.IDENTIFIER().getText();
                const fullName = `${name}_${varName}`;
                const prefix = isPrivate ? 'static ' : '';

                let decl = `${prefix}${type} ${fullName}`;
                if (varDecl.arrayDimension()) {
                    decl += this.generateArrayDimension(varDecl.arrayDimension()!);
                }
                if (varDecl.expression()) {
                    decl += ` = ${this.generateExpression(varDecl.expression()!)}`;
                }
                lines.push(decl + ';');
            }

            if (member.functionDeclaration()) {
                const funcDecl = member.functionDeclaration()!;
                const returnType = this.generateType(funcDecl.type());
                const funcName = funcDecl.IDENTIFIER().getText();
                const fullName = `${name}_${funcName}`;
                const prefix = isPrivate ? 'static ' : '';

                // Track parameters for ADR-006 pointer semantics
                this.setParameters(funcDecl.parameterList() ?? null);

                const params = funcDecl.parameterList()
                    ? this.generateParameterList(funcDecl.parameterList()!)
                    : 'void';

                const body = this.generateBlock(funcDecl.block());
                this.clearParameters();

                lines.push('');
                lines.push(`${prefix}${returnType} ${fullName}(${params}) ${body}`);
            }
        }

        lines.push('');
        this.context.currentNamespace = null;
        return lines.join('\n');
    }

    // ========================================================================
    // Class (ADR-005: Multiple instances, no inheritance)
    // ========================================================================

    private generateClass(ctx: Parser.ClassDeclarationContext): string {
        const name = ctx.IDENTIFIER().getText();
        this.context.currentClass = name;

        const lines: string[] = [];
        lines.push(`/* Class: ${name} */`);
        lines.push(`typedef struct {`);

        // Generate struct fields
        for (const member of ctx.classMember()) {
            if (member.fieldDeclaration()) {
                const field = member.fieldDeclaration()!;
                const type = this.generateType(field.type());
                const fieldName = field.IDENTIFIER().getText();
                let decl = `    ${type} ${fieldName}`;
                if (field.arrayDimension()) {
                    decl += this.generateArrayDimension(field.arrayDimension()!);
                }
                lines.push(decl + ';');
            }
        }

        lines.push(`} ${name};`);
        lines.push('');

        // Generate methods as functions with self pointer
        for (const member of ctx.classMember()) {
            if (member.methodDeclaration()) {
                const method = member.methodDeclaration()!;
                const returnType = this.generateType(method.type());
                const methodName = method.IDENTIFIER().getText();
                const fullName = `${name}_${methodName}`;

                // Track parameters for ADR-006 pointer semantics
                this.setParameters(method.parameterList() ?? null);

                let params = `${name}* self`;
                if (method.parameterList()) {
                    params += ', ' + this.generateParameterList(method.parameterList()!);
                }

                const body = this.generateBlock(method.block());
                this.clearParameters();

                lines.push(`${returnType} ${fullName}(${params}) ${body}`);
                lines.push('');
            }

            if (member.constructorDeclaration()) {
                const ctor = member.constructorDeclaration()!;
                const fullName = `${name}_init`;

                // Track parameters for ADR-006 pointer semantics
                this.setParameters(ctor.parameterList() ?? null);

                let params = `${name}* self`;
                if (ctor.parameterList()) {
                    params += ', ' + this.generateParameterList(ctor.parameterList()!);
                }

                const body = this.generateBlock(ctor.block());
                this.clearParameters();

                lines.push(`void ${fullName}(${params}) ${body}`);
                lines.push('');
            }
        }

        this.context.currentClass = null;
        return lines.join('\n');
    }

    // ========================================================================
    // Register Bindings (ADR-004)
    // ========================================================================

    private generateRegister(ctx: Parser.RegisterDeclarationContext): string {
        const name = ctx.IDENTIFIER().getText();
        const address = this.generateExpression(ctx.expression());

        const lines: string[] = [];
        lines.push(`/* Register: ${name} @ ${address} */`);
        lines.push(`typedef struct {`);

        for (const member of ctx.registerMember()) {
            const regName = member.IDENTIFIER().getText();
            const regType = this.generateType(member.type());
            const access = member.accessModifier().getText();

            let qualifiers = 'volatile ';
            if (access === 'ro') {
                qualifiers += 'const ';
            }

            lines.push(`    ${qualifiers}${regType} ${regName};`);
        }

        lines.push(`} ${name}_TypeDef;`);
        lines.push('');
        lines.push(`#define ${name} (*(volatile ${name}_TypeDef*)${address})`);
        lines.push('');

        return lines.join('\n');
    }

    // ========================================================================
    // Struct
    // ========================================================================

    private generateStruct(ctx: Parser.StructDeclarationContext): string {
        const name = ctx.IDENTIFIER().getText();

        const lines: string[] = [];
        lines.push(`typedef struct {`);

        for (const member of ctx.structMember()) {
            const volatile = member.volatileModifier() ? 'volatile ' : '';
            const type = this.generateType(member.type());
            const fieldName = member.IDENTIFIER().getText();
            lines.push(`    ${volatile}${type} ${fieldName};`);
        }

        lines.push(`} ${name};`);
        lines.push('');

        return lines.join('\n');
    }

    // ========================================================================
    // Functions
    // ========================================================================

    private generateFunction(ctx: Parser.FunctionDeclarationContext): string {
        const returnType = this.generateType(ctx.type());
        const name = ctx.IDENTIFIER().getText();

        // Track parameters for ADR-006 pointer semantics
        this.setParameters(ctx.parameterList() ?? null);

        const params = ctx.parameterList()
            ? this.generateParameterList(ctx.parameterList()!)
            : 'void';
        const body = this.generateBlock(ctx.block());

        this.clearParameters();

        return `${returnType} ${name}(${params}) ${body}\n`;
    }

    private generateParameterList(ctx: Parser.ParameterListContext): string {
        return ctx.parameter().map(p => this.generateParameter(p)).join(', ');
    }

    private generateParameter(ctx: Parser.ParameterContext): string {
        const constMod = ctx.constModifier() ? 'const ' : '';
        const type = this.generateType(ctx.type());
        const name = ctx.IDENTIFIER().getText();

        // Arrays pass naturally as pointers
        if (ctx.arrayDimension()) {
            const dim = this.generateArrayDimension(ctx.arrayDimension()!);
            return `${constMod}${type} ${name}${dim}`;
        }

        // ADR-006: Pass by reference for non-array types
        // Add pointer for primitive types to enable pass-by-reference semantics
        return `${constMod}${type}* ${name}`;
    }

    private generateArrayDimension(ctx: Parser.ArrayDimensionContext): string {
        if (ctx.expression()) {
            return `[${this.generateExpression(ctx.expression()!)}]`;
        }
        return '[]';
    }

    // ========================================================================
    // Variables
    // ========================================================================

    private generateVariableDecl(ctx: Parser.VariableDeclarationContext): string {
        const type = this.generateType(ctx.type());
        const name = ctx.IDENTIFIER().getText();

        let decl = `${type} ${name}`;

        if (ctx.arrayDimension()) {
            decl += this.generateArrayDimension(ctx.arrayDimension()!);
            // ADR-006: Track local arrays (they don't need & when passed to functions)
            this.context.localArrays.add(name);
        }

        if (ctx.expression()) {
            decl += ` = ${this.generateExpression(ctx.expression()!)}`;
        }

        return decl + ';';
    }

    // ========================================================================
    // Statements
    // ========================================================================

    private generateBlock(ctx: Parser.BlockContext): string {
        this.context.indentLevel++;
        const lines: string[] = ['{'];

        for (const stmt of ctx.statement()) {
            const stmtCode = this.generateStatement(stmt);
            if (stmtCode) {
                lines.push(this.indent(stmtCode));
            }
        }

        this.context.indentLevel--;
        lines.push('}');

        return lines.join('\n');
    }

    private generateStatement(ctx: Parser.StatementContext): string {
        if (ctx.variableDeclaration()) {
            return this.generateVariableDecl(ctx.variableDeclaration()!);
        }
        if (ctx.assignmentStatement()) {
            return this.generateAssignment(ctx.assignmentStatement()!);
        }
        if (ctx.expressionStatement()) {
            return this.generateExpression(ctx.expressionStatement()!.expression()) + ';';
        }
        if (ctx.ifStatement()) {
            return this.generateIf(ctx.ifStatement()!);
        }
        if (ctx.whileStatement()) {
            return this.generateWhile(ctx.whileStatement()!);
        }
        if (ctx.forStatement()) {
            return this.generateFor(ctx.forStatement()!);
        }
        if (ctx.returnStatement()) {
            return this.generateReturn(ctx.returnStatement()!);
        }
        if (ctx.block()) {
            return this.generateBlock(ctx.block()!);
        }
        return '';
    }

    // ADR-001: <- becomes = in C
    private generateAssignment(ctx: Parser.AssignmentStatementContext): string {
        const target = this.generateAssignmentTarget(ctx.assignmentTarget());
        const value = this.generateExpression(ctx.expression());
        return `${target} = ${value};`;
    }

    private generateAssignmentTarget(ctx: Parser.AssignmentTargetContext): string {
        if (ctx.memberAccess()) {
            return this.generateMemberAccess(ctx.memberAccess()!);
        }
        if (ctx.arrayAccess()) {
            return this.generateArrayAccess(ctx.arrayAccess()!);
        }

        const id = ctx.IDENTIFIER()!.getText();

        // If inside a namespace, check if this identifier is a namespace member
        if (this.context.currentNamespace) {
            const members = this.context.namespaceMembers.get(this.context.currentNamespace);
            if (members && members.has(id)) {
                return `${this.context.currentNamespace}_${id}`;
            }
        }

        // If inside a class, check if this identifier is a class field
        if (this.context.currentClass) {
            const members = this.context.classMembers.get(this.context.currentClass);
            if (members && members.has(id)) {
                return `self->${id}`;
            }
        }

        // ADR-006: Dereference parameter when writing to it
        // (non-array parameters are passed as pointers)
        const paramInfo = this.context.currentParameters.get(id);
        if (paramInfo && !paramInfo.isArray) {
            return `(*${id})`;
        }

        return id;
    }

    private generateIf(ctx: Parser.IfStatementContext): string {
        const condition = this.generateExpression(ctx.expression());
        const statements = ctx.statement();
        const thenBranch = this.generateStatement(statements[0]);

        let result = `if (${condition}) ${thenBranch}`;

        if (statements.length > 1) {
            const elseBranch = this.generateStatement(statements[1]);
            result += ` else ${elseBranch}`;
        }

        return result;
    }

    private generateWhile(ctx: Parser.WhileStatementContext): string {
        const condition = this.generateExpression(ctx.expression());
        const body = this.generateStatement(ctx.statement());
        return `while (${condition}) ${body}`;
    }

    private generateFor(ctx: Parser.ForStatementContext): string {
        let init = '';
        const forInit = ctx.forInit();
        if (forInit) {
            if (forInit.variableDeclaration()) {
                // Remove trailing semicolon since for loop adds it
                init = this.generateVariableDecl(forInit.variableDeclaration()!);
                init = init.slice(0, -1); // Remove semicolon
            } else if (forInit.assignmentStatement()) {
                init = this.generateAssignment(forInit.assignmentStatement()!);
                init = init.slice(0, -1); // Remove semicolon
            }
        }

        let condition = '';
        if (ctx.expression()) {
            condition = this.generateExpression(ctx.expression()!);
        }

        let update = '';
        const forUpdate = ctx.forUpdate();
        if (forUpdate) {
            const target = this.generateAssignmentTarget(forUpdate.assignmentTarget());
            const value = this.generateExpression(forUpdate.expression());
            update = `${target} = ${value}`;
        }

        const body = this.generateStatement(ctx.statement());

        return `for (${init}; ${condition}; ${update}) ${body}`;
    }

    private generateReturn(ctx: Parser.ReturnStatementContext): string {
        if (ctx.expression()) {
            return `return ${this.generateExpression(ctx.expression()!)};`;
        }
        return 'return;';
    }

    // ========================================================================
    // Expressions
    // ========================================================================

    private generateExpression(ctx: Parser.ExpressionContext): string {
        return this.generateOrExpr(ctx.orExpression());
    }

    private generateOrExpr(ctx: Parser.OrExpressionContext): string {
        const parts = ctx.andExpression().map(e => this.generateAndExpr(e));
        return parts.join(' || ');
    }

    private generateAndExpr(ctx: Parser.AndExpressionContext): string {
        const parts = ctx.equalityExpression().map(e => this.generateEqualityExpr(e));
        return parts.join(' && ');
    }

    // ADR-001: = becomes == in C
    private generateEqualityExpr(ctx: Parser.EqualityExpressionContext): string {
        const exprs = ctx.relationalExpression();
        if (exprs.length === 1) {
            return this.generateRelationalExpr(exprs[0]);
        }

        // Build the expression, transforming = to ==
        let result = this.generateRelationalExpr(exprs[0]);

        // Get the full text to find operators
        const fullText = ctx.getText();

        for (let i = 1; i < exprs.length; i++) {
            // Check if there's a != operator before this expression
            // Simple heuristic: look for != in the text
            const op = fullText.includes('!=') ? '!=' : '==';
            result += ` ${op} ${this.generateRelationalExpr(exprs[i])}`;
        }

        return result;
    }

    private generateRelationalExpr(ctx: Parser.RelationalExpressionContext): string {
        const exprs = ctx.bitwiseOrExpression();
        if (exprs.length === 1) {
            return this.generateBitwiseOrExpr(exprs[0]);
        }

        let result = this.generateBitwiseOrExpr(exprs[0]);
        const text = ctx.getText();

        for (let i = 1; i < exprs.length; i++) {
            let op = '<';
            if (text.includes('>=')) op = '>=';
            else if (text.includes('<=')) op = '<=';
            else if (text.includes('>')) op = '>';

            result += ` ${op} ${this.generateBitwiseOrExpr(exprs[i])}`;
        }

        return result;
    }

    private generateBitwiseOrExpr(ctx: Parser.BitwiseOrExpressionContext): string {
        const parts = ctx.bitwiseXorExpression().map(e => this.generateBitwiseXorExpr(e));
        return parts.join(' | ');
    }

    private generateBitwiseXorExpr(ctx: Parser.BitwiseXorExpressionContext): string {
        const parts = ctx.bitwiseAndExpression().map(e => this.generateBitwiseAndExpr(e));
        return parts.join(' ^ ');
    }

    private generateBitwiseAndExpr(ctx: Parser.BitwiseAndExpressionContext): string {
        const parts = ctx.shiftExpression().map(e => this.generateShiftExpr(e));
        return parts.join(' & ');
    }

    private generateShiftExpr(ctx: Parser.ShiftExpressionContext): string {
        const exprs = ctx.additiveExpression();
        if (exprs.length === 1) {
            return this.generateAdditiveExpr(exprs[0]);
        }

        let result = this.generateAdditiveExpr(exprs[0]);
        const text = ctx.getText();

        for (let i = 1; i < exprs.length; i++) {
            const op = text.includes('<<') ? '<<' : '>>';
            result += ` ${op} ${this.generateAdditiveExpr(exprs[i])}`;
        }

        return result;
    }

    private generateAdditiveExpr(ctx: Parser.AdditiveExpressionContext): string {
        const exprs = ctx.multiplicativeExpression();
        if (exprs.length === 1) {
            return this.generateMultiplicativeExpr(exprs[0]);
        }

        // Need to get operators - for now use simple approach
        let result = this.generateMultiplicativeExpr(exprs[0]);
        const text = ctx.getText();

        for (let i = 1; i < exprs.length; i++) {
            // Simple heuristic to determine operator
            const op = text.includes('-') ? '-' : '+';
            result += ` ${op} ${this.generateMultiplicativeExpr(exprs[i])}`;
        }

        return result;
    }

    private generateMultiplicativeExpr(ctx: Parser.MultiplicativeExpressionContext): string {
        const exprs = ctx.unaryExpression();
        if (exprs.length === 1) {
            return this.generateUnaryExpr(exprs[0]);
        }

        let result = this.generateUnaryExpr(exprs[0]);
        const text = ctx.getText();

        for (let i = 1; i < exprs.length; i++) {
            let op = '*';
            if (text.includes('/')) op = '/';
            else if (text.includes('%')) op = '%';
            result += ` ${op} ${this.generateUnaryExpr(exprs[i])}`;
        }

        return result;
    }

    private generateUnaryExpr(ctx: Parser.UnaryExpressionContext): string {
        if (ctx.postfixExpression()) {
            return this.generatePostfixExpr(ctx.postfixExpression()!);
        }

        const inner = this.generateUnaryExpr(ctx.unaryExpression()!);
        const text = ctx.getText();

        if (text.startsWith('!')) return `!${inner}`;
        if (text.startsWith('-')) return `-${inner}`;
        if (text.startsWith('~')) return `~${inner}`;
        if (text.startsWith('&')) return `&${inner}`;

        return inner;
    }

    private generatePostfixExpr(ctx: Parser.PostfixExpressionContext): string {
        const primary = ctx.primaryExpression();
        const ops = ctx.postfixOp();

        // Check if this is a struct parameter - we may need to handle -> access
        const primaryId = primary.IDENTIFIER()?.getText();
        const paramInfo = primaryId ? this.context.currentParameters.get(primaryId) : null;
        const isStructParam = paramInfo?.isStruct ?? false;

        let result = this.generatePrimaryExpr(primary);

        for (let i = 0; i < ops.length; i++) {
            const op = ops[i];

            // Member access
            if (op.IDENTIFIER()) {
                const memberName = op.IDENTIFIER()!.getText();

                // Check if this is a namespace member access: Namespace.member
                if (this.knownNamespaces.has(result)) {
                    // Transform Namespace.member to Namespace_member
                    result = `${result}_${memberName}`;
                }
                // Check if this is a class member access on 'self'
                else if (result === 'self' && this.context.currentClass) {
                    result = `self->${memberName}`;
                }
                // ADR-006: Struct parameter uses -> for member access
                else if (isStructParam && result === primaryId) {
                    result = `${result}->${memberName}`;
                }
                else {
                    result = `${result}.${memberName}`;
                }
            }
            // Array subscript
            else if (op.expression()) {
                result = `${result}[${this.generateExpression(op.expression()!)}]`;
            }
            // Function call - ADR-006: add & for local variable arguments
            else if (op.argumentList()) {
                const args = op.argumentList()!.expression()
                    .map(e => this.generateFunctionArg(e))
                    .join(', ');
                result = `${result}(${args})`;
            }
            // Empty function call
            else {
                result = `${result}()`;
            }
        }

        return result;
    }

    private generatePrimaryExpr(ctx: Parser.PrimaryExpressionContext): string {
        if (ctx.IDENTIFIER()) {
            const id = ctx.IDENTIFIER()!.getText();

            // If inside a namespace, check if this identifier is a namespace member
            if (this.context.currentNamespace) {
                const members = this.context.namespaceMembers.get(this.context.currentNamespace);
                if (members && members.has(id)) {
                    return `${this.context.currentNamespace}_${id}`;
                }
            }

            // If inside a class, check if this identifier is a class field
            if (this.context.currentClass) {
                const members = this.context.classMembers.get(this.context.currentClass);
                if (members && members.has(id)) {
                    return `self->${id}`;
                }
            }

            // ADR-006: Dereference parameter when reading its value
            // (non-array parameters are passed as pointers)
            // Note: Struct parameters use -> for member access, handled in generatePostfixExpr
            const paramInfo = this.context.currentParameters.get(id);
            if (paramInfo && !paramInfo.isArray && !paramInfo.isStruct) {
                return `(*${id})`;
            }
            // For struct parameters, return as-is here (will use -> in member access)
            // or dereference if used as a whole value
            if (paramInfo && paramInfo.isStruct) {
                return id; // Will be handled by postfix context
            }

            return id;
        }
        if (ctx.literal()) {
            return ctx.literal()!.getText();
        }
        if (ctx.expression()) {
            return `(${this.generateExpression(ctx.expression()!)})`;
        }
        return '';
    }

    private generateMemberAccess(ctx: Parser.MemberAccessContext): string {
        const parts = ctx.IDENTIFIER().map(id => id.getText());
        const expressions = ctx.expression();

        if (expressions.length > 0) {
            const firstPart = parts[0];
            const index = this.generateExpression(expressions[0]);
            if (parts.length > 1) {
                return `${firstPart}[${index}].${parts.slice(1).join('.')}`;
            }
            return `${firstPart}[${index}]`;
        }

        // ADR-006: Check if the first part is a struct parameter
        const firstPart = parts[0];
        const paramInfo = this.context.currentParameters.get(firstPart);
        if (paramInfo && paramInfo.isStruct) {
            // Use -> for struct parameter member access
            if (parts.length === 1) {
                return firstPart;
            }
            return `${firstPart}->${parts.slice(1).join('.')}`;
        }

        return parts.join('.');
    }

    private generateArrayAccess(ctx: Parser.ArrayAccessContext): string {
        const name = ctx.IDENTIFIER().getText();
        const index = this.generateExpression(ctx.expression());
        return `${name}[${index}]`;
    }

    // ========================================================================
    // Types
    // ========================================================================

    private generateType(ctx: Parser.TypeContext): string {
        if (ctx.primitiveType()) {
            const type = ctx.primitiveType()!.getText();
            return TYPE_MAP[type] || type;
        }
        if (ctx.userType()) {
            return ctx.userType()!.getText();
        }
        if (ctx.arrayType()) {
            const arrCtx = ctx.arrayType()!;
            let baseType: string;
            if (arrCtx.primitiveType()) {
                baseType = TYPE_MAP[arrCtx.primitiveType()!.getText()] || arrCtx.primitiveType()!.getText();
            } else {
                baseType = arrCtx.userType()!.getText();
            }
            return baseType;
        }
        if (ctx.genericType()) {
            // Generics need special handling - for now, return the base name
            return ctx.genericType()!.IDENTIFIER().getText();
        }
        if (ctx.getText() === 'void') {
            return 'void';
        }
        return ctx.getText();
    }

    // ========================================================================
    // Helpers
    // ========================================================================

    private indent(text: string): string {
        const spaces = '    '.repeat(this.context.indentLevel);
        return text.split('\n').map(line => spaces + line).join('\n');
    }
}
