/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {
    if (a > UINT32_MAX - b) return UINT32_MAX;
    return a + b;
}

uint32_t main(void) {
    uint8_t buffer[256] = {0};
    uint32_t offset = 0;
    uint32_t magic = 0x50415255;
    if (offset + 4 <= sizeof(buffer)) { memcpy(&buffer[offset], &magic, 4); }
    offset = cnx_clamp_add_u32(offset, 4);
    uint16_t version = 0x0100;
    if (offset + 2 <= sizeof(buffer)) { memcpy(&buffer[offset], &version, 2); }
    offset = cnx_clamp_add_u32(offset, 2);
    uint16_t length = 20;
    if (offset + 2 <= sizeof(buffer)) { memcpy(&buffer[offset], &length, 2); }
    offset = cnx_clamp_add_u32(offset, 2);
    uint8_t flags = 0x0F;
    if (offset + 1 <= sizeof(buffer)) { memcpy(&buffer[offset], &flags, 1); }
    offset = cnx_clamp_add_u32(offset, 1);
    uint8_t reserved1 = 0;
    uint8_t reserved2 = 0;
    uint8_t reserved3 = 0;
    if (offset + 1 <= sizeof(buffer)) { memcpy(&buffer[offset], &reserved1, 1); }
    offset = cnx_clamp_add_u32(offset, 1);
    if (offset + 1 <= sizeof(buffer)) { memcpy(&buffer[offset], &reserved2, 1); }
    offset = cnx_clamp_add_u32(offset, 1);
    if (offset + 1 <= sizeof(buffer)) { memcpy(&buffer[offset], &reserved3, 1); }
    offset = cnx_clamp_add_u32(offset, 1);
    uint64_t data = 0x0102030405060708;
    if (offset + 8 <= sizeof(buffer)) { memcpy(&buffer[offset], &data, 8); }
    offset = cnx_clamp_add_u32(offset, 8);
    if (offset != 20) return 1;
    if (buffer[0] != 0x55) return 2;
    if (buffer[1] != 0x52) return 3;
    if (buffer[2] != 0x41) return 4;
    if (buffer[3] != 0x50) return 5;
    if (buffer[4] != 0x00) return 6;
    if (buffer[5] != 0x01) return 7;
    if (buffer[6] != 20) return 8;
    if (buffer[7] != 0) return 9;
    if (buffer[8] != 0x0F) return 10;
    if (buffer[9] != 0) return 11;
    if (buffer[10] != 0) return 12;
    if (buffer[11] != 0) return 13;
    if (buffer[12] != 0x08) return 14;
    if (buffer[13] != 0x07) return 15;
    if (buffer[14] != 0x06) return 16;
    if (buffer[15] != 0x05) return 17;
    if (buffer[16] != 0x04) return 18;
    if (buffer[17] != 0x03) return 19;
    if (buffer[18] != 0x02) return 20;
    if (buffer[19] != 0x01) return 21;
    uint32_t newMagic = 0x44434241;
    if (0 + 4 <= sizeof(buffer)) { memcpy(&buffer[0], &newMagic, 4); }
    if (buffer[0] != 0x41) return 22;
    if (buffer[1] != 0x42) return 23;
    if (buffer[2] != 0x43) return 24;
    if (buffer[3] != 0x44) return 25;
    if (buffer[4] != 0x00) return 26;
    if (buffer[8] != 0x0F) return 27;
    return 0;
}
