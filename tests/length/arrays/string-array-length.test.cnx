// test-execution
// Comprehensive .length test for string arrays across all contexts
// Tests: array.length returns 4 (element count), string.length returns strlen (runtime)
string<64> globalArr[4];

scope TestScope {
    public u32 getGlobalArrayLength() {
        return global.globalArr.length;
    }
    string<64> scopeArr[4];
    public u32 getScopeArrayLength() {
        return this.scopeArr.length;
    }
    public string<64> publicArr[4];
}

u32 checkArrayLength(string<64> arr[4]) {
    return arr.length;
}

struct TestStruct {
    string<64> arr[4];
}

i32 main() {
    globalArr[0] <- "Hello";
    globalArr[1] <- "World";

   
// Test array.length (element count)
    if (globalArr.length != 4) {
        return 1;
    }

   
// Test string[0].length (runtime strlen)
    if (globalArr[0].length != 5) {
        return 2;
    }

    // Scope access - array length
    if (TestScope.getGlobalArrayLength() != 4) {
        return 3;
    }

    // Scope member - array length
    if (TestScope.getScopeArrayLength() != 4) {
        return 4;
    }

    // Cross-scope - array length
    if (TestScope.publicArr.length != 4) {
        return 5;
    }

    // Local array
    string<64> localArr[4];
    localArr[0] <- "Test";
    if (localArr.length != 4) {
        return 6;
    }
    if (localArr[0].length != 4) {
        return 7;
    }

    // Function parameter - array length
    string<64> testArr[4];
    testArr[0] <- "Param";
    if (checkArrayLength(testArr) != 4) {
        return 8;
    }

    // Struct member array
    TestStruct ts;
    ts.arr[0] <- "Struct";
    if (ts.arr.length != 4) {
        return 9;
    }
    if (ts.arr[0].length != 6) {
        return 10;
    }

    return 0;
}
