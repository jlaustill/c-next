/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// Test: Compound assignment on 3D arrays
// Covers all compound operators on deeply indexed array elements
uint32_t cube[3][3][3] = {0};

int main(void) {
    cube[0][0][0] = 100U;
    cube[1][1][1] = 50U;
    cube[2][2][2] = 10U;
    cube[0][1][2] = 100U;
    cube[2][1][0] = 17U;
    cube[1][0][2] = 0b11110000U;
    cube[0][2][1] = 0b00001111U;
    cube[2][0][1] = 0b10101010U;
    cube[1][2][0] = 8U;
    cube[1][1][0] = 128U;
    cube[0][0][0] += 25U;
    cube[1][1][1] -= 15U;
    cube[2][2][2] *= 7U;
    cube[0][1][2] /= 4U;
    cube[2][1][0] %= 5U;
    cube[1][0][2] &= 0b11001100U;
    cube[0][2][1] |= 0b11110000U;
    cube[2][0][1] ^= 0b11111111U;
    cube[1][2][0] <<= 2U;
    cube[1][1][0] >>= 3U;
    if (cube[0U][0U][0U] != 125) {
        return 1;
    }
    if (cube[1U][1U][1U] != 35) {
        return 2;
    }
    if (cube[2U][2U][2U] != 70) {
        return 3;
    }
    if (cube[0U][1U][2U] != 25) {
        return 4;
    }
    if (cube[2U][1U][0U] != 2) {
        return 5;
    }
    if (cube[1U][0U][2U] != 192) {
        return 6;
    }
    if (cube[0U][2U][1U] != 255) {
        return 7;
    }
    if (cube[2U][0U][1U] != 85) {
        return 8;
    }
    if (cube[1U][2U][0U] != 32) {
        return 9;
    }
    if (cube[1U][1U][0U] != 16) {
        return 10;
    }
    return 0;
}
