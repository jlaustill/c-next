"use strict";
/**
 * Header Generator
 * Generates C header (.h) files from C-Next source
 */
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const ESymbolKind_1 = __importDefault(require("../types/ESymbolKind"));
const ESourceLanguage_1 = __importDefault(require("../types/ESourceLanguage"));
/**
 * Maps C-Next types to C types
 */
const TYPE_MAP = {
  u8: "uint8_t",
  u16: "uint16_t",
  u32: "uint32_t",
  u64: "uint64_t",
  i8: "int8_t",
  i16: "int16_t",
  i32: "int32_t",
  i64: "int64_t",
  f32: "float",
  f64: "double",
  bool: "bool",
  void: "void",
  ISR: "ISR", // ADR-040: Interrupt Service Routine function pointer
};
/**
 * Generates C header files from symbol information
 */
class HeaderGenerator {
  /**
   * Generate a header file from symbols
   */
  generate(symbols, filename, options = {}) {
    const lines = [];
    const guard = this.makeGuard(filename, options.guardPrefix);
    // Header guard
    lines.push(`#ifndef ${guard}`);
    lines.push(`#define ${guard}`);
    lines.push("");
    // Header comment
    lines.push("/**");
    lines.push(" * Generated by C-Next Transpiler");
    lines.push(" * Header file for cross-language interoperability");
    lines.push(" */");
    lines.push("");
    // System includes
    if (options.includeSystemHeaders !== false) {
      lines.push("#include <stdint.h>");
      lines.push("#include <stdbool.h>");
      lines.push("");
    }
    // C++ compatibility
    lines.push("#ifdef __cplusplus");
    lines.push('extern "C" {');
    lines.push("#endif");
    lines.push("");
    // Filter symbols
    const exportedSymbols = options.exportedOnly
      ? symbols.filter((s) => s.isExported)
      : symbols;
    // Group symbols by kind
    const structs = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Struct,
    );
    const classes = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Class,
    );
    const functions = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Function,
    );
    const variables = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Variable,
    );
    const enums = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Enum,
    );
    const types = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind_1.default.Type,
    );
    // Forward declarations for structs
    if (structs.length > 0 || classes.length > 0) {
      lines.push("/* Forward declarations */");
      for (const sym of structs) {
        lines.push(`typedef struct ${sym.name} ${sym.name};`);
      }
      for (const sym of classes) {
        // Classes become typedefs to structs
        lines.push(`typedef struct ${sym.name} ${sym.name};`);
      }
      lines.push("");
    }
    // Enum declarations
    if (enums.length > 0) {
      lines.push("/* Enumerations */");
      for (const sym of enums) {
        // For now, just forward declare - full definition would require enum values
        lines.push(`/* Enum: ${sym.name} (see implementation for values) */`);
      }
      lines.push("");
    }
    // Type aliases
    if (types.length > 0) {
      lines.push("/* Type aliases */");
      for (const sym of types) {
        if (sym.type) {
          const cType = this.mapType(sym.type);
          lines.push(`typedef ${cType} ${sym.name};`);
        }
      }
      lines.push("");
    }
    // Extern variable declarations
    if (variables.length > 0) {
      lines.push("/* External variables */");
      for (const sym of variables) {
        const cType = sym.type ? this.mapType(sym.type) : "int";
        lines.push(`extern ${cType} ${sym.name};`);
      }
      lines.push("");
    }
    // Function prototypes
    if (functions.length > 0) {
      lines.push("/* Function prototypes */");
      for (const sym of functions) {
        const proto = this.generateFunctionPrototype(sym);
        if (proto) {
          lines.push(proto);
        }
      }
      lines.push("");
    }
    // C++ compatibility end
    lines.push("#ifdef __cplusplus");
    lines.push("}");
    lines.push("#endif");
    lines.push("");
    // End header guard
    lines.push(`#endif /* ${guard} */`);
    lines.push("");
    return lines.join("\n");
  }
  /**
   * Generate header from a symbol table, filtering by source file
   */
  generateFromSymbolTable(symbolTable, sourceFile, options = {}) {
    const symbols = symbolTable.getSymbolsByFile(sourceFile);
    const basename = sourceFile.replace(/\.[^.]+$/, "");
    const headerName = `${basename}.h`;
    return this.generate(symbols, headerName, options);
  }
  /**
   * Generate header for all C-Next symbols in the symbol table
   */
  generateCNextHeader(symbolTable, filename, options = {}) {
    const symbols = symbolTable.getSymbolsByLanguage(
      ESourceLanguage_1.default.CNext,
    );
    return this.generate(symbols, filename, options);
  }
  /**
   * Create an include guard macro from filename
   */
  makeGuard(filename, prefix) {
    // Remove path and extension
    const base = filename.replace(/^.*[\\/]/, "").replace(/\.[^.]+$/, "");
    // Convert to uppercase and replace non-alphanumeric with underscore
    const sanitized = base.toUpperCase().replace(/[^A-Z0-9]/g, "_");
    if (prefix) {
      return `${prefix.toUpperCase()}_${sanitized}_H`;
    }
    return `${sanitized}_H`;
  }
  /**
   * Map a C-Next type to C type
   */
  mapType(type) {
    // Check direct mapping first
    if (TYPE_MAP[type]) {
      return TYPE_MAP[type];
    }
    // Handle pointer types
    if (type.endsWith("*")) {
      const baseType = type.slice(0, -1).trim();
      return `${this.mapType(baseType)}*`;
    }
    // Handle array types (simplified)
    const arrayMatch = type.match(/^(\w+)\[(\d*)\]$/);
    if (arrayMatch) {
      const baseType = this.mapType(arrayMatch[1]);
      const size = arrayMatch[2] || "";
      return `${baseType}[${size}]`;
    }
    // User-defined types pass through
    return type;
  }
  /**
   * Generate a function prototype from symbol info
   * Handles all parameter edge cases per ADR-006, ADR-029, and ADR-040
   */
  generateFunctionPrototype(sym) {
    // Map return type from C-Next to C
    const returnType = sym.type ? this.mapType(sym.type) : "void";
    // Build parameter list with proper C semantics
    let params = "void"; // Default for no parameters
    if (sym.parameters && sym.parameters.length > 0) {
      const translatedParams = sym.parameters.map((p) => {
        const baseType = this.mapType(p.type);
        const constMod = p.isConst ? "const " : "";
        // Handle array parameters (pass naturally as pointers per C semantics)
        if (p.isArray && p.arrayDimensions) {
          const dims = p.arrayDimensions.map((d) => `[${d}]`).join("");
          // Special case: string[] becomes char* name[]
          if (p.type === "string") {
            return `${constMod}char* ${p.name}${dims}`;
          }
          return `${constMod}${baseType} ${p.name}${dims}`;
        }
        // ADR-040: ISR is already a function pointer typedef, no pointer needed
        if (p.type === "ISR") {
          return `${constMod}${baseType} ${p.name}`;
        }
        // Float types (f32, f64) use standard C pass-by-value semantics
        if (p.type === "f32" || p.type === "f64") {
          return `${constMod}${baseType} ${p.name}`;
        }
        // ADR-006: Pass by reference - non-array, non-float params become pointers
        // This applies to primitives (u32, i16, etc.) and struct types
        return `${constMod}${baseType}* ${p.name}`;
      });
      params = translatedParams.join(", ");
    }
    return `${returnType} ${sym.name}(${params});`;
  }
}
exports.default = HeaderGenerator;
