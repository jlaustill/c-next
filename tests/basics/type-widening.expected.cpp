/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: Implicit type widening (safe conversions)
// Demonstrates: smaller types implicitly widen to larger types
int main(void) {
    uint8_t byte = 255U;
    uint16_t word = byte;
    if (word != 255) return 1;
    uint32_t dword = word;
    if (dword != 255) return 2;
    uint64_t qword = dword;
    if (qword != 255) return 3;
    int8_t sbyte = -128;
    int16_t sword = sbyte;
    if (sword != -128) return 4;
    int32_t sdword = sword;
    if (sdword != -128) return 5;
    int64_t sqword = sdword;
    if (sqword != -128) return 6;
    int8_t posByte = 127;
    int32_t posWord = posByte;
    if (posWord != 127) return 7;
    float single = 3.14;
    double precise = single;
    if (precise < 3.13 || precise > 3.15) return 8;
    uint8_t a = 200U;
    uint8_t b = 200U;
    uint16_t sum = a + b;
    if (sum != 400) return 9;
    return 0;
}
