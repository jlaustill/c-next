/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>


#include <stdint.h>
#include <stdbool.h>
#include <cmsis_gcc.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

/* Scope: SysTick */

/* Bitmap: SysTick_ControlBits */
/* Fields:
 *   ENABLE: bit 0 (1 bit)
 *   TICKINT: bit 1 (1 bit)
 *   CLKSOURCE: bit 2 (1 bit)
 *   Reserved_3: bit 3 (1 bit)
 *   Reserved_4: bit 4 (1 bit)
 *   Reserved_5: bit 5 (1 bit)
 *   Reserved_6: bit 6 (1 bit)
 *   Reserved_7: bit 7 (1 bit)
 *   Reserved_8: bit 8 (1 bit)
 *   Reserved_9: bit 9 (1 bit)
 *   Reserved_10: bit 10 (1 bit)
 *   Reserved_11: bit 11 (1 bit)
 *   Reserved_12: bit 12 (1 bit)
 *   Reserved_13: bit 13 (1 bit)
 *   Reserved_14: bit 14 (1 bit)
 *   Reserved_15: bit 15 (1 bit)
 *   COUNTFLAG: bit 16 (1 bit)
 *   Reserved_17: bit 17 (1 bit)
 *   Reserved_18: bit 18 (1 bit)
 *   Reserved_19: bit 19 (1 bit)
 *   Reserved_20: bit 20 (1 bit)
 *   Reserved_21: bit 21 (1 bit)
 *   Reserved_22: bit 22 (1 bit)
 *   Reserved_23: bit 23 (1 bit)
 *   Reserved_24: bit 24 (1 bit)
 *   Reserved_25: bit 25 (1 bit)
 *   Reserved_26: bit 26 (1 bit)
 *   Reserved_27: bit 27 (1 bit)
 *   Reserved_28: bit 28 (1 bit)
 *   Reserved_29: bit 29 (1 bit)
 *   Reserved_30: bit 30 (1 bit)
 *   Reserved_31: bit 31 (1 bit)
 */
typedef uint32_t SysTick_ControlBits;


/* Register: SysTick_SysTick @ 0xE000E010 */
#define SysTick_SysTick_CTRL (*(volatile SysTick_ControlBits*)(0xE000E010 + 0x00))
#define SysTick_SysTick_LOAD (*(volatile uint32_t*)(0xE000E010 + 0x04))
#define SysTick_SysTick_VAL (*(volatile uint32_t*)(0xE000E010 + 0x08))
#define SysTick_SysTick_CALIB (*(volatile uint32_t const *)(0xE000E010 + 0x0C))


void SysTick_init(void) {
    SysTick_SysTick_CTRL = (SysTick_SysTick_CTRL & ~(1 << 0)) | ((false ? 1 : 0) << 0);
    SysTick_SysTick_LOAD = 16000 - 1;
    SysTick_SysTick_VAL = 0;
    SysTick_SysTick_CTRL = (SysTick_SysTick_CTRL & ~(1 << 2)) | ((true ? 1 : 0) << 2);
    SysTick_SysTick_CTRL = (SysTick_SysTick_CTRL & ~(1 << 1)) | ((true ? 1 : 0) << 1);
    SysTick_SysTick_CTRL = (SysTick_SysTick_CTRL & ~(1 << 0)) | ((true ? 1 : 0) << 0);
}

/* Scope: RCC */

/* Bitmap: RCC_AHB1Peripherals */
/* Fields:
 *   GPIOAEN: bit 0 (1 bit)
 *   GPIOBEN: bit 1 (1 bit)
 *   GPIOCEN: bit 2 (1 bit)
 *   GPIODEN: bit 3 (1 bit)
 *   GPIOEEN: bit 4 (1 bit)
 *   GPIOFEN: bit 5 (1 bit)
 *   GPIOGEN: bit 6 (1 bit)
 *   GPIOHEN: bit 7 (1 bit)
 *   Reserved_8: bit 8 (1 bit)
 *   Reserved_9: bit 9 (1 bit)
 *   Reserved_10: bit 10 (1 bit)
 *   Reserved_11: bit 11 (1 bit)
 *   CRCEN: bit 12 (1 bit)
 *   Reserved_13: bit 13 (1 bit)
 *   Reserved_14: bit 14 (1 bit)
 *   Reserved_15: bit 15 (1 bit)
 *   Reserved_16: bit 16 (1 bit)
 *   Reserved_17: bit 17 (1 bit)
 *   Reserved_18: bit 18 (1 bit)
 *   Reserved_19: bit 19 (1 bit)
 *   Reserved_20: bit 20 (1 bit)
 *   DMA1EN: bit 21 (1 bit)
 *   DMA2EN: bit 22 (1 bit)
 *   Reserved_23: bit 23 (1 bit)
 *   Reserved_24: bit 24 (1 bit)
 *   Reserved_25: bit 25 (1 bit)
 *   Reserved_26: bit 26 (1 bit)
 *   Reserved_27: bit 27 (1 bit)
 *   Reserved_28: bit 28 (1 bit)
 *   Reserved_29: bit 29 (1 bit)
 *   Reserved_30: bit 30 (1 bit)
 *   Reserved_31: bit 31 (1 bit)
 */
typedef uint32_t RCC_AHB1Peripherals;


/* Register: RCC_RCC @ 0x40023800 */
#define RCC_RCC_AHB1ENR (*(volatile RCC_AHB1Peripherals*)(0x40023800 + 0x30))


/* Scope: STM32F446 */

typedef enum {
    STM32F446_GPIOMode_INPUT = 0,
    STM32F446_GPIOMode_OUTPUT = 1,
    STM32F446_GPIOMode_ALTERNATE = 2,
    STM32F446_GPIOMode_ANALOG = 3
} STM32F446_GPIOMode;


typedef enum {
    STM32F446_GPIOOutputType_PUSH_PULL = 0,
    STM32F446_GPIOOutputType_OPEN_DRAIN = 1
} STM32F446_GPIOOutputType;


typedef enum {
    STM32F446_GPIOSpeed_LOW = 0,
    STM32F446_GPIOSpeed_MEDIUM = 1,
    STM32F446_GPIOSpeed_HIGH = 2,
    STM32F446_GPIOSpeed_VERY_HIGH = 3
} STM32F446_GPIOSpeed;


typedef enum {
    STM32F446_GPIOPull_NO_PULL = 0,
    STM32F446_GPIOPull_PULL_UP = 1,
    STM32F446_GPIOPull_PULL_DOWN = 2,
    STM32F446_GPIOPull_RESERVED = 3
} STM32F446_GPIOPull;


/* Bitmap: STM32F446_GPIOAPins */
/* Fields:
 *   PA0: bit 0 (1 bit)
 *   PA1: bit 1 (1 bit)
 *   PA2: bit 2 (1 bit)
 *   PA3: bit 3 (1 bit)
 *   PA4: bit 4 (1 bit)
 *   LD2: bit 5 (1 bit)
 *   PA6: bit 6 (1 bit)
 *   PA7: bit 7 (1 bit)
 *   PA8: bit 8 (1 bit)
 *   PA9: bit 9 (1 bit)
 *   PA10: bit 10 (1 bit)
 *   PA11: bit 11 (1 bit)
 *   PA12: bit 12 (1 bit)
 *   PA13: bit 13 (1 bit)
 *   PA14: bit 14 (1 bit)
 *   PA15: bit 15 (1 bit)
 *   PA0_RESET: bit 16 (1 bit)
 *   PA1_RESET: bit 17 (1 bit)
 *   PA2_RESET: bit 18 (1 bit)
 *   PA3_RESET: bit 19 (1 bit)
 *   PA4_RESET: bit 20 (1 bit)
 *   LD2_RESET: bit 21 (1 bit)
 *   PA6_RESET: bit 22 (1 bit)
 *   PA7_RESET: bit 23 (1 bit)
 *   PA8_RESET: bit 24 (1 bit)
 *   PA9_RESET: bit 25 (1 bit)
 *   PA10_RESET: bit 26 (1 bit)
 *   PA11_RESET: bit 27 (1 bit)
 *   PA12_RESET: bit 28 (1 bit)
 *   PA13_RESET: bit 29 (1 bit)
 *   PA14_RESET: bit 30 (1 bit)
 *   PA15_RESET: bit 31 (1 bit)
 */
typedef uint32_t STM32F446_GPIOAPins;


/* Register: STM32F446_GPIOA @ 0x40020000 */
#define STM32F446_GPIOA_ModeRegister (*(volatile uint32_t*)(0x40020000 + 0x00))
#define STM32F446_GPIOA_OutputTypeRegister (*(volatile STM32F446_GPIOAPins*)(0x40020000 + 0x04))
#define STM32F446_GPIOA_OutputSpeedRegister (*(volatile uint32_t*)(0x40020000 + 0x08))
#define STM32F446_GPIOA_PullUpDownRegister (*(volatile uint32_t*)(0x40020000 + 0x0C))
#define STM32F446_GPIOA_InputData (*(volatile STM32F446_GPIOAPins const *)(0x40020000 + 0x10))
#define STM32F446_GPIOA_OutputData (*(volatile STM32F446_GPIOAPins*)(0x40020000 + 0x14))
#define STM32F446_GPIOA_BitSetReset (*(volatile STM32F446_GPIOAPins*)(0x40020000 + 0x18))
#define STM32F446_GPIOA_LockRegister (*(volatile STM32F446_GPIOAPins*)(0x40020000 + 0x1C))
#define STM32F446_GPIOA_AlternateFunctionLow (*(volatile uint32_t*)(0x40020000 + 0x20))
#define STM32F446_GPIOA_AlternateFunctionHigh (*(volatile uint32_t*)(0x40020000 + 0x24))


/* Scope: LED */

void LED_init(void) {
    RCC_RCC_AHB1ENR_GPIOAEN = true;
    STM32F446_GPIOA_ModeRegister[10, 2] = (uint8_t)STM32F446_GPIOMode_OUTPUT;
    STM32F446_GPIOA_OutputTypeRegister_LD2 = (bool)STM32F446_GPIOOutputType_PUSH_PULL;
    STM32F446_GPIOA_OutputSpeedRegister[10, 2] = (uint8_t)STM32F446_GPIOSpeed_MEDIUM;
    STM32F446_GPIOA_PullUpDownRegister[10, 2] = (uint8_t)STM32F446_GPIOPull_NO_PULL;
}

void LED_on(void) {
    STM32F446_GPIOA_BitSetReset_LD2 = true;
}

void LED_off(void) {
    STM32F446_GPIOA_BitSetReset_LD2_RESET = true;
}

void LED_toggle(void) {
    if (((STM32F446_GPIOA_OutputData >> 5) & 1)) {
        LED_off();
    } else {
        LED_on();
    }
}

bool LED_isOn(void) {
    return ((STM32F446_GPIOA_OutputData >> 5) & 1);
}

const uint32_t BLINK_DELAY_MS = 2000;

volatile uint32_t tick_count = 0;

void SysTick_Handler(void) {
    {
        uint32_t __primask = __get_PRIMASK();
        __disable_irq();
        tick_count = cnx_clamp_add_u32(tick_count, 1);
        __set_PRIMASK(__primask);
    }
}

void setup(void) {
    SysTick_init();
    LED_init();
}

void loop(void) {
    if (tick_count >= BLINK_DELAY_MS) {
        LED_toggle();
        tick_count = 0;
    }
}

int main(void) {
    setup();
    while (true) {
        loop();
    }
    return 0;
}
