/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 32.1-hex-literals
// test-execution
// Tests: Unsuffixed hex literals with type inference
// Validates that 0x... literals work correctly when type is inferred from context
int main(void) {
    uint8_t byte = 0xFF;
    if (byte != 255) return 1;
    uint16_t word = 0xABCD;
    if (word != 43981) return 2;
    uint32_t dword = 0xDEADBEEF;
    if (dword != 3735928559) return 3;
    uint8_t lower = 0xff;
    if (lower != 255) return 4;
    uint8_t upper = 0XFF;
    if (upper != 255) return 5;
    uint32_t mixed = 0xAbCdEf;
    if (mixed != 11259375) return 6;
    uint8_t zero = 0x0;
    if (zero != 0) return 7;
    uint8_t single = 0xA;
    if (single != 10) return 8;
    uint8_t two = 0x1F;
    if (two != 31) return 9;
    uint16_t sum = 48;
    if (sum != 48) return 10;
    uint16_t diff = 240;
    if (diff != 240) return 11;
    uint32_t product = 256;
    if (product != 256) return 12;
    uint8_t andResult = 0xFF & 0x0F;
    if (andResult != 15) return 13;
    uint8_t orResult = 0xF0 | 0x0F;
    if (orResult != 255) return 14;
    uint8_t bytes[4] = {0x48, 0x65, 0x6C, 0x6C};
    if (bytes[0] != 72) return 15;
    if (bytes[1] != 101) return 16;
    if (bytes[2] != 108) return 17;
    if (bytes[3] != 108) return 18;
    uint8_t val = 0x42;
    if (val != 0x42) return 19;
    if (0x10 >= 0x20) return 20;
    if (0xFF <= 0xFE) return 21;
    return 0;
}
