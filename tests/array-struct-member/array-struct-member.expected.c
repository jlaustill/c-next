/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int32_t cnx_clamp_add_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a + b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

// Regression test: Array-of-struct member assignment
// Verifies arr[i].field generates correctly (was generating arr.field[i])
typedef struct Point {
    int32_t x;
    int32_t y;
} Point;

typedef struct Sensor {
    uint16_t id;
    int32_t value;
    bool active;
} Sensor;

// Test arrays
Point points[3] = {0};

Sensor sensors[4] = {0};

// Test function to verify array-of-struct assignment
int main(void) {
    int32_t errors = 0;
    points[0].x = 10;
    points[0].y = 20;
    points[1].x = 30;
    points[1].y = 40;
    points[2].x = 50;
    points[2].y = 60;
    if (points[0].x != 10) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[0].y != 20) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[1].x != 30) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[1].y != 40) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[2].x != 50) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[2].y != 60) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    sensors[0].id = 100;
    sensors[0].value = 1000;
    sensors[0].active = true;
    sensors[1].id = 200;
    sensors[1].value = 2000;
    sensors[1].active = false;
    if (sensors[0].id != 100) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[0].value != 1000) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[0].active != true) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[1].id != 200) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[1].value != 2000) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[1].active != false) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    int32_t idx = 2;
    sensors[idx].id = 300;
    sensors[idx].value = 3000;
    if (sensors[2].id != 300) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (sensors[2].value != 3000) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    points[0].x += 5;
    points[1].y -= 10;
    if (points[0].x != 15) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (points[1].y != 30) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    points[2].x = points[0].x + points[1].x;
    if (points[2].x != 45) {
        errors = cnx_clamp_add_i32(errors, 1);
    }
    if (errors > 0) {
        return 1;
    }
    return 0;
}
