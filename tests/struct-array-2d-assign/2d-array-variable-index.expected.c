/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-execution
// Tests: 2D struct array access with variable indices
// Coverage: Runtime index computation, nested loops
typedef struct Pixel {
    uint8_t r;
    uint8_t g;
    uint8_t b;
} Pixel;

Pixel image[4][4] = {0};

int main(void) {
    uint32_t y = 0U;
    while (y < 4) {
        uint32_t x = 0U;
        while (x < 4) {
            image[y][x].r = y * 64U;
            image[y][x].g = x * 64U;
            image[y][x].b = (y + x) * 32U;
            x = cnx_clamp_add_u32(x, 1U);
        }
        y = cnx_clamp_add_u32(y, 1U);
    }
    uint32_t testY = 2U;
    uint32_t testX = 3U;
    if (image[testY][testX].r != 128) return 1;
    if (image[testY][testX].g != 192) return 2;
    if (image[testY][testX].b != 160) return 3;
    if (image[0][0].r != 0) return 4;
    if (image[0][0].g != 0) return 5;
    if (image[0][0].b != 0) return 6;
    if (image[3][3].r != 192) return 7;
    if (image[3][3].g != 192) return 8;
    if (image[3][3].b != 192) return 9;
    uint32_t baseRow = 1U;
    uint32_t offset = 1U;
    if (image[baseRow + offset][offset].r != 128) return 10;
    uint32_t targetRow = 2U;
    uint32_t targetCol = 2U;
    image[targetRow][targetCol].r = 255U;
    image[targetRow][targetCol].g = 255U;
    image[targetRow][targetCol].b = 255U;
    if (image[2][2].r != 255) return 11;
    if (image[2][2].g != 255) return 12;
    if (image[2][2].b != 255) return 13;
    return 0;
}
