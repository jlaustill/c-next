/**
 * Generated by C-Next Transpiler from: clamp-u64.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)(UINT64_MAX - a)) return UINT64_MAX;
    uint64_t result;
    if (__builtin_add_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

static inline uint64_t cnx_clamp_sub_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)a) return 0;
    uint64_t result;
    if (__builtin_sub_overflow(a, (uint64_t)b, &result)) return 0;
    return result;
}

// test-execution
// Tests: clamp modifier for u64 type (0 to 18446744073709551615)
// Validates overflow clamps to UINT64_MAX, underflow clamps to 0
// ADR-044: Per-variable overflow semantics
int main(void) {
    uint64_t val = 18446744073709551610ULL;
    val = cnx_clamp_add_u64(val, 10ULL);
    if (val != 18446744073709551615) return 1;
    val = 18446744073709551615ULL;
    val = cnx_clamp_add_u64(val, 1ULL);
    if (val != 18446744073709551615) return 2;
    val = 18446744073709551600ULL;
    val = cnx_clamp_add_u64(val, 100ULL);
    if (val != 18446744073709551615) return 3;
    val = 18446744073709551610ULL;
    val = cnx_clamp_add_u64(val, 10ULL);
    if (val != 18446744073709551615) return 4;
    val = cnx_clamp_add_u64(val, 1000ULL);
    if (val != 18446744073709551615) return 5;
    val = 50ULL;
    val = cnx_clamp_sub_u64(val, 100ULL);
    if (val != 0) return 6;
    val = 0ULL;
    val = cnx_clamp_sub_u64(val, 1ULL);
    if (val != 0) return 7;
    val = 1000ULL;
    val = cnx_clamp_sub_u64(val, 1000000ULL);
    if (val != 0) return 8;
    val = 5ULL;
    val = cnx_clamp_sub_u64(val, 10ULL);
    if (val != 0) return 9;
    val = cnx_clamp_sub_u64(val, 100ULL);
    if (val != 0) return 10;
    val = 1000000000000ULL;
    val = cnx_clamp_add_u64(val, 500000000000ULL);
    if (val != 1500000000000) return 11;
    val = 1000000000000ULL;
    val = cnx_clamp_sub_u64(val, 300000000000ULL);
    if (val != 700000000000) return 12;
    val = 0ULL;
    val = cnx_clamp_add_u64(val, 9223372036854775807ULL);
    if (val != 9223372036854775807) return 13;
    val = 100000ULL;
    val = cnx_clamp_sub_u64(val, 100000ULL);
    if (val != 0) return 14;
    val = 100ULL;
    val = cnx_clamp_add_u64(val, 50ULL);
    if (val != 150) return 15;
    val = 100ULL;
    val = cnx_clamp_sub_u64(val, 50ULL);
    if (val != 50) return 16;
    val = 9999999999ULL;
    val = cnx_clamp_add_u64(val, 0ULL);
    if (val != 9999999999) return 17;
    val = 9999999999ULL;
    val = cnx_clamp_sub_u64(val, 0ULL);
    if (val != 9999999999) return 18;
    val = 18446744073709551610ULL;
    val = cnx_clamp_add_u64(val, 10ULL);
    if (val != 18446744073709551615) return 19;
    val = cnx_clamp_sub_u64(val, 18446744073709551615ULL);
    if (val != 0) return 20;
    val = cnx_clamp_add_u64(val, 1000ULL);
    if (val != 1000) return 21;
    return 0;
}
