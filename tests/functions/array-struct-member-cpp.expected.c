/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// tests/functions/array-struct-member-cpp.test.cnx
/* test-execution */
// Tests: Issue #256 - array-of-structs member passing in C++ mode
// When passing arr[i].member to u8 parameter, must generate temp variable
// because bool* and enum* cannot convert to uint8_t* in C++
#include "array-struct-member-cpp.h"

#include <stdint.h>
#include <stdbool.h>

// Array of external C structs with bool/enum members
SensorReading sensors[4] = {0};

uint32_t process(uint32_t* crc, uint8_t* byte) {
    return (*crc) ^ (*byte);
}

uint32_t testArrayStructMembers(void) {
    uint32_t crc = 0;
    sensors[0].active = true;
    sensors[0].sensorType = SENSOR_PRESSURE;
    sensors[0].status = STATUS_ON;
    sensors[0].value = 42;
    uint8_t _cnx_tmp_0 = static_cast<uint8_t>(sensors[0].active);
    crc = process(&crc, &_cnx_tmp_0);
    uint8_t _cnx_tmp_1 = static_cast<uint8_t>(sensors[0].sensorType);
    crc = process(&crc, &_cnx_tmp_1);
    uint8_t _cnx_tmp_2 = static_cast<uint8_t>(sensors[0].status);
    crc = process(&crc, &_cnx_tmp_2);
    uint8_t _cnx_tmp_3 = static_cast<uint8_t>(sensors[0].value);
    crc = process(&crc, &_cnx_tmp_3);
    return crc;
}

uint32_t testMultipleIndices(void) {
    uint32_t crc = 0;
    sensors[1].active = false;
    sensors[1].sensorType = SENSOR_HUMIDITY;
    sensors[2].status = STATUS_ERROR;
    sensors[3].value = 100;
    uint8_t _cnx_tmp_4 = static_cast<uint8_t>(sensors[1].active);
    crc = process(&crc, &_cnx_tmp_4);
    uint8_t _cnx_tmp_5 = static_cast<uint8_t>(sensors[1].sensorType);
    crc = process(&crc, &_cnx_tmp_5);
    uint8_t _cnx_tmp_6 = static_cast<uint8_t>(sensors[2].status);
    crc = process(&crc, &_cnx_tmp_6);
    uint8_t _cnx_tmp_7 = static_cast<uint8_t>(sensors[3].value);
    crc = process(&crc, &_cnx_tmp_7);
    return crc;
}

int main(void) {
    uint32_t result1 = testArrayStructMembers();
    if (result1 != 43) return 1;
    uint32_t result2 = testMultipleIndices();
    if (result2 != 100) return 2;
    return 0;
}
