/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-050: Platform-portable IRQ wrappers for critical sections
#if defined(__arm__) || defined(__ARM_ARCH)
// ARM platforms (including ARM Arduino like Teensy 4.x, Due, Zero)
// Provide inline assembly PRIMASK access to avoid CMSIS header dependencies
__attribute__((always_inline)) static inline uint32_t __cnx_get_PRIMASK(void) {
    uint32_t result;
    __asm volatile ("MRS %0, primask" : "=r" (result));
    return result;
}
__attribute__((always_inline)) static inline void __cnx_set_PRIMASK(uint32_t mask) {
    __asm volatile ("MSR primask, %0" :: "r" (mask) : "memory");
}
#if defined(ARDUINO)
static inline void __cnx_disable_irq(void) { noInterrupts(); }
#else
__attribute__((always_inline)) static inline void __cnx_disable_irq(void) {
    __asm volatile ("cpsid i" ::: "memory");
}
#endif
#elif defined(__AVR__)
// AVR Arduino: use SREG for interrupt state
// Note: Uses PRIMASK naming for API consistency across platforms (AVR has no PRIMASK)
// Returns uint8_t which is implicitly widened to uint32_t at call sites - this is intentional
static inline uint8_t __cnx_get_PRIMASK(void) { return SREG; }
static inline void __cnx_set_PRIMASK(uint8_t mask) { SREG = mask; }
static inline void __cnx_disable_irq(void) { cli(); }
#else
// Fallback: assume CMSIS is available
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }
#endif

// test-c-only
// test-execution
// Issue #269: Pass-by-value for small unmodified parameters
// Tests that unmodified small primitive types pass by value,
// while modified parameters still pass by pointer.
// --- Unmodified parameters: should pass by value ---
uint8_t getLowByte(uint16_t value) {
    return ((value) & 0xFFU);
}

uint8_t getHighByte(uint16_t value) {
    return ((value >> 8) & 0xFFU);
}

uint32_t addTwo(uint32_t a, uint32_t b) {
    return a + b;
}

bool invert(bool flag) {
    return !flag;
}

// --- Modified parameters: should still pass by pointer ---
void increment(uint32_t* x) {
    (*x) = (*x) + 1;
}

void doubleValue(uint16_t* val) {
    (*val) = (*val) * 2;
}

// --- Transitively modified: passed to function that modifies ---
// These should pass by pointer because increment() modifies its param
void incrementWrapper(uint32_t* x) {
    increment(x);
}

// --- Mixed: some params modified, some not ---
uint32_t addAndIncrement(uint32_t* a, uint32_t b) {
    (*a) = (*a) + 1;
    return (*a) + b;
}

// --- Modification in switch statement (Issue #269 bug fix) ---
// Parameters modified inside switch cases must still pass by pointer
void modifyInSwitch(uint32_t* x, uint32_t mode) {
    switch (mode) {
        case 1: {
            (*x) = (*x) + 10;
            break;
        }
        case 2: {
            (*x) = (*x) + 20;
            break;
        }
        default: {
            (*x) = (*x) + 1;
            break;
        }
    }
}

// --- Modification in critical section (ADR-050) ---
void modifyInCritical(uint32_t* x) {
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        (*x) = (*x) * 2;
        __cnx_set_PRIMASK(__primask);
    }
}

// --- Main test ---
int main(void) {
    uint16_t testVal = 0x1234;
    uint8_t low = getLowByte(testVal);
    if (low != 0x34) return 1;
    uint8_t high = getHighByte(testVal);
    if (high != 0x12) return 2;
    uint32_t sum = addTwo(100, 200);
    if (sum != 300) return 3;
    bool result = invert(true);
    if (result != false) return 4;
    result = invert(false);
    if (result != true) return 5;
    uint32_t counter = 10;
    increment(&counter);
    if (counter != 11) return 6;
    uint16_t doubled = 50;
    doubleValue(&doubled);
    if (doubled != 100) return 7;
    uint32_t wrapped = 20;
    incrementWrapper(&wrapped);
    if (wrapped != 21) return 8;
    uint32_t mixedA = 5;
    uint32_t mixedB = 10;
    uint32_t mixedResult = addAndIncrement(&mixedA, mixedB);
    if (mixedResult != 16) return 9;
    if (mixedA != 6) return 10;
    uint32_t switchVal = 100;
    modifyInSwitch(&switchVal, 1);
    if (switchVal != 110) return 11;
    switchVal = 100;
    modifyInSwitch(&switchVal, 2);
    if (switchVal != 120) return 12;
    switchVal = 100;
    modifyInSwitch(&switchVal, 99);
    if (switchVal != 101) return 13;
    uint32_t criticalVal = 50;
    modifyInCritical(&criticalVal);
    if (criticalVal != 100) return 14;
    return 0;
}
