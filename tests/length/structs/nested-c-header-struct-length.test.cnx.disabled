// NOTE: test-execution disabled due to Issue #196 (.length code generation bug)
// Tests: .length property on nested C header struct members
// Regression test for issue #103 - .length returns 0 for nested struct member access

#include "../../include/NestedTestConfig.h"

u32 main() {
    OuterConfig config;

    // LEVEL 1: Direct struct field (baseline - already works)
    if (config.directField.length != 32) return 1;

    // LEVEL 2: Nested struct field (BUG #103 - was returning 0)
    if (config.single.byteField.length != 8) return 2;
    if (config.single.shortField.length != 16) return 3;
    if (config.single.intField.length != 32) return 4;
    if (config.single.floatField.length != 32) return 5;

    // LEVEL 3: Array of nested structs - constant index (BUG #103)
    if (config.array[0].byteField.length != 8) return 6;
    if (config.array[0].shortField.length != 16) return 7;
    if (config.array[1].intField.length != 32) return 8;
    if (config.array[2].floatField.length != 32) return 9;

    // LEVEL 3: Array of nested structs - loop variable index (BUG #103)
    for (u32 i <- 0; i < 4; i +<- 1) {
        if (config.array[i].intField.length != 32) return 10;
        if (config.array[i].byteField.length != 8) return 11;
    }

    // Test 3-level deep nesting (DeepConfig -> OuterConfig -> InnerConfig)
    DeepConfig deep;
    if (deep.outer.single.byteField.length != 8) return 12;
    if (deep.outer.single.shortField.length != 16) return 13;
    if (deep.outer.single.intField.length != 32) return 14;
    if (deep.outer.single.floatField.length != 32) return 15;
    if (deep.outer.array[0].shortField.length != 16) return 16;
    if (deep.outer.directField.length != 32) return 17;
    if (deep.timestamp.length != 64) return 18;

    // Test byte calculation from nested struct (common serialization pattern)
    u32 bytes <- config.single.intField.length / 8;
    if (bytes != 4) return 19;

    // Test expression with multiple nested .length values
    u32 total <- config.single.byteField.length + config.single.shortField.length;
    if (total != 24) return 20;  // 8 + 16 = 24

    // Test nested .length in loop bounds (edge case)
    u32 bitSum <- 0;
    for (u32 j <- 0; j < 4; j +<- 1) {
        bitSum +<- config.array[j].byteField.length;
    }
    if (bitSum != 32) return 21;  // 4 * 8 = 32

    return 0;  // All tests passed
}
