/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

// test-execution
// Regression test: .length in control flow expressions
// Tests if, while, for, and switch with .length property
typedef struct {
    uint32_t header;
    uint16_t length;
    uint8_t type;
    uint64_t payload;
} Packet;

int main(void) {
    Packet pkt = {0};
    pkt.header = 0xDEADBEEF;
    pkt.length = 256;
    pkt.type = 1;
    pkt.payload = 0x123456789ABCDEF;
    if (32 != 32) {
        return 1;
    }
    if (32 != 32) return 2;
    if (8 != 8) return 3;
    uint32_t counter = 0;
    uint32_t maxBits = 32;
    while ((counter < maxBits) != false) {
        counter = cnx_clamp_add_u32(counter, 8);
    }
    if (counter != 32) return 4;
    uint32_t totalBits = 0;
    for (uint32_t i = 0; (i < 4) != false; i += 1) {
        totalBits = cnx_clamp_add_u32(totalBits, 8);
    }
    if (totalBits != 32) return 5;
    uint32_t fieldSize = ((32 > 16) != false) ? 4 : 2;
    if (fieldSize != 4) return 6;
    uint32_t headerBytes = 32 / 8;
    if (headerBytes != 4) {
        return 7;
    }
    if (32 != 32) {
        return 8;
    }
    if (64 != 64) {
        return 9;
    }
    return 0;
}
