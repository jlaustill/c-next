# MISRA C:2012 Rule 10.3 Narrowing Cast Compliance

## Overview

Fix 106 MISRA C:2012 Rule 10.3 violations in generated C code by adding explicit casts at assignment sites where C's type promotion rules create implicit narrowing.

**Issue:** #845
**Date:** 2026-02-23
**Status:** Approved

## Problem Statement

C-Next enforces type safety at the source level — narrowing conversions require explicit bit extraction (`value[0, 8]`). However, the _generated C code_ uses expressions that have wider types in C's type system:

```c-next
u8 x <- value[0, 8];  // C-Next: valid, explicit bit extraction
```

Generates:

```c
uint8_t x = ((value >> 0U) & 0xFFU);  // MISRA 10.3 violation!
```

The expression `((value >> 0U) & 0xFFU)` has type `uint32_t` in C (bitwise ops preserve source type). MISRA sees this as `uint32_t → uint8_t` narrowing without explicit cast.

### Why This Happens

1. **C's integer promotion**: Operations on `char`, `short`, `uint8_t`, `uint16_t` promote to `int`
2. **Bitwise operations**: Preserve the wider operand's type
3. **Character literals**: `'A'` has type `int` in C (not `char`)
4. **Compound assignments**: `x &= y` expands to `x = x & y` with intermediate `int` type

### Violation Breakdown (106 total)

| Pattern                   | Count | Example                              |
| ------------------------- | ----- | ------------------------------------ |
| Bit extraction → uint8_t  | 15    | `uint8_t x = ((val >> n) & 0xFF)`    |
| Bit extraction → uint16_t | 6     | `uint16_t x = ((val >> n) & 0xFFFF)` |
| Bool from bit extraction  | 18    | `bool x = ((flags >> n) & 1)`        |
| Char literal → uint8_t    | 28    | `uint8_t x = 'A'`                    |
| Float/int conversions     | 11    | Implicit float↔int                   |
| Compound assignment       | 10    | `int16_t x &= 0xAAAA`                |
| Negative literals         | 5     | `int32_t x = -2147483648`            |
| Other                     | 13    | Mixed patterns                       |

## Solution: Centralized Cast Insertion

### Architecture

Create `NarrowingCastHelper` to wrap expressions with casts at assignment sites:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Assignment Sites                              │
├─────────────────────────────────────────────────────────────────┤
│  VariableDeclarationGenerator  →  NarrowingCastHelper.wrap()    │
│  AssignmentHandlers            →  NarrowingCastHelper.wrap()    │
│  CompoundAssignmentHandler     →  NarrowingCastHelper.wrap()    │
│  BitRangeHelper                →  (unchanged - returns expr)    │
│  BitmapHandlers                →  (unchanged - returns expr)    │
└─────────────────────────────────────────────────────────────────┘
```

### New Component: `NarrowingCastHelper`

Location: `src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts`

```typescript
class NarrowingCastHelper {
  /**
   * Wrap expression with cast if source→target is narrowing or different category.
   * MISRA C:2012 Rule 10.3 compliance for generated C code.
   */
  static wrap(expr: string, sourceType: string, targetType: string): string {
    if (!NarrowingCastHelper.needsCast(sourceType, targetType)) {
      return expr;
    }

    // Bool target: use comparison instead of cast (MISRA 10.5)
    if (targetType === "bool") {
      return `(${expr} != 0U)`;
    }

    // Otherwise: add explicit cast
    const cType = TYPE_MAP[targetType] ?? targetType;
    return CppModeHelper.cast(cType, expr);
  }

  /** Check if cast is needed (different essential type or narrowing) */
  static needsCast(sourceType: string, targetType: string): boolean;

  /** Get the expression type from bit operations */
  static getBitExpressionType(baseType: string, width: number): string;
}
```

### Integration Points (6 locations)

| Location                       | Pattern                | Change                              |
| ------------------------------ | ---------------------- | ----------------------------------- |
| `VariableDeclarationGenerator` | `u8 x <- value[0,8]`   | Wrap RHS with cast to declared type |
| `AssignmentHandlers`           | `x <- value[0,8]`      | Wrap RHS with cast to target type   |
| `CompoundAssignmentHandler`    | `x &= mask`            | Expand to `x = (T)(x & mask)`       |
| `BitRangeHelper`               | `((v >> n) & mask)`    | Pass target type, helper wraps      |
| `BitmapHandlers`               | `flags.Running` → bool | Wrap with `!= 0U` comparison        |
| `LiteralGenerator`             | `'A'` → uint8_t        | Wrap char literals with cast        |

### Generated Output Examples

**Before:**

```c
uint8_t lowByte = ((value >> 0U) & 0xFFU);
bool isRunning = ((flags >> 0) & 1);
uint8_t ch = 'A';
andVal &= 0xAAAA;
```

**After:**

```c
uint8_t lowByte = (uint8_t)((value >> 0U) & 0xFFU);
bool isRunning = (((flags >> 0) & 1) != 0U);
uint8_t ch = (uint8_t)'A';
andVal = (int16_t)(andVal & 0xAAAA);
```

**C++ Mode:**

```cpp
uint8_t lowByte = static_cast<uint8_t>((value >> 0U) & 0xFFU);
bool isRunning = (((flags >> 0) & 1) != 0U);
uint8_t ch = static_cast<uint8_t>('A');
andVal = static_cast<int16_t>(andVal & 0xAAAA);
```

## Type Detection Strategy

### Bit Extraction Expressions

| Source Variable Type | Expression Type in C | Reason              |
| -------------------- | -------------------- | ------------------- |
| `u32`, `i32`         | Same as source       | No promotion needed |
| `u16`, `i16`         | `int`                | Integer promotion   |
| `u8`, `i8`           | `int`                | Integer promotion   |

### Bool Assignments

MISRA 10.5 discourages casting to `bool`. Use explicit comparison instead:

- `(expr != 0U)` for unsigned expressions
- `(expr != 0)` for signed expressions

### Character Literals

In C, `'A'` has type `int`. When assigned to `uint8_t`, wrap with cast:

- `(uint8_t)'A'`
- `(uint8_t)'\n'`

## Edge Cases

| Scenario                                      | Handling                                       |
| --------------------------------------------- | ---------------------------------------------- |
| Nested bit extraction `value[0,8][0,4]`       | Each level gets cast to intermediate type      |
| Chained member access `obj.field.bits[0,8]`   | Cast applied at final assignment               |
| Ternary with mixed types `cond ? a[0,8] : b`  | Cast wraps entire ternary if needed            |
| Float bit extraction `f32Val[0,8]`            | Already uses union pattern, add cast to target |
| Array element assignment `arr[i] <- val[0,8]` | Cast based on array element type               |

## Testing Strategy

### Unit Tests

New file: `src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

- Test `needsCast()` for all type combinations
- Test `wrap()` output for C and C++ modes
- Test bool comparison generation
- Test char literal handling

### Integration Tests

Update expected output files (~26 files):

- `tests/basics/bit-indexing.expected.c`
- `tests/bitmap/*.expected.c`
- `tests/literals/char-*.expected.c`
- `tests/compound-assign/*.expected.c`
- And corresponding `.expected.cpp` files

### MISRA Validation

```bash
# Before: 106 violations
npm run validate:c 2>&1 | grep -c "misra-c2012-10.3"

# After: 0 violations
npm run validate:c 2>&1 | grep -c "misra-c2012-10.3"
```

## Documentation Updates

### ADR-024 Addition

Add new section: **"Generated C Code MISRA Compliance"**

Content:

- C-Next enforces type safety at source level
- Generated C expressions have C's promoted types
- Explicit casts added to satisfy MISRA 10.3
- Bool assignments use `!= 0U` comparison (MISRA 10.5)

## Success Criteria

1. `npm run validate:c | grep "misra-c2012-10.3"` returns 0 matches
2. All existing tests pass (with updated expected files)
3. Both C and C++ modes generate correct casts
4. ADR-024 updated with generated code compliance section
5. Unit test coverage for `NarrowingCastHelper` meets 80% threshold

## Files to Create/Modify

### New Files

- `src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts`
- `src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

### Modified Files

- `src/transpiler/output/codegen/generators/VariableDeclarationGenerator.ts`
- `src/transpiler/output/codegen/assignment/handlers/*.ts` (as needed)
- `src/transpiler/output/codegen/helpers/BitRangeHelper.ts`
- `docs/decisions/adr-024-type-casting.md`
- ~26 test expected files

## References

- [MISRA C:2012 Rule 10.3](https://www.codeant.ai/blogs/misra-c-2012-rules-examples-pdf) - Narrowing conversions
- [MISRA C:2012 Rule 10.5](https://www.codeant.ai/blogs/misra-c-2012-rules-examples-pdf) - Bool casts
- Issue #915 - Prior art for MISRA cast handling (bitwise NOT)
- ADR-024 - Type Casting design decisions
