/**
 * Header Generator
 * Generates C header (.h) files from C-Next source
 */

import ISymbol from "../types/ISymbol";
import ESymbolKind from "../types/ESymbolKind";
import ESourceLanguage from "../types/ESourceLanguage";
import SymbolTable from "../symbols/SymbolTable";
import IHeaderOptions from "./types/IHeaderOptions";

/**
 * Maps C-Next types to C types
 */
const TYPE_MAP: Record<string, string> = {
  u8: "uint8_t",
  u16: "uint16_t",
  u32: "uint32_t",
  u64: "uint64_t",
  i8: "int8_t",
  i16: "int16_t",
  i32: "int32_t",
  i64: "int64_t",
  f32: "float",
  f64: "double",
  bool: "bool",
  void: "void",
  ISR: "ISR", // ADR-040: Interrupt Service Routine function pointer
};

/**
 * Generates C header files from symbol information
 */
class HeaderGenerator {
  /**
   * Generate a header file from symbols
   */
  generate(
    symbols: ISymbol[],
    filename: string,
    options: IHeaderOptions = {},
  ): string {
    const lines: string[] = [];
    const guard = this.makeGuard(filename, options.guardPrefix);

    // Header guard
    lines.push(`#ifndef ${guard}`);
    lines.push(`#define ${guard}`);
    lines.push("");

    // Header comment
    lines.push("/**");
    lines.push(" * Generated by C-Next Transpiler");
    lines.push(" * Header file for cross-language interoperability");
    lines.push(" */");
    lines.push("");

    // System includes
    if (options.includeSystemHeaders !== false) {
      lines.push("#include <stdint.h>");
      lines.push("#include <stdbool.h>");
      lines.push("");
    }

    // C++ compatibility
    lines.push("#ifdef __cplusplus");
    lines.push('extern "C" {');
    lines.push("#endif");
    lines.push("");

    // Filter symbols
    const exportedSymbols = options.exportedOnly
      ? symbols.filter((s) => s.isExported)
      : symbols;

    // Group symbols by kind
    const structs = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Struct,
    );
    const classes = exportedSymbols.filter((s) => s.kind === ESymbolKind.Class);
    const functions = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Function,
    );
    const variables = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Variable,
    );
    const enums = exportedSymbols.filter((s) => s.kind === ESymbolKind.Enum);
    const types = exportedSymbols.filter((s) => s.kind === ESymbolKind.Type);

    // Issue #121: Collect external type dependencies from function signatures
    const localStructNames = new Set(structs.map((s) => s.name));
    const localEnumNames = new Set(enums.map((s) => s.name));
    const localTypeNames = new Set(types.map((s) => s.name));
    const externalTypes = this.collectExternalTypes(
      functions,
      variables,
      localStructNames,
      localEnumNames,
      localTypeNames,
    );

    // Emit forward declarations for external types
    if (externalTypes.size > 0) {
      lines.push(
        "/* External type dependencies - include appropriate headers */",
      );
      for (const typeName of externalTypes) {
        lines.push(`struct ${typeName};`);
      }
      lines.push("");
    }

    // Forward declarations for structs
    if (structs.length > 0 || classes.length > 0) {
      lines.push("/* Forward declarations */");
      for (const sym of structs) {
        lines.push(`typedef struct ${sym.name} ${sym.name};`);
      }
      for (const sym of classes) {
        // Classes become typedefs to structs
        lines.push(`typedef struct ${sym.name} ${sym.name};`);
      }
      lines.push("");
    }

    // Enum declarations
    if (enums.length > 0) {
      lines.push("/* Enumerations */");
      for (const sym of enums) {
        // For now, just forward declare - full definition would require enum values
        lines.push(`/* Enum: ${sym.name} (see implementation for values) */`);
      }
      lines.push("");
    }

    // Type aliases
    if (types.length > 0) {
      lines.push("/* Type aliases */");
      for (const sym of types) {
        if (sym.type) {
          const cType = this.mapType(sym.type);
          lines.push(`typedef ${cType} ${sym.name};`);
        }
      }
      lines.push("");
    }

    // Extern variable declarations
    if (variables.length > 0) {
      lines.push("/* External variables */");
      for (const sym of variables) {
        const cType = sym.type ? this.mapType(sym.type) : "int";
        lines.push(`extern ${cType} ${sym.name};`);
      }
      lines.push("");
    }

    // Function prototypes
    if (functions.length > 0) {
      lines.push("/* Function prototypes */");
      for (const sym of functions) {
        const proto = this.generateFunctionPrototype(sym);
        if (proto) {
          lines.push(proto);
        }
      }
      lines.push("");
    }

    // C++ compatibility end
    lines.push("#ifdef __cplusplus");
    lines.push("}");
    lines.push("#endif");
    lines.push("");

    // End header guard
    lines.push(`#endif /* ${guard} */`);
    lines.push("");

    return lines.join("\n");
  }

  /**
   * Generate header from a symbol table, filtering by source file
   */
  generateFromSymbolTable(
    symbolTable: SymbolTable,
    sourceFile: string,
    options: IHeaderOptions = {},
  ): string {
    const symbols = symbolTable.getSymbolsByFile(sourceFile);
    const basename = sourceFile.replace(/\.[^.]+$/, "");
    const headerName = `${basename}.h`;

    return this.generate(symbols, headerName, options);
  }

  /**
   * Generate header for all C-Next symbols in the symbol table
   */
  generateCNextHeader(
    symbolTable: SymbolTable,
    filename: string,
    options: IHeaderOptions = {},
  ): string {
    const symbols = symbolTable.getSymbolsByLanguage(ESourceLanguage.CNext);
    return this.generate(symbols, filename, options);
  }

  /**
   * Create an include guard macro from filename
   */
  private makeGuard(filename: string, prefix?: string): string {
    // Remove path and extension
    const base = filename.replace(/^.*[\\/]/, "").replace(/\.[^.]+$/, "");

    // Convert to uppercase and replace non-alphanumeric with underscore
    const sanitized = base.toUpperCase().replace(/[^A-Z0-9]/g, "_");

    if (prefix) {
      return `${prefix.toUpperCase()}_${sanitized}_H`;
    }

    return `${sanitized}_H`;
  }

  /**
   * Map a C-Next type to C type
   */
  private mapType(type: string): string {
    // Check direct mapping first
    if (TYPE_MAP[type]) {
      return TYPE_MAP[type];
    }

    // Handle pointer types
    if (type.endsWith("*")) {
      const baseType = type.slice(0, -1).trim();
      return `${this.mapType(baseType)}*`;
    }

    // Handle array types (simplified)
    const arrayMatch = type.match(/^(\w+)\[(\d*)\]$/);
    if (arrayMatch) {
      const baseType = this.mapType(arrayMatch[1]);
      const size = arrayMatch[2] || "";
      return `${baseType}[${size}]`;
    }

    // User-defined types pass through
    return type;
  }

  /**
   * Generate a function prototype from symbol info
   * Handles all parameter edge cases per ADR-006, ADR-029, and ADR-040
   */
  private generateFunctionPrototype(sym: ISymbol): string | null {
    // Map return type from C-Next to C
    const returnType = sym.type ? this.mapType(sym.type) : "void";

    // Build parameter list with proper C semantics
    let params = "void"; // Default for no parameters

    if (sym.parameters && sym.parameters.length > 0) {
      const translatedParams = sym.parameters.map((p) => {
        const baseType = this.mapType(p.type);
        const constMod = p.isConst ? "const " : "";

        // Handle array parameters (pass naturally as pointers per C semantics)
        if (p.isArray && p.arrayDimensions) {
          const dims = p.arrayDimensions.map((d) => `[${d}]`).join("");
          // Special case: string[] becomes char* name[]
          if (p.type === "string") {
            return `${constMod}char* ${p.name}${dims}`;
          }
          return `${constMod}${baseType} ${p.name}${dims}`;
        }

        // ADR-040: ISR is already a function pointer typedef, no pointer needed
        if (p.type === "ISR") {
          return `${constMod}${baseType} ${p.name}`;
        }

        // Float types (f32, f64) use standard C pass-by-value semantics
        if (p.type === "f32" || p.type === "f64") {
          return `${constMod}${baseType} ${p.name}`;
        }

        // ADR-006: Pass by reference - non-array, non-float params become pointers
        // This applies to primitives (u32, i16, etc.) and struct types
        return `${constMod}${baseType}* ${p.name}`;
      });
      params = translatedParams.join(", ");
    }

    return `${returnType} ${sym.name}(${params});`;
  }

  /**
   * Issue #121: Collect external type dependencies from function signatures and variables
   * Returns types that are:
   * - Not primitive types (not in TYPE_MAP)
   * - Not locally defined structs, enums, or type aliases
   */
  private collectExternalTypes(
    functions: ISymbol[],
    variables: ISymbol[],
    localStructs: Set<string>,
    localEnums: Set<string>,
    localTypes: Set<string>,
  ): Set<string> {
    const externalTypes = new Set<string>();

    const isExternalType = (typeName: string): boolean => {
      // Skip if it's a primitive type
      if (TYPE_MAP[typeName]) {
        return false;
      }

      // Skip if locally defined
      if (localStructs.has(typeName)) {
        return false;
      }
      if (localEnums.has(typeName)) {
        return false;
      }
      if (localTypes.has(typeName)) {
        return false;
      }

      // Skip pointer markers and array brackets
      if (typeName === "" || typeName === "*") {
        return false;
      }

      return true;
    };

    const extractBaseType = (type: string): string => {
      // Remove pointer suffix
      let baseType = type.replace(/\*+$/, "").trim();

      // Remove array brackets
      baseType = baseType.replace(/\[\d*\]$/, "").trim();

      // Handle const prefix
      baseType = baseType.replace(/^const\s+/, "").trim();

      return baseType;
    };

    // Check function return types and parameters
    for (const fn of functions) {
      // Check return type
      if (fn.type) {
        const baseType = extractBaseType(fn.type);
        if (isExternalType(baseType)) {
          externalTypes.add(baseType);
        }
      }

      // Check parameter types
      if (fn.parameters) {
        for (const param of fn.parameters) {
          if (param.type) {
            const baseType = extractBaseType(param.type);
            if (isExternalType(baseType)) {
              externalTypes.add(baseType);
            }
          }
        }
      }
    }

    // Check variable types
    for (const v of variables) {
      if (v.type) {
        const baseType = extractBaseType(v.type);
        if (isExternalType(baseType)) {
          externalTypes.add(baseType);
        }
      }
    }

    return externalTypes;
  }
}

export default HeaderGenerator;
