/**
 * Generated by C-Next Transpiler from: enum-type-aware-resolution.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// test-coverage: issue-452-type-aware-resolution
// Tests: Type-aware enum member resolution with overlapping names
// When multiple enums have the same member name, the assignment target's type
// determines which enum to use.
typedef enum {
    Color_RED = 0,
    Color_GREEN = 1,
    Color_BLUE = 2
} Color;

typedef enum {
    Status_RED = 10,
    Status_YELLOW = 20,
    Status_GREEN = 30
} Status;

typedef struct ColorConfig {
    Color color;
} ColorConfig;

typedef struct StatusConfig {
    Status status;
} StatusConfig;

void setColorRed(ColorConfig* cfg) {
    cfg->color = Color_RED;
}

void setStatusRed(StatusConfig* cfg) {
    cfg->status = Status_RED;
}

int main(void) {
    ColorConfig colorCfg = (ColorConfig){ .color = Color_BLUE };
    setColorRed(&colorCfg);
    if ((uint32_t)colorCfg.color != 0) return 1;
    StatusConfig statusCfg = (StatusConfig){ .status = Status_YELLOW };
    setStatusRed(&statusCfg);
    if ((uint32_t)statusCfg.status != 10) return 2;
    colorCfg.color = Color_GREEN;
    if ((uint32_t)colorCfg.color != 1) return 3;
    statusCfg.status = Status_GREEN;
    if ((uint32_t)statusCfg.status != 30) return 4;
    colorCfg.color = Color_BLUE;
    if ((uint32_t)colorCfg.color != 2) return 5;
    statusCfg.status = Status_YELLOW;
    if ((uint32_t)statusCfg.status != 20) return 6;
    return 0;
}
