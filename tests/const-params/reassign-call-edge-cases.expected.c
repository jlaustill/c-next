/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "reassign-call-edge-cases.test.h"

#include <stdint.h>
#include <stdbool.h>

// ADR-050: Platform-portable IRQ wrappers for critical sections
#if defined(__arm__) || defined(__ARM_ARCH)
// ARM platforms (including ARM Arduino like Teensy 4.x, Due, Zero)
// Provide inline assembly PRIMASK access to avoid CMSIS header dependencies
__attribute__((always_inline)) static inline uint32_t __cnx_get_PRIMASK(void) {
    uint32_t result;
    __asm volatile ("MRS %0, primask" : "=r" (result));
    return result;
}
__attribute__((always_inline)) static inline void __cnx_set_PRIMASK(uint32_t mask) {
    __asm volatile ("MSR primask, %0" :: "r" (mask) : "memory");
}
#if defined(ARDUINO)
static inline void __cnx_disable_irq(void) { noInterrupts(); }
#else
__attribute__((always_inline)) static inline void __cnx_disable_irq(void) {
    __asm volatile ("cpsid i" ::: "memory");
}
#endif
#elif defined(__AVR__)
// AVR Arduino: use SREG for interrupt state
// Note: Uses PRIMASK naming for API consistency across platforms (AVR has no PRIMASK)
// Returns uint8_t which is implicitly widened to uint32_t at call sites - this is intentional
static inline uint8_t __cnx_get_PRIMASK(void) { return SREG; }
static inline void __cnx_set_PRIMASK(uint8_t mask) { SREG = mask; }
static inline void __cnx_disable_irq(void) { cli(); }
#else
// Fallback: assume CMSIS is available
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }
#endif

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-c-only
// test-execution
// Tests: Issue #565 edge cases - comprehensive coverage for reassignment const inference
// Covers: nested conditionals, switch, do-while, critical, compound assignments,
// this.method calls, nested calls, multiple params
/* Scope: Handler */

uint8_t Handler_setValue(Config* cfg, uint32_t val) {
    cfg->value = val;
    return 0;
}

uint8_t Handler_setSecond(uint32_t dummy, Config* cfg) {
    cfg->value = 999U;
    return 0;
}

uint32_t Handler_getValue(const Config* cfg) {
    return cfg->value;
}

uint8_t Handler_wrapSetValue(Config* cfg, uint32_t val) {
    return Handler_setValue(cfg, val);
}

// Edge case 1: Nested conditionals
void handleNestedIf(Config* config) {
    uint8_t errorCode = 0U;
    bool a = true;
    bool b = true;
    if (a) {
        if (b) {
            errorCode = Handler_setValue(config, 10U);
        }
    }
}

// Edge case 2: Switch statement
void handleSwitch(Config* config) {
    uint8_t errorCode = 0U;
    uint32_t choice = 1U;
    switch (choice) {
        case 0: {
            errorCode = 0U;
            break;
        }
        case 1: {
            errorCode = Handler_setValue(config, 20U);
            break;
        }
        default: {
            errorCode = 2U;
            break;
        }
    }
}

// Edge case 3: do-while loop
void handleDoWhile(Config* config) {
    uint8_t errorCode = 0U;
    uint32_t count = 0U;
    do {
        errorCode = Handler_setValue(config, 30U);
        count = count + 1U;
    } while (count < 1);
}

// Edge case 4: Critical block
void handleCritical(Config* config) {
    uint8_t errorCode = 0U;
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        errorCode = Handler_setValue(config, 40U);
        __cnx_set_PRIMASK(__primask);
    }
}

// Edge case 5: this.method() call in reassignment (within a scope)
/* Scope: Processor */

static uint8_t Processor_helper(Config* cfg) {
    cfg->value = 50U;
    return 0;
}

void Processor_process(Config* config) {
    uint8_t errorCode = 0U;
    errorCode = Processor_helper(config);
}

// Edge case 6: Second parameter is modified (not first)
void handleSecondParam(Config* config) {
    uint8_t errorCode = 0U;
    uint32_t dummy = 0U;
    errorCode = Handler_setSecond(dummy, config);
}

// Edge case 7: Nested function call in RHS
void handleNestedCall(const Config* config) {
    uint32_t result = 0U;
    result = Handler_getValue(config);
}

// Edge case 8: Transitive modification via wrapper
void handleTransitive(Config* config) {
    uint8_t errorCode = 0U;
    errorCode = Handler_wrapSetValue(config, 60U);
}

// Edge case 9: Multiple reassignments, only one modifies
void handleMultipleReassign(Config* config) {
    uint8_t errorCode = 0U;
    uint32_t readVal = 0U;
    readVal = Handler_getValue(config);
    errorCode = Handler_setValue(config, 70U);
}

// Edge case 10: Compound assignment with modifying call
// Note: compound assignment like a +<- b is equivalent to a <- a + b
// The RHS here is an expression, so we need to ensure it's walked
void handleCompoundAssign(const Config* config) {
    uint32_t total = 0U;
    total = cnx_clamp_add_u32(total, Handler_getValue(config));
}

// Edge case 11: Compound assignment where the call modifies
void handleCompoundModify(Config* config) {
    uint32_t total = 0U;
    uint8_t code = Handler_setValue(config, 80U);
    total = cnx_clamp_add_u32(total, code);
}

// Edge case 12: Bare function call (expression statement, no assignment)
void handleBareCall(Config* config) {
    Handler_setValue(config, 90U);
}

// Edge case 13: Bare function call that only reads (should be const)
void handleBareReadOnly(const Config* config) {
    Handler_getValue(config);
}

int main(void) {
    Config cfg = {0};
    cfg.value = 0U;
    handleNestedIf(&cfg);
    if (cfg.value != 10) return 1;
    cfg.value = 0U;
    handleSwitch(&cfg);
    if (cfg.value != 20) return 2;
    cfg.value = 0U;
    handleDoWhile(&cfg);
    if (cfg.value != 30) return 3;
    cfg.value = 0U;
    handleCritical(&cfg);
    if (cfg.value != 40) return 4;
    cfg.value = 0U;
    Processor_process(&cfg);
    if (cfg.value != 50) return 5;
    cfg.value = 0U;
    handleSecondParam(&cfg);
    if (cfg.value != 999) return 6;
    cfg.value = 123U;
    handleNestedCall(&cfg);
    if (cfg.value != 123) return 7;
    cfg.value = 0U;
    handleTransitive(&cfg);
    if (cfg.value != 60) return 8;
    cfg.value = 0U;
    handleMultipleReassign(&cfg);
    if (cfg.value != 70) return 9;
    cfg.value = 100U;
    handleCompoundAssign(&cfg);
    if (cfg.value != 100) return 10;
    cfg.value = 0U;
    handleCompoundModify(&cfg);
    if (cfg.value != 80) return 11;
    cfg.value = 0U;
    handleBareCall(&cfg);
    if (cfg.value != 90) return 12;
    cfg.value = 123U;
    handleBareReadOnly(&cfg);
    if (cfg.value != 123) return 13;
    return 0;
}
