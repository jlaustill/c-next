/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: u32 array parameter assignment
// Coverage: Sized u32 array parameters
// Sized array parameter
void writeU32(uint32_t arr[4], uint32_t index, uint32_t value) {
    arr[index] = value;
}

// Read and return from array parameter
uint32_t readU32(const uint32_t arr[4], uint32_t index) {
    return arr[index];
}

// Modify array element with compound assignment
void incrementU32(uint32_t arr[4], uint32_t index) {
    arr[index] += 1U;
}

// Copy between arrays
void copyU32(const uint32_t src[4], uint32_t dst[4], uint32_t index) {
    dst[index] = src[index];
}

int main(void) {
    uint32_t buffer[4] = {0};
    buffer[0] = 0U;
    buffer[1] = 0U;
    buffer[2] = 0U;
    buffer[3] = 0U;
    writeU32(buffer, 0, 100000);
    if (buffer[0] != 100000) return 1;
    writeU32(buffer, 3, 999999);
    if (buffer[3] != 999999) return 2;
    writeU32(buffer, 1, 500000);
    if (buffer[1] != 500000) return 3;
    uint32_t result = readU32(buffer, 0U);
    if (result != 100000) return 4;
    result = readU32(buffer, 3U);
    if (result != 999999) return 5;
    buffer[2] = 50U;
    incrementU32(buffer, 2);
    if (buffer[2] != 51) return 6;
    incrementU32(buffer, 2);
    incrementU32(buffer, 2);
    if (buffer[2] != 53) return 7;
    uint32_t source[4] = {0};
    uint32_t dest[4] = {0};
    source[0] = 12345U;
    source[1] = 67890U;
    dest[0] = 0U;
    dest[1] = 0U;
    copyU32(source, dest, 0);
    if (dest[0] != 12345) return 8;
    copyU32(source, dest, 1);
    if (dest[1] != 67890) return 9;
    return 0;
}
