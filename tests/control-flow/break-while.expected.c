/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

/* test-execution */
// Tests: break statement in while loop
// Validates: early loop termination with break in while loops
int main(void) {
    uint32_t count = 0;
    uint32_t i = 0;
    while (i < 100) {
        count = cnx_clamp_add_u32(count, 1);
        if (i == 9) {
            break;
        }
        i = cnx_clamp_add_u32(i, 1);
    }
    if (count != 10) return 1;
    if (i != 9) return 2;
    uint32_t sum = 0;
    uint32_t j = 0;
    while (true) {
        if (j >= 5) {
            break;
        }
        sum = cnx_clamp_add_u32(sum, j);
        j = cnx_clamp_add_u32(j, 1);
    }
    if (sum != 10) return 3;
    if (j != 5) return 4;
    uint32_t k = 0;
    uint32_t found = 0;
    while (k < 1000) {
        if (k == 42) {
            found = 1;
            break;
        }
        k = cnx_clamp_add_u32(k, 1);
    }
    if (found != 1) return 5;
    if (k != 42) return 6;
    uint32_t m = 0;
    uint32_t total = 0;
    while (m < 5) {
        total = cnx_clamp_add_u32(total, m);
        m = cnx_clamp_add_u32(m, 1);
        if (m == 999) {
            break;
        }
    }
    if (total != 10) return 7;
    if (m != 5) return 8;
    return 0;
}
