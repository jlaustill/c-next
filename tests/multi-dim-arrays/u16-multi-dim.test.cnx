// test-execution
// Tests: multi-dimensional u16 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: sensor data, medium-range counters, port numbers
u16[4] matrix2d[8];

u16[2] cube3d[3][4];

u32 main() {
    // 2D array: Write operations
    matrix2d[0][0] <- 1000;
    matrix2d[0][7] <- 20000;
    matrix2d[1][3] <- 30000;
    matrix2d[3][7] <- 65535;

    // 2D array: Read and verify
    if (matrix2d[0][0] != 1000) return 1;
    if (matrix2d[0][7] != 20000) return 2;
    if (matrix2d[1][3] != 30000) return 3;
    if (matrix2d[3][7] != 65535) return 4;

    // 3D array: Write operations
    cube3d[0][0][0] <- 100;
    cube3d[0][0][3] <- 500;
    cube3d[0][2][3] <- 1000;
    cube3d[1][0][0] <- 10000;
    cube3d[1][2][3] <- 50000;

    // 3D array: Read and verify
    if (cube3d[0][0][0] != 100) return 5;
    if (cube3d[0][0][3] != 500) return 6;
    if (cube3d[0][2][3] != 1000) return 7;
    if (cube3d[1][0][0] != 10000) return 8;
    if (cube3d[1][2][3] != 50000) return 9;

   
// Test .length property at each dimension
    // 2D array dimensions
    if (matrix2d.length != 4) return 10; // First dimension
    if (matrix2d[0].length != 8) return 11; // Second dimension
    if (matrix2d[0][0].length != 16) return 12; // Element bit width

    // 3D array dimensions
    if (cube3d.length != 2) return 13; // First dimension
    if (cube3d[0].length != 3) return 14; // Second dimension
    if (cube3d[0][0].length != 4) return 15; // Third dimension
    if (cube3d[0][0][0].length != 16) return 16; // Element bit width

    // Nested loop iteration - populate 2D array
    for (u32 i <- 0; i < 4; i +<- 1) {
        for (u32 j <- 0; j < 8; j +<- 1) {
            matrix2d[i][j] <- i * 100 + j;
        }
    }

    // Verify populated values
    if (matrix2d[0][0] != 0) return 17;
    if (matrix2d[0][7] != 7) return 18;
    if (matrix2d[1][3] != 103) return 19;
    if (matrix2d[3][7] != 307) return 20;

    // Nested loop iteration - populate and sum 3D array
    u32 sum <- 0;
    for (u32 i <- 0; i < 2; i +<- 1) {
        for (u32 j <- 0; j < 3; j +<- 1) {
            for (u32 k <- 0; k < 4; k +<- 1) {
                cube3d[i][j][k] <- i * 100 + j * 10 + k;
                sum +<- cube3d[i][j][k];
            }
        }
    }

    // Verify sum: 6+46+86+406+446+486 = 1476
    if (sum != 1476) return 21;

   
// Test modification after initialization
    matrix2d[2][4] <- 60000;
    if (matrix2d[2][4] != 60000) return 22;

   
// Test boundary access
    matrix2d[matrix2d.length - 1][matrix2d[0].length - 1] <- 555;
    if (matrix2d[3][7] != 555) return 23;

   
// Test u16 specific edge cases
    u16[3] testArray[2];

    // Initialize all elements first
    for (u32 ti <- 0; ti < 3; ti +<- 1) {
        for (u32 tj <- 0; tj < 2; tj +<- 1) {
            testArray[ti][tj] <- 0;
        }
    }
    testArray[0][0] <- 0; // Min value
    testArray[0][1] <- 65535; // Max value
    testArray[1][0] <- 32768; // Mid value
    testArray[2][1] <- 1000; // Small value

    if (testArray[0][0] != 0) return 24;
    if (testArray[0][1] != 65535) return 25;
    if (testArray[1][0] != 32768) return 26;
    if (testArray[2][1] != 1000) return 27;

   
// Test 2D array with port numbers pattern
    u16[3] ports[3];

    // Initialize all elements first
    for (u32 pi <- 0; pi < 3; pi +<- 1) {
        for (u32 pj <- 0; pj < 3; pj +<- 1) {
            ports[pi][pj] <- 0;
        }
    }
    ports[0][0] <- 80; // HTTP
    ports[0][1] <- 443; // HTTPS
    ports[1][0] <- 22; // SSH
    ports[1][1] <- 3306; // MySQL
    ports[2][0] <- 5432; // PostgreSQL
    ports[2][1] <- 8080; // Alt HTTP

    if (ports[0][0] != 80) return 28;
    if (ports[0][1] != 443) return 29;
    if (ports[1][0] != 22) return 30;
    if (ports[1][1] != 3306) return 31;
    if (ports[2][0] != 5432) return 32;
    if (ports[2][1] != 8080) return 33;

   
// Test large value calculations
    u16[2] data[2];

    // Initialize all elements first
    for (u32 di <- 0; di < 2; di +<- 1) {
        for (u32 dj <- 0; dj < 2; dj +<- 1) {
            data[di][dj] <- 0;
        }
    }
    data[0][0] <- 30000;
    data[0][1] <- 35000;
    u32 largeSum <- data[0][0] + data[0][1];
    if (largeSum != 65000) return 34;

    return 0;
}
