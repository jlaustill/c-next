/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-coverage: 1.1-u64-in-ternary-expression */
/* test-execution */
// ADR-022: Ternary operator test for u64
// Tests: ternary with u64 in conditions and branches
uint64_t getMax(uint64_t* a, uint64_t* b) {
    return ((*a) > (*b)) ? (*a) : (*b);
}

uint64_t getMin(uint64_t* a, uint64_t* b) {
    return ((*a) < (*b)) ? (*a) : (*b);
}

uint32_t main(void) {
    uint64_t a = 1000;
    uint64_t b = 2000;
    uint64_t c = 3000;
    uint64_t d = 500;
    if (getMax(&a, &b) != 2000) {
        return 1;
    }
    if (getMax(&c, &d) != 3000) {
        return 2;
    }
    if (getMin(&a, &b) != 1000) {
        return 3;
    }
    if (getMin(&c, &d) != 500) {
        return 4;
    }
    uint64_t result = (a > b) ? a : b;
    if (result != 2000) {
        return 5;
    }
    uint64_t large_a = 1000000000000;
    uint64_t large_b = 2000000000000;
    uint64_t large_result = (large_a < large_b) ? large_a : large_b;
    if (large_result != 1000000000000) {
        return 6;
    }
    uint64_t zero = 0;
    uint64_t one = 1;
    uint64_t zero_result = (zero < one) ? zero : one;
    if (zero_result != 0) {
        return 7;
    }
    uint64_t equal_test = (a == 1000) ? 100000 : 200000;
    if (equal_test != 100000) {
        return 8;
    }
    uint64_t very_large_a = 9000000000000000000;
    uint64_t very_large_b = 9000000000000000001;
    uint64_t very_large_result = (very_large_a < very_large_b) ? very_large_a : very_large_b;
    if (very_large_result != 9000000000000000000) {
        return 9;
    }
    return 0;
}
