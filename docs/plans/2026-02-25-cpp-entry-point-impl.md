# C/C++ Entry Point Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enable C/C++ files as transpiler entry points for incremental C-Next adoption.

**Architecture:** Extend the existing `_discoverFromFiles()` flow to accept C/C++ implementation files. When a C/C++ entry point is detected, walk the include tree looking for headers with C-Next generation markers. Extract source `.cnx` paths from markers, then transpile those files using the existing pipeline.

**Tech Stack:** TypeScript, existing IncludeResolver/IncludeDiscovery infrastructure, regex for marker parsing

**Design Doc:** `docs/plans/2026-02-25-cpp-entry-point-design.md`

---

## Task 1: Add Source Path to Generated Header Marker

**Files:**

- Modify: `src/transpiler/output/headers/HeaderGeneratorUtils.ts:253-263`
- Test: `src/transpiler/output/headers/__tests__/HeaderGeneratorUtils.test.ts`

**Step 1: Write the failing test**

In `src/transpiler/output/headers/__tests__/HeaderGeneratorUtils.test.ts`, add:

```typescript
describe("generateHeaderStart", () => {
  it("should include source path in generation comment when provided", () => {
    const lines = HeaderGeneratorUtils.generateHeaderStart("TEST_H", "led.cnx");
    expect(lines.join("\n")).toContain(
      "Generated by C-Next Transpiler from: led.cnx",
    );
  });

  it("should use default comment when no source path provided", () => {
    const lines = HeaderGeneratorUtils.generateHeaderStart("TEST_H");
    expect(lines.join("\n")).toContain("Generated by C-Next Transpiler");
    expect(lines.join("\n")).not.toContain("from:");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm run unit -- src/transpiler/output/headers/__tests__/HeaderGeneratorUtils.test.ts`
Expected: FAIL - signature doesn't accept sourcePath parameter

**Step 3: Update generateHeaderStart signature and implementation**

In `src/transpiler/output/headers/HeaderGeneratorUtils.ts`, change `generateHeaderStart`:

```typescript
/**
 * Generate header guard opening and file comment
 * @param guard - The include guard macro name
 * @param sourcePath - Optional source .cnx file path for marker
 */
static generateHeaderStart(guard: string, sourcePath?: string): string[] {
  const generatedLine = sourcePath
    ? ` * Generated by C-Next Transpiler from: ${sourcePath}`
    : " * Generated by C-Next Transpiler";

  return [
    `#ifndef ${guard}`,
    `#define ${guard}`,
    "",
    "/**",
    generatedLine,
    " * Header file for cross-language interoperability",
    " */",
    "",
  ];
}
```

**Step 4: Run test to verify it passes**

Run: `npm run unit -- src/transpiler/output/headers/__tests__/HeaderGeneratorUtils.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/output/headers/HeaderGeneratorUtils.ts src/transpiler/output/headers/__tests__/HeaderGeneratorUtils.test.ts
git commit -m "feat: add source path to header generation marker"
```

---

## Task 2: Add Source Path to Generated C File Marker

**Files:**

- Modify: `src/transpiler/output/codegen/CodeGenerator.ts:2228-2233`
- Test: `src/transpiler/output/codegen/__tests__/CodeGenerator.test.ts`

**Step 1: Write the failing test**

In `src/transpiler/output/codegen/__tests__/CodeGenerator.test.ts`, find an existing generation test and add:

```typescript
it("should include source path in generation comment", () => {
  const source = `void test() { }`;
  CodeGenState.sourcePath = "led.cnx";
  const { code } = generator.generate(source);
  expect(code).toContain("Generated by C-Next Transpiler from: led.cnx");
});
```

**Step 2: Run test to verify it fails**

Run: `npm run unit -- src/transpiler/output/codegen/__tests__/CodeGenerator.test.ts -t "source path"`
Expected: FAIL - generated code doesn't contain "from: led.cnx"

**Step 3: Update assembleGeneratedOutput**

In `src/transpiler/output/codegen/CodeGenerator.ts`, modify the header comment section:

```typescript
// Add header comment
const sourcePath = CodeGenState.sourcePath;
const generatedLine = sourcePath
  ? ` * Generated by C-Next Transpiler from: ${basename(sourcePath)}`
  : " * Generated by C-Next Transpiler";

output.push(
  "/**",
  generatedLine,
  " * A safer C for embedded systems",
  " */",
  "",
);
```

Note: Add `import { basename } from "node:path";` if not already imported.

**Step 4: Run test to verify it passes**

Run: `npm run unit -- src/transpiler/output/codegen/__tests__/CodeGenerator.test.ts -t "source path"`
Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/output/codegen/CodeGenerator.ts src/transpiler/output/codegen/__tests__/CodeGenerator.test.ts
git commit -m "feat: add source path to C file generation marker"
```

---

## Task 3: Pass Source Path Through Header Generation Pipeline

**Files:**

- Modify: `src/transpiler/output/headers/HeaderGenerator.ts`
- Modify: `src/transpiler/Transpiler.ts` (generateHeaderForFile)

**Step 1: Trace the header generation call path**

The path is: `Transpiler._generateAllHeadersFromPipeline()` -> `generateHeaderForFile()` -> `HeaderGenerator.generate()` -> `HeaderGeneratorUtils.generateHeaderStart()`

**Step 2: Update HeaderGenerator.generate() to accept sourcePath**

Find the `generate()` method signature and add `sourcePath?: string` parameter. Pass it to `HeaderGeneratorUtils.generateHeaderStart()`.

**Step 3: Update generateHeaderForFile in Transpiler.ts**

Pass `basename(file.path)` as the sourcePath to `HeaderGenerator.generate()`.

**Step 4: Run integration tests**

Run: `npm test -- tests/header-generation/`
Expected: All pass (headers now have source path in marker)

**Step 5: Update snapshots if needed**

Run: `npm test -- tests/header-generation/ --update`

**Step 6: Commit**

```bash
git add src/transpiler/output/headers/HeaderGenerator.ts src/transpiler/Transpiler.ts tests/
git commit -m "feat: pass source path through header generation pipeline"
```

---

## Task 4: Create CNextMarkerDetector Utility

**Files:**

- Create: `src/transpiler/data/CNextMarkerDetector.ts`
- Create: `src/transpiler/data/__tests__/CNextMarkerDetector.test.ts`

**Step 1: Write the failing tests**

Create `src/transpiler/data/__tests__/CNextMarkerDetector.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import CNextMarkerDetector from "../CNextMarkerDetector";

describe("CNextMarkerDetector", () => {
  describe("extractSourcePath", () => {
    it("should extract source path from valid marker", () => {
      const content = `/**
 * Generated by C-Next Transpiler from: led.cnx
 * Header file for cross-language interoperability
 */`;
      expect(CNextMarkerDetector.extractSourcePath(content)).toBe("led.cnx");
    });

    it("should return null for header without marker", () => {
      const content = `/**
 * Some other header
 */
#ifndef FOO_H
#define FOO_H`;
      expect(CNextMarkerDetector.extractSourcePath(content)).toBeNull();
    });

    it("should return null for old-style marker without source path", () => {
      const content = `/**
 * Generated by C-Next Transpiler
 * Header file for cross-language interoperability
 */`;
      expect(CNextMarkerDetector.extractSourcePath(content)).toBeNull();
    });

    it("should handle paths with directories", () => {
      const content = `/**
 * Generated by C-Next Transpiler from: ../lib/utils.cnx
 */`;
      expect(CNextMarkerDetector.extractSourcePath(content)).toBe(
        "../lib/utils.cnx",
      );
    });
  });

  describe("isCNextGenerated", () => {
    it("should return true for C-Next generated header", () => {
      const content = `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`;
      expect(CNextMarkerDetector.isCNextGenerated(content)).toBe(true);
    });

    it("should return true for old-style marker", () => {
      const content = `/**
 * Generated by C-Next Transpiler
 */`;
      expect(CNextMarkerDetector.isCNextGenerated(content)).toBe(true);
    });

    it("should return false for non-generated header", () => {
      const content = `#ifndef FOO_H
#define FOO_H`;
      expect(CNextMarkerDetector.isCNextGenerated(content)).toBe(false);
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm run unit -- src/transpiler/data/__tests__/CNextMarkerDetector.test.ts`
Expected: FAIL - module not found

**Step 3: Create CNextMarkerDetector**

Create `src/transpiler/data/CNextMarkerDetector.ts`:

```typescript
/**
 * Detects C-Next generation markers in header files.
 *
 * Used by the C/C++ entry point feature to discover which headers
 * were generated from .cnx source files.
 */
class CNextMarkerDetector {
  /**
   * Regex to extract source path from generation marker.
   * Matches: "Generated by C-Next Transpiler from: <path>"
   */
  private static readonly SOURCE_PATH_REGEX =
    /Generated by C-Next Transpiler from:\s*(\S+)/;

  /**
   * Check if content contains any C-Next generation marker.
   */
  static isCNextGenerated(content: string): boolean {
    return content.includes("Generated by C-Next Transpiler");
  }

  /**
   * Extract the source .cnx path from a C-Next generation marker.
   *
   * @param content - File content (typically first 500 chars is sufficient)
   * @returns The source path (e.g., "led.cnx") or null if no marker found
   */
  static extractSourcePath(content: string): string | null {
    const match = this.SOURCE_PATH_REGEX.exec(content);
    return match ? match[1] : null;
  }
}

export default CNextMarkerDetector;
```

**Step 4: Run test to verify it passes**

Run: `npm run unit -- src/transpiler/data/__tests__/CNextMarkerDetector.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/data/CNextMarkerDetector.ts src/transpiler/data/__tests__/CNextMarkerDetector.test.ts
git commit -m "feat: add CNextMarkerDetector for source path extraction"
```

---

## Task 5: Accept C/C++ Extensions in InputExpansion

**Files:**

- Modify: `src/transpiler/data/InputExpansion.ts`
- Create: `src/transpiler/data/__tests__/InputExpansion.test.ts`

**Step 1: Write the failing tests**

Create `src/transpiler/data/__tests__/InputExpansion.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import InputExpansion from "../InputExpansion";

describe("InputExpansion", () => {
  describe("validateFileExtension", () => {
    it("should accept .cnx files", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/file.cnx"),
      ).not.toThrow();
    });

    it("should accept .cnext files", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/file.cnext"),
      ).not.toThrow();
    });

    it("should accept .c files as entry points", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/main.c"),
      ).not.toThrow();
    });

    it("should accept .cpp files as entry points", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/main.cpp"),
      ).not.toThrow();
    });

    it("should accept .cc files as entry points", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/main.cc"),
      ).not.toThrow();
    });

    it("should reject unknown extensions", () => {
      expect(() =>
        InputExpansion.validateFileExtension("/path/to/file.txt"),
      ).toThrow();
    });
  });

  describe("isCppEntryPoint", () => {
    it("should return true for .c files", () => {
      expect(InputExpansion.isCppEntryPoint("/path/to/main.c")).toBe(true);
    });

    it("should return true for .cpp files", () => {
      expect(InputExpansion.isCppEntryPoint("/path/to/main.cpp")).toBe(true);
    });

    it("should return false for .cnx files", () => {
      expect(InputExpansion.isCppEntryPoint("/path/to/file.cnx")).toBe(false);
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm run unit -- src/transpiler/data/__tests__/InputExpansion.test.ts`
Expected: FAIL - .c files still rejected, isCppEntryPoint doesn't exist

**Step 3: Update InputExpansion**

Replace `src/transpiler/data/InputExpansion.ts`:

```typescript
import { resolve, extname, basename } from "node:path";
import { existsSync, statSync } from "node:fs";

/**
 * Input expansion for C-Next CLI
 *
 * Validates and resolves file paths for compilation.
 */
class InputExpansion {
  /** C/C++ implementation file extensions (for entry point scanning) */
  private static readonly CPP_EXTENSIONS = [
    ".c",
    ".cpp",
    ".cc",
    ".cxx",
    ".c++",
  ];

  /** C-Next source file extensions */
  private static readonly CNEXT_EXTENSIONS = [".cnx", ".cnext"];

  /**
   * Check if a file is a C/C++ entry point (not a .cnx file)
   */
  static isCppEntryPoint(path: string): boolean {
    const ext = extname(path);
    return this.CPP_EXTENSIONS.includes(ext);
  }

  /**
   * Expand inputs (files) to list of .cnx files
   *
   * @param inputs - Array of file paths
   * @returns Array of .cnx file paths
   */
  static expandInputs(inputs: string[]): string[] {
    const files: string[] = [];

    for (const input of inputs) {
      const resolvedPath = resolve(input);

      if (!existsSync(resolvedPath)) {
        throw new Error(`Input not found: ${input}`);
      }

      const stats = statSync(resolvedPath);

      if (stats.isFile()) {
        this.validateFileExtension(resolvedPath);
        files.push(resolvedPath);
      }
    }

    return Array.from(new Set(files));
  }

  /**
   * Validate file extension
   *
   * Accepts: .cnx, .cnext, .c, .cpp, .cc, .cxx, .c++
   *
   * @param path - File path to validate
   * @throws Error if extension is invalid
   */
  static validateFileExtension(path: string): void {
    const ext = extname(path);
    const fileName = basename(path);

    // Accept C-Next source files
    if (this.CNEXT_EXTENSIONS.includes(ext)) {
      return;
    }

    // Accept C/C++ implementation files as entry points
    if (this.CPP_EXTENSIONS.includes(ext)) {
      return;
    }

    throw new Error(
      `Invalid file extension '${ext}' for file '${fileName}'. ` +
        `C-Next accepts .cnx, .cnext, or C/C++ files (.c, .cpp) as entry points.`,
    );
  }
}

export default InputExpansion;
```

**Step 4: Run test to verify it passes**

Run: `npm run unit -- src/transpiler/data/__tests__/InputExpansion.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/data/InputExpansion.ts src/transpiler/data/__tests__/InputExpansion.test.ts
git commit -m "feat: accept C/C++ files as entry points in InputExpansion"
```

---

## Task 6: Create CppEntryPointScanner

**Files:**

- Create: `src/transpiler/data/CppEntryPointScanner.ts`
- Create: `src/transpiler/data/__tests__/CppEntryPointScanner.test.ts`

**Step 1: Write the failing tests**

Create `src/transpiler/data/__tests__/CppEntryPointScanner.test.ts`:

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import CppEntryPointScanner from "../CppEntryPointScanner";
import IFileSystem from "../../types/IFileSystem";

describe("CppEntryPointScanner", () => {
  let mockFs: IFileSystem;
  let files: Map<string, string>;

  beforeEach(() => {
    files = new Map();
    mockFs = {
      readFile: (path: string) => {
        const content = files.get(path);
        if (!content) throw new Error(`File not found: ${path}`);
        return content;
      },
      exists: (path: string) => files.has(path),
      isDirectory: () => false,
      writeFile: () => {},
      mkdir: () => {},
      readdir: () => [],
    };
  });

  describe("scan", () => {
    it("should find .cnx source from header with marker", () => {
      // main.cpp includes led.h which has marker pointing to led.cnx
      files.set("/project/main.cpp", '#include "led.h"\nint main() {}');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */
void led_on(void);`,
      );
      files.set("/project/led.cnx", "scope LED { public void on() {} }");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(1);
      expect(result.cnextSources[0]).toBe("/project/led.cnx");
    });

    it("should return empty when no C-Next markers found", () => {
      files.set("/project/main.cpp", '#include "utils.h"\nint main() {}');
      files.set("/project/utils.h", "void utils_init(void);");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(0);
      expect(result.noCNextFound).toBe(true);
    });

    it("should follow transitive includes through .cnx sources", () => {
      // main.cpp -> middleware.h -> middleware.cnx -> led.h -> led.cnx
      files.set("/project/main.cpp", '#include "middleware.h"');
      files.set(
        "/project/middleware.h",
        `/**
 * Generated by C-Next Transpiler from: middleware.cnx
 */`,
      );
      files.set("/project/middleware.cnx", '#include "led.h"');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      files.set("/project/led.cnx", "scope LED {}");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toContain("/project/middleware.cnx");
      expect(result.cnextSources).toContain("/project/led.cnx");
    });

    it("should report error when marker points to missing .cnx", () => {
      files.set("/project/main.cpp", '#include "led.h"');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      // led.cnx does NOT exist

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toContain("led.cnx");
      expect(result.errors[0]).toContain("led.h");
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm run unit -- src/transpiler/data/__tests__/CppEntryPointScanner.test.ts`
Expected: FAIL - module not found

**Step 3: Create CppEntryPointScanner**

Create `src/transpiler/data/CppEntryPointScanner.ts`:

```typescript
import { dirname, join, resolve } from "node:path";
import IncludeDiscovery from "./IncludeDiscovery";
import CNextMarkerDetector from "./CNextMarkerDetector";
import IFileSystem from "../types/IFileSystem";
import NodeFileSystem from "../NodeFileSystem";

/**
 * Result of scanning a C/C++ entry point for C-Next sources
 */
interface IScanResult {
  /** Absolute paths to discovered .cnx source files */
  cnextSources: string[];
  /** Errors encountered (e.g., marker points to missing file) */
  errors: string[];
  /** Warnings (e.g., unresolved includes) */
  warnings: string[];
  /** True if no C-Next files were found in the include tree */
  noCNextFound: boolean;
}

/**
 * Scans C/C++ entry points to discover C-Next source files.
 *
 * Walks the include tree transitively, looking for headers with
 * C-Next generation markers. When a marker is found, extracts the
 * source .cnx path and continues scanning that file's includes.
 */
class CppEntryPointScanner {
  private readonly fs: IFileSystem;
  private readonly searchPaths: string[];
  private readonly visited = new Set<string>();
  private readonly cnextSources = new Set<string>();
  private readonly errors: string[] = [];
  private readonly warnings: string[] = [];

  constructor(searchPaths: string[], fs: IFileSystem = new NodeFileSystem()) {
    this.searchPaths = searchPaths;
    this.fs = fs;
  }

  /**
   * Scan a C/C++ file for C-Next includes.
   */
  scan(entryPath: string): IScanResult {
    const absolutePath = resolve(entryPath);
    this._scanFile(absolutePath);

    return {
      cnextSources: Array.from(this.cnextSources),
      errors: this.errors,
      warnings: this.warnings,
      noCNextFound: this.cnextSources.size === 0 && this.errors.length === 0,
    };
  }

  /**
   * Scan a single file for includes, recursively processing them.
   */
  private _scanFile(filePath: string): void {
    if (this.visited.has(filePath)) return;
    this.visited.add(filePath);

    let content: string;
    try {
      content = this.fs.readFile(filePath);
    } catch {
      this.warnings.push(`Warning: Could not read ${filePath}`);
      return;
    }

    const includes = IncludeDiscovery.extractIncludesWithInfo(content);
    const fileDir = dirname(filePath);
    const localSearchPaths = [fileDir, ...this.searchPaths];

    for (const includeInfo of includes) {
      this._processInclude(includeInfo, localSearchPaths, filePath);
    }
  }

  /**
   * Process a single include directive.
   */
  private _processInclude(
    includeInfo: { path: string; isLocal: boolean },
    searchPaths: string[],
    fromFile: string,
  ): void {
    const resolved = IncludeDiscovery.resolveInclude(
      includeInfo.path,
      searchPaths,
      this.fs,
    );

    if (!resolved) {
      if (includeInfo.isLocal) {
        this.warnings.push(
          `Warning: #include "${includeInfo.path}" not found (from ${fromFile})`,
        );
      }
      return;
    }

    const absolutePath = resolve(resolved);
    if (this.visited.has(absolutePath)) return;

    // Check if this is a C-Next generated header
    let headerContent: string;
    try {
      headerContent = this.fs.readFile(absolutePath);
    } catch {
      return;
    }

    const sourcePath = CNextMarkerDetector.extractSourcePath(headerContent);
    if (sourcePath) {
      // Found a C-Next marker - resolve the source path
      this._handleCNextMarker(sourcePath, absolutePath);
    } else if (!CNextMarkerDetector.isCNextGenerated(headerContent)) {
      // Regular header - continue scanning its includes
      this._scanFile(absolutePath);
    }
    // Old-style C-Next marker (no source path) - skip recursion
  }

  /**
   * Handle a C-Next generation marker found in a header.
   */
  private _handleCNextMarker(sourcePath: string, headerPath: string): void {
    // Resolve source path relative to header location
    const headerDir = dirname(headerPath);
    const absoluteSourcePath = resolve(join(headerDir, sourcePath));

    if (!this.fs.exists(absoluteSourcePath)) {
      this.errors.push(
        `C-Next source not found: ${sourcePath} (referenced by ${headerPath})`,
      );
      return;
    }

    this.cnextSources.add(absoluteSourcePath);

    // Continue scanning the .cnx file's includes
    this._scanFile(absoluteSourcePath);
  }
}

export default CppEntryPointScanner;
```

**Step 4: Run test to verify it passes**

Run: `npm run unit -- src/transpiler/data/__tests__/CppEntryPointScanner.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/data/CppEntryPointScanner.ts src/transpiler/data/__tests__/CppEntryPointScanner.test.ts
git commit -m "feat: add CppEntryPointScanner for include tree walking"
```

---

## Task 7: Integrate C/C++ Entry Point in Transpiler

**Files:**

- Modify: `src/transpiler/Transpiler.ts`

**Step 1: Add import for new classes**

At the top of `Transpiler.ts`, add:

```typescript
import InputExpansion from "./data/InputExpansion";
import CppEntryPointScanner from "./data/CppEntryPointScanner";
```

**Step 2: Modify \_discoverFromFiles to handle C/C++ entry points**

Replace the `_discoverFromFiles` method:

```typescript
private async _discoverFromFiles(): Promise<IPipelineInput> {
  const entryPath = resolve(this.config.input);

  // Check if this is a C/C++ entry point
  if (InputExpansion.isCppEntryPoint(entryPath)) {
    return this._discoverFromCppEntryPoint(entryPath);
  }

  // Original .cnx entry point logic follows...
  // [keep existing implementation]
}
```

**Step 3: Add \_discoverFromCppEntryPoint method**

Add new method after `_discoverFromFiles`:

```typescript
/**
 * Discover C-Next files from a C/C++ entry point.
 *
 * Scans the include tree for headers with C-Next generation markers,
 * extracts the source .cnx paths, and returns them for transpilation.
 */
private _discoverFromCppEntryPoint(entryPath: string): IPipelineInput {
  const entryDir = dirname(entryPath);
  const searchPaths = IncludeResolver.buildSearchPaths(
    entryDir,
    this.config.includeDirs,
    [],
    undefined,
    this.fs,
  );

  const scanner = new CppEntryPointScanner(searchPaths, this.fs);
  const scanResult = scanner.scan(entryPath);

  // Report errors
  for (const error of scanResult.errors) {
    this.warnings.push(error);
  }
  this.warnings.push(...scanResult.warnings);

  if (scanResult.noCNextFound) {
    return { cnextFiles: [], headerFiles: [], writeOutputToDisk: true };
  }

  // Convert discovered .cnx paths to pipeline files
  const cnextFiles: IDiscoveredFile[] = scanResult.cnextSources.map((path) => ({
    path,
    type: EFileType.CNext,
    extension: ".cnx",
  }));

  // Build dependency graph and process includes for each .cnx file
  const headerSet = new Map<string, IDiscoveredFile>();
  const depGraph = new DependencyGraph();
  const fileByPath = new Map<string, IDiscoveredFile>();
  const cnextBaseNames = new Set(
    cnextFiles.map((f) => basename(f.path).replace(/\.cnx$|\.cnext$/, "")),
  );

  for (const cnxFile of cnextFiles) {
    fileByPath.set(resolve(cnxFile.path), cnxFile);
    this._processFileIncludes(
      cnxFile,
      depGraph,
      cnextFiles,
      cnextBaseNames,
      headerSet,
      fileByPath,
    );
  }

  // Sort files topologically
  const sortedCnextFiles = this._sortFilesByDependency(depGraph, fileByPath);

  // Resolve headers transitively
  const { headers: allHeaders, warnings: headerWarnings } =
    IncludeResolver.resolveHeadersTransitively(
      [...headerSet.values()],
      this.config.includeDirs,
      {
        onDebug: this.config.debugMode
          ? (msg) => console.log(`[DEBUG] ${msg}`)
          : undefined,
        processedPaths: this.state.getProcessedHeadersSet(),
        fs: this.fs,
      },
    );
  this.warnings.push(...headerWarnings);

  // Convert to pipeline files
  const pipelineFiles: IPipelineFile[] = sortedCnextFiles.map((f) => ({
    path: f.path,
    discoveredFile: f,
  }));

  return {
    cnextFiles: pipelineFiles,
    headerFiles: allHeaders,
    writeOutputToDisk: true,
  };
}
```

**Step 4: Run existing tests to verify no regression**

Run: `npm test`
Expected: All existing tests pass

**Step 5: Commit**

```bash
git add src/transpiler/Transpiler.ts
git commit -m "feat: integrate C/C++ entry point discovery in Transpiler"
```

---

## Task 8: Add CLI Output Messages

**Files:**

- Modify: `src/cli/Runner.ts`

**Step 1: Update Runner to show scanning messages**

Find where `transpile()` is called and add console output:

```typescript
// Before transpile() call, check if C/C++ entry point
if (InputExpansion.isCppEntryPoint(config.input)) {
  console.log(`Scanning ${basename(config.input)} for C-Next includes...`);
}

const result = await transpiler.transpile({ kind: "files" });

// After transpile, show appropriate message
if (InputExpansion.isCppEntryPoint(config.input)) {
  if (result.filesProcessed === 0) {
    console.log("No C-Next files found in include tree. To get started:");
    console.log("  1. Create a .cnx file (e.g., led.cnx)");
    console.log("  2. Run: cnext led.cnx");
    console.log("  3. Include the generated header in your C/C++ code");
    console.log(`  4. Re-run: cnext ${basename(config.input)}`);
  } else {
    const fileNames = result.files
      .map((f) => basename(f.sourcePath))
      .join(", ");
    console.log(
      `Found ${result.filesProcessed} C-Next source file(s): ${fileNames}`,
    );
  }
}
```

**Step 2: Run manual test**

Create a test scenario and run:

```bash
mkdir -p /tmp/cnext-test
echo '#include "led.h"' > /tmp/cnext-test/main.cpp
npx tsx src/index.ts /tmp/cnext-test/main.cpp
```

Expected: Shows "No C-Next files found..." message

**Step 3: Commit**

```bash
git add src/cli/Runner.ts
git commit -m "feat: add CLI output messages for C/C++ entry points"
```

---

## Task 9: Create Integration Tests

**Files:**

- Create: `tests/cpp-entry/basic/main.test.cpp`
- Create: `tests/cpp-entry/basic/led.cnx`
- Create: `tests/cpp-entry/basic/led.expected.h`
- Create: `tests/cpp-entry/basic/led.expected.c`

**Step 1: Create test directory structure**

```bash
mkdir -p tests/cpp-entry/basic
mkdir -p tests/cpp-entry/transitive
mkdir -p tests/cpp-entry/no-cnx
```

**Step 2: Create basic test case**

`tests/cpp-entry/basic/main.test.cpp`:

```cpp
// test-cpp-entry
#include "led.h"

int main() {
    LED_on();
    return 0;
}
```

`tests/cpp-entry/basic/led.cnx`:

```c-next
scope LED {
    public void on() {
        // LED on logic
    }
}
```

**Step 3: Generate expected files**

Run: `npx tsx src/index.ts tests/cpp-entry/basic/led.cnx`
Then copy generated files to expected:

```bash
cp tests/cpp-entry/basic/led.c tests/cpp-entry/basic/led.expected.c
cp tests/cpp-entry/basic/led.h tests/cpp-entry/basic/led.expected.h
```

**Step 4: Update test framework to support cpp-entry tests**

The test framework needs to recognize `// test-cpp-entry` marker and run differently.

**Step 5: Run integration test**

Run: `npm test -- tests/cpp-entry/basic/`
Expected: PASS

**Step 6: Commit**

```bash
git add tests/cpp-entry/
git commit -m "test: add cpp-entry integration tests"
```

---

## Task 10: Create Transitive Include Test

**Files:**

- Create: `tests/cpp-entry/transitive/main.test.cpp`
- Create: `tests/cpp-entry/transitive/middleware.cnx`
- Create: `tests/cpp-entry/transitive/led.cnx`
- Create expected files

**Step 1: Create transitive test case**

This tests the scenario: `main.cpp` -> `middleware.h` -> `middleware.cnx` -> `led.h` -> `led.cnx`

`tests/cpp-entry/transitive/main.test.cpp`:

```cpp
// test-cpp-entry
#include "middleware.h"

int main() {
    Middleware_init();
    return 0;
}
```

`tests/cpp-entry/transitive/middleware.cnx`:

```c-next
#include "led.h"

scope Middleware {
    public void init() {
        LED_on();
    }
}
```

`tests/cpp-entry/transitive/led.cnx`:

```c-next
scope LED {
    public void on() { }
}
```

**Step 2: Generate expected files**

First transpile led.cnx, then middleware.cnx:

```bash
npx tsx src/index.ts tests/cpp-entry/transitive/led.cnx
npx tsx src/index.ts tests/cpp-entry/transitive/middleware.cnx
```

Copy to expected files.

**Step 3: Run test**

Run: `npm test -- tests/cpp-entry/transitive/`
Expected: PASS

**Step 4: Commit**

```bash
git add tests/cpp-entry/transitive/
git commit -m "test: add transitive cpp-entry test"
```

---

## Task 11: Update Documentation

**Files:**

- Modify: `README.md`
- Modify: `docs/learn-cnext-in-y-minutes.md` (if it exists)

**Step 1: Add incremental adoption section to README**

Add under a "Getting Started" or "Incremental Adoption" section:

````markdown
## Incremental Adoption

C-Next supports gradual migration from existing C/C++ codebases. You can convert files one at a time:

1. **Convert a leaf file** to C-Next:
   ```bash
   cnext led.cnx    # Generates led.h and led.c
   ```
````

2. **Include the generated header** in your existing code:

   ```cpp
   // main.cpp
   #include "led.h"
   ```

3. **Run the transpiler on your entry point**:
   ```bash
   cnext main.cpp   # Discovers and re-transpiles all C-Next includes
   ```

The transpiler automatically discovers C-Next files by looking for generation markers in included headers, then follows the include tree transitively.

````

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add incremental adoption guide"
````

---

## Task 12: Final Verification

**Step 1: Run all tests**

```bash
npm run test:all
```

Expected: All tests pass

**Step 2: Run manual end-to-end test**

Create a complete test scenario:

```bash
mkdir -p /tmp/cnext-e2e

cat > /tmp/cnext-e2e/led.cnx << 'EOF'
scope LED {
    public void on() { }
    public void off() { }
}
EOF

cat > /tmp/cnext-e2e/main.cpp << 'EOF'
#include "led.h"
int main() {
    LED_on();
    LED_off();
    return 0;
}
EOF
```

Step 1: Initial transpile

```bash
npx tsx src/index.ts /tmp/cnext-e2e/led.cnx
```

Verify header has marker:

```bash
head -5 /tmp/cnext-e2e/led.h
# Should show: Generated by C-Next Transpiler from: led.cnx
```

Step 2: Run from C++ entry point:

```bash
npx tsx src/index.ts /tmp/cnext-e2e/main.cpp
# Should show: Scanning main.cpp for C-Next includes...
# Should show: Found 1 C-Next source file(s): led.cnx
```

**Step 3: Commit final state**

```bash
git add -A
git commit -m "feat: complete C/C++ entry point support for incremental adoption"
```
