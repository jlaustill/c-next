// Issue #294: Cross-file scope function calls
// Note: This is a snapshot test, not an execution test, because the decoder
// scope is in a separate file that would need to be compiled and linked separately.
// Tests that including a file with a scope allows calling that scope's
// public functions, and the generated code uses underscore notation
// (e.g., decoder_getSpn) not dot notation (decoder.getSpn)

#include <issue-294-decoder.cnx>

scope handler {
    // Call the included scope's function from within another scope
    // ADR-016: Must use global. prefix when accessing another scope from inside a scope
    public u16 processData(const u8[8] data) {
        // This should generate: decoder_getSpn(data)
        // NOT: decoder.getSpn(data)
        u16 spn <- global.decoder.getSpn(data);
        return spn;
    }

    public u8 extractByte(const u8[8] data, u8 idx) {
        // Another cross-file scope call using global. prefix
        return global.decoder.getByte(data, idx);
    }
}

u32 main() {
    // Create test data
    u8[8] testData;
    testData[0] <- 0x34;  // Low byte
    testData[1] <- 0x12;  // High byte (0x1234 = 4660)
    testData[2] <- 0xAB;
    testData[3] <- 0xCD;
    testData[4] <- 0x00;
    testData[5] <- 0x00;
    testData[6] <- 0x00;
    testData[7] <- 0x00;

    // Test 1: Call decoder.getSpn directly from main
    // This should generate: decoder_getSpn(testData)
    u16 spn <- decoder.getSpn(testData);
    // 0x34 + (0x12 * 256) = 52 + 4608 = 4660 = 0x1234
    if (spn != 4660) return 1;

    // Test 2: Call decoder.getByte directly from main
    u8 byte0 <- decoder.getByte(testData, 0);
    if (byte0 != 0x34) return 2;

    u8 byte1 <- decoder.getByte(testData, 1);
    if (byte1 != 0x12) return 3;

    u8 byte2 <- decoder.getByte(testData, 2);
    if (byte2 != 0xAB) return 4;

    // Test 3: Call through handler scope (cross-scope calling cross-file scope)
    u16 spn2 <- handler.processData(testData);
    if (spn2 != 4660) return 5;

    // Test 4: Another cross-scope through handler
    u8 extracted <- handler.extractByte(testData, 3);
    if (extracted != 0xCD) return 6;

    // All tests passed
    return 0;
}
