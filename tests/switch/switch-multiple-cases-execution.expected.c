/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// ADR-025: Multiple cases execution test
// Tests: case A || B syntax with result validation
// Coverage: Section 7 (Control Flow) - multiple cases per block
uint32_t result = 0;

// Basic multiple case syntax
void testMultiCase(uint32_t val) {
    switch (val) {
        case 0:
        case 1:
        case 2: {
            result = 100U;
            break;
        }
        case 10:
        case 20: {
            result = 200U;
            break;
        }
        case 100: {
            result = 300U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

// Multiple cases with hex literals
void testMultiCaseHex(uint8_t val) {
    switch (val) {
        case 0x00:
        case 0x01: {
            result = 10U;
            break;
        }
        case 0x0A:
        case 0x0B: {
            result = 20U;
            break;
        }
        case 0xFF: {
            result = 30U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Multiple cases with binary literals
void testMultiCaseBinary(uint8_t val) {
    switch (val) {
        case 0x0:
        case 0x1: {
            result = 40U;
            break;
        }
        case 0xA:
        case 0xB: {
            result = 50U;
            break;
        }
        case 0xFF: {
            result = 60U;
            break;
        }
        default: {
            result = 99U;
            break;
        }
    }
}

// Multiple cases with signed values (positive case labels only)
void testMultiCaseSigned(int8_t val) {
    switch (val) {
        case 0:
        case 1:
        case 2: {
            result = 1U;
            break;
        }
        case 50:
        case 51:
        case 52: {
            result = 2U;
            break;
        }
        case 126:
        case 127: {
            result = 3U;
            break;
        }
        default: {
            result = 9U;
            break;
        }
    }
}

// Many cases combined (5 alternatives)
void testManyMultiCases(uint16_t val) {
    switch (val) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5: {
            result = 500U;
            break;
        }
        case 100:
        case 200:
        case 300: {
            result = 600U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

int main(void) {
    uint32_t val0 = 0U;
    uint32_t val1 = 1U;
    uint32_t val2 = 2U;
    uint32_t val10 = 10U;
    uint32_t val20 = 20U;
    uint32_t val100 = 100U;
    uint32_t val50 = 50U;
    testMultiCase(val0);
    if (result != 100) return 1;
    testMultiCase(val1);
    if (result != 100) return 2;
    testMultiCase(val2);
    if (result != 100) return 3;
    testMultiCase(val10);
    if (result != 200) return 4;
    testMultiCase(val20);
    if (result != 200) return 5;
    testMultiCase(val100);
    if (result != 300) return 6;
    testMultiCase(val50);
    if (result != 999) return 7;
    uint8_t hex0 = 0x00U;
    uint8_t hex1 = 0x01U;
    uint8_t hexA = 0x0AU;
    uint8_t hexFF = 0xFFU;
    uint8_t hexOther = 0x50U;
    testMultiCaseHex(hex0);
    if (result != 10) return 8;
    testMultiCaseHex(hex1);
    if (result != 10) return 9;
    testMultiCaseHex(hexA);
    if (result != 20) return 10;
    testMultiCaseHex(hexFF);
    if (result != 30) return 11;
    testMultiCaseHex(hexOther);
    if (result != 99) return 12;
    uint8_t bin0 = 0b00000000U;
    uint8_t bin1 = 0b00000001U;
    uint8_t binA = 0b00001010U;
    uint8_t binFF = 0b11111111U;
    uint8_t binOther = 0b00100000U;
    testMultiCaseBinary(bin0);
    if (result != 40) return 13;
    testMultiCaseBinary(bin1);
    if (result != 40) return 14;
    testMultiCaseBinary(binA);
    if (result != 50) return 15;
    testMultiCaseBinary(binFF);
    if (result != 60) return 16;
    testMultiCaseBinary(binOther);
    if (result != 99) return 17;
    int8_t sZero = 0;
    int8_t sOne = 1;
    int8_t sTwo = 2;
    int8_t sFifty = 50;
    int8_t sFiftyOne = 51;
    int8_t sMax1 = 126;
    int8_t sMax = 127;
    int8_t sNeg = -50;
    testMultiCaseSigned(sZero);
    if (result != 1) return 18;
    testMultiCaseSigned(sOne);
    if (result != 1) return 19;
    testMultiCaseSigned(sTwo);
    if (result != 1) return 20;
    testMultiCaseSigned(sFifty);
    if (result != 2) return 21;
    testMultiCaseSigned(sFiftyOne);
    if (result != 2) return 22;
    testMultiCaseSigned(sMax1);
    if (result != 3) return 23;
    testMultiCaseSigned(sMax);
    if (result != 3) return 24;
    testMultiCaseSigned(sNeg);
    if (result != 9) return 25;
    uint16_t m1 = 1U;
    uint16_t m3 = 3U;
    uint16_t m5 = 5U;
    uint16_t m100 = 100U;
    uint16_t m200 = 200U;
    uint16_t m300 = 300U;
    uint16_t mOther = 999U;
    testManyMultiCases(m1);
    if (result != 500) return 26;
    testManyMultiCases(m3);
    if (result != 500) return 27;
    testManyMultiCases(m5);
    if (result != 500) return 28;
    testManyMultiCases(m100);
    if (result != 600) return 29;
    testManyMultiCases(m200);
    if (result != 600) return 30;
    testManyMultiCases(m300);
    if (result != 600) return 31;
    testManyMultiCases(mOther);
    if (result != 999) return 32;
    return 0;
}
