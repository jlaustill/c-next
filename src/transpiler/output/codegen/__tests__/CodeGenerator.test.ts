/**
 * Unit tests for CodeGenerator - the main transpiler component.
 * Tests the IOrchestrator interface and internal methods.
 */
import { describe, it, expect } from "vitest";
import CodeGenerator from "../CodeGenerator";
import CNextSourceParser from "../../../logic/parser/CNextSourceParser";
import * as Parser from "../../../logic/parser/grammar/CNextParser";
import SymbolTable from "../../../logic/symbols/SymbolTable";
import CNextResolver from "../../../logic/symbols/cnext/index";
import TSymbolInfoAdapter from "../../../logic/symbols/cnext/adapters/TSymbolInfoAdapter";
import ICodeGenSymbols from "../../../types/ICodeGenSymbols";

/**
 * Helper to parse C-Next source and return tree + generator ready for testing.
 */
function setupGenerator(source: string): {
  tree: Parser.ProgramContext;
  generator: CodeGenerator;
  symbols: ICodeGenSymbols;
} {
  const { tree, errors, tokenStream } = CNextSourceParser.parse(source);
  if (errors.length > 0) {
    throw new Error(`Parse failed: ${errors.map((e) => e.message).join(", ")}`);
  }

  const symbolTable = new SymbolTable();
  const tSymbols = CNextResolver.resolve(tree, "test.cnx");
  const symbols = TSymbolInfoAdapter.convert(tSymbols);

  const generator = new CodeGenerator();
  // Generate to initialize the generator state
  generator.generate(tree, symbolTable, tokenStream, {
    symbolInfo: symbols,
    sourcePath: "test.cnx",
  });

  return { tree, generator, symbols };
}

/**
 * Helper to create a minimal generator for testing specific methods.
 */
function createMinimalGenerator(source: string): CodeGenerator {
  const { generator } = setupGenerator(source);
  return generator;
}

describe("CodeGenerator", () => {
  describe("generate()", () => {
    it("should generate basic C code from empty program", () => {
      const source = "";
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Generated by C-Next Transpiler");
    });

    it("should generate function declarations", () => {
      const source = `
        void foo() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("void foo(void)");
    });

    it("should throw when symbolInfo is not provided", () => {
      const source = `void foo() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          sourcePath: "test.cnx",
        } as never),
      ).toThrow("symbolInfo is required");
    });

    it("should enable debug mode when specified", () => {
      const source = `
        clamp u8 val;
        void main() {
          val +<- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
        debugMode: true,
      });

      // Debug mode affects helper generation
      expect(code).toContain("cnx_clamp_add_u8");
    });

    it("should generate C++ output when cppMode is enabled", () => {
      const source = `
        void foo() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
        cppMode: true,
      });

      expect(generator.isCppMode()).toBe(true);
      // C++ mode uses consistent function signatures with explicit void
      expect(code).toContain("void foo(void)");
    });

    it("should handle include directories", () => {
      const source = `
        void foo() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
        includeDirs: ["/usr/include"],
        inputs: ["."],
      });

      expect(code).toContain("void foo");
    });
  });

  describe("IOrchestrator interface", () => {
    describe("getInput()", () => {
      it("should return input context with symbol table", () => {
        const generator = createMinimalGenerator(`
          void foo() { }
        `);

        const input = generator.getInput();

        expect(input.symbolTable).not.toBeNull();
        expect(input.symbols).not.toBeNull();
        expect(input.typeRegistry).toBeInstanceOf(Map);
        expect(input.functionSignatures).toBeInstanceOf(Map);
        expect(input.knownFunctions).toBeInstanceOf(Set);
        expect(input.knownStructs).toBeInstanceOf(Set);
        expect(input.constValues).toBeInstanceOf(Map);
        expect(input.callbackTypes).toBeInstanceOf(Map);
        expect(input.callbackFieldTypes).toBeInstanceOf(Map);
        expect(typeof input.debugMode).toBe("boolean");
      });
    });

    describe("getState()", () => {
      it("should return generation state snapshot", () => {
        const generator = createMinimalGenerator(`
          void foo() { }
        `);

        const state = generator.getState();

        expect(state.currentScope).toBeNull();
        expect(typeof state.indentLevel).toBe("number");
        expect(typeof state.inFunctionBody).toBe("boolean");
        expect(state.currentParameters).toBeInstanceOf(Map);
        expect(state.localVariables).toBeInstanceOf(Set);
        expect(state.localArrays).toBeInstanceOf(Set);
        expect(state.scopeMembers).toBeInstanceOf(Map);
      });
    });

    describe("applyEffects()", () => {
      it("should process include effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // Apply stdint include effect - verify it doesn't throw
        expect(() =>
          generator.applyEffects([{ type: "include", header: "stdint" }]),
        ).not.toThrow();

        // Verify generator is still functional after applying effects
        expect(generator.getState()).toBeDefined();
      });

      it("should process register-local effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.applyEffects([
          { type: "register-local", name: "myVar", isArray: false },
        ]);

        const state = generator.getState();
        expect(state.localVariables.has("myVar")).toBe(true);
      });

      it("should process register-local array effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.applyEffects([
          { type: "register-local", name: "myArray", isArray: true },
        ]);

        const state = generator.getState();
        expect(state.localVariables.has("myArray")).toBe(true);
        expect(state.localArrays.has("myArray")).toBe(true);
      });

      it("should process set-scope effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.applyEffects([{ type: "set-scope", name: "MyScope" }]);

        const state = generator.getState();
        expect(state.currentScope).toBe("MyScope");
      });

      it("should process enter-function-body effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // First add a local
        generator.applyEffects([
          { type: "register-local", name: "myVar", isArray: false },
        ]);
        expect(generator.getState().localVariables.has("myVar")).toBe(true);

        // Then enter function body (clears locals)
        generator.applyEffects([{ type: "enter-function-body" }]);

        expect(generator.getState().inFunctionBody).toBe(true);
        expect(generator.getState().localVariables.size).toBe(0);
      });

      it("should process exit-function-body effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.applyEffects([{ type: "enter-function-body" }]);
        expect(generator.getState().inFunctionBody).toBe(true);

        generator.applyEffects([{ type: "exit-function-body" }]);

        expect(generator.getState().inFunctionBody).toBe(false);
      });

      it("should process set-array-init-count effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // Verify effect is applied without throwing
        expect(() =>
          generator.applyEffects([{ type: "set-array-init-count", count: 5 }]),
        ).not.toThrow();

        // Verify generator state is still valid
        expect(generator.getState()).toBeDefined();
      });

      it("should process set-array-fill-value effects", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // Verify effect is applied without throwing
        expect(() =>
          generator.applyEffects([
            { type: "set-array-fill-value", value: "0xFF" },
          ]),
        ).not.toThrow();

        // Verify generator state is still valid
        expect(generator.getState()).toBeDefined();
      });
    });

    describe("getIndent()", () => {
      it("should return empty string at indent level 0", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getIndent()).toBe("");
      });
    });

    describe("resolveIdentifier()", () => {
      it("should resolve simple identifier", () => {
        const generator = createMinimalGenerator(`
          u32 globalVar;
          void foo() { }
        `);

        const resolved = generator.resolveIdentifier("globalVar");
        expect(resolved).toBe("globalVar");
      });

      it("should resolve scope-prefixed identifier", () => {
        const source = `
          scope Motor {
            u32 speed;
            public void setSpeed() { }
          }
        `;
        const generator = createMinimalGenerator(source);

        // When inside a scope, identifiers should be resolved with prefix
        generator.setCurrentScope("Motor");

        // Verify scope was set correctly
        expect(generator.getState().currentScope).toBe("Motor");
      });
    });

    describe("isKnownStruct()", () => {
      it("should return true for known struct", () => {
        const generator = createMinimalGenerator(`
          struct Point { i32 x; i32 y; }
        `);

        expect(generator.isKnownStruct("Point")).toBe(true);
      });

      it("should return false for unknown struct", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.isKnownStruct("UnknownStruct")).toBe(false);
      });
    });

    describe("isFloatType()", () => {
      it("should return true for f32", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isFloatType("f32")).toBe(true);
      });

      it("should return true for f64", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isFloatType("f64")).toBe(true);
      });

      it("should return false for C type float (only C-Next types checked)", () => {
        // isFloatType only checks C-Next types, not C types
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isFloatType("float")).toBe(false);
      });

      it("should return false for C type double (only C-Next types checked)", () => {
        // isFloatType only checks C-Next types, not C types
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isFloatType("double")).toBe(false);
      });

      it("should return false for integer types", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isFloatType("u32")).toBe(false);
        expect(generator.isFloatType("i32")).toBe(false);
      });
    });

    describe("isIntegerType()", () => {
      it("should return true for unsigned integer types", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isIntegerType("u8")).toBe(true);
        expect(generator.isIntegerType("u16")).toBe(true);
        expect(generator.isIntegerType("u32")).toBe(true);
        expect(generator.isIntegerType("u64")).toBe(true);
      });

      it("should return true for signed integer types", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isIntegerType("i8")).toBe(true);
        expect(generator.isIntegerType("i16")).toBe(true);
        expect(generator.isIntegerType("i32")).toBe(true);
        expect(generator.isIntegerType("i64")).toBe(true);
      });

      it("should return false for float types", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isIntegerType("f32")).toBe(false);
        expect(generator.isIntegerType("f64")).toBe(false);
      });
    });

    describe("isCNextFunction()", () => {
      it("should return true for C-Next defined function", () => {
        const generator = createMinimalGenerator(`
          void myFunction() { }
        `);

        expect(generator.isCNextFunction("myFunction")).toBe(true);
      });

      it("should return false for unknown function", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.isCNextFunction("unknownFunction")).toBe(false);
      });
    });

    describe("isCppMode()", () => {
      it("should return false by default", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isCppMode()).toBe(false);
      });
    });

    describe("isStructType()", () => {
      it("should return true for struct type", () => {
        const generator = createMinimalGenerator(`
          struct Point { i32 x; i32 y; }
        `);

        expect(generator.isStructType("Point")).toBe(true);
      });

      it("should return false for primitive type", () => {
        const generator = createMinimalGenerator(`void foo() { }`);
        expect(generator.isStructType("u32")).toBe(false);
      });
    });

    describe("getKnownEnums()", () => {
      it("should return set of known enums", () => {
        const generator = createMinimalGenerator(`
          enum Color { RED, GREEN, BLUE }
        `);

        const knownEnums = generator.getKnownEnums();
        expect(knownEnums.has("Color")).toBe(true);
      });
    });

    describe("isConstValue()", () => {
      it("should return true for const variable", () => {
        const generator = createMinimalGenerator(`
          const u32 MAX_VALUE <- 100;
          void foo() { }
        `);

        expect(generator.isConstValue("MAX_VALUE")).toBe(true);
      });

      it("should return false for non-const variable", () => {
        const generator = createMinimalGenerator(`
          u32 value;
          void foo() { }
        `);

        expect(generator.isConstValue("value")).toBe(false);
      });
    });

    describe("flushPendingTempDeclarations()", () => {
      it("should return empty string when no pending declarations", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.flushPendingTempDeclarations()).toBe("");
      });
    });

    describe("registerLocalVariable()", () => {
      it("should add variable to local variables", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.registerLocalVariable("localVar");

        expect(generator.getState().localVariables.has("localVar")).toBe(true);
      });
    });

    describe("setCurrentScope() / setCurrentFunctionName()", () => {
      it("should set and track current scope", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.setCurrentScope("MyScope");
        expect(generator.getState().currentScope).toBe("MyScope");

        generator.setCurrentScope(null);
        expect(generator.getState().currentScope).toBeNull();
      });

      it("should set current function name", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // Verify function name can be set without throwing
        expect(() =>
          generator.setCurrentFunctionName("myFunction"),
        ).not.toThrow();

        // Verify generator state is still valid
        expect(generator.getState()).toBeDefined();
      });
    });

    describe("getCurrentFunctionReturnType() / setCurrentFunctionReturnType()", () => {
      it("should get and set return type", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getCurrentFunctionReturnType()).toBeNull();

        generator.setCurrentFunctionReturnType("u32");
        expect(generator.getCurrentFunctionReturnType()).toBe("u32");

        generator.setCurrentFunctionReturnType(null);
        expect(generator.getCurrentFunctionReturnType()).toBeNull();
      });
    });

    describe("enterFunctionBody() / exitFunctionBody()", () => {
      it("should track function body state", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getState().inFunctionBody).toBe(false);

        generator.enterFunctionBody();
        expect(generator.getState().inFunctionBody).toBe(true);

        generator.exitFunctionBody();
        expect(generator.getState().inFunctionBody).toBe(false);
      });

      it("should clear local state on exit", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.enterFunctionBody();
        generator.registerLocalVariable("tempVar");
        expect(generator.getState().localVariables.has("tempVar")).toBe(true);

        generator.exitFunctionBody();
        expect(generator.getState().localVariables.has("tempVar")).toBe(false);
      });
    });

    describe("setMainArgsName()", () => {
      it("should set main args name", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.setMainArgsName("args");
        expect(generator.getState().mainArgsName).toBe("args");

        generator.setMainArgsName(null);
        expect(generator.getState().mainArgsName).toBeNull();
      });
    });

    describe("isKnownScope()", () => {
      it("should return true for known scope", () => {
        const generator = createMinimalGenerator(`
          scope Motor {
            public void stop() { }
          }
        `);

        expect(generator.isKnownScope("Motor")).toBe(true);
      });

      it("should return false for unknown scope", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.isKnownScope("UnknownScope")).toBe(false);
      });
    });

    describe("addPendingTempDeclaration()", () => {
      it("should add temp declaration that can be flushed", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.addPendingTempDeclaration("int _tmp1 = 0;");

        const decls = generator.flushPendingTempDeclarations();
        expect(decls).toBe("int _tmp1 = 0;");

        // After flush, should be empty
        expect(generator.flushPendingTempDeclarations()).toBe("");
      });
    });

    describe("float bit shadow management", () => {
      it("should register and track float bit shadows", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.hasFloatBitShadow("__bits_myFloat")).toBe(false);
        expect(generator.isFloatShadowCurrent("__bits_myFloat")).toBe(false);

        generator.registerFloatBitShadow("__bits_myFloat");
        expect(generator.hasFloatBitShadow("__bits_myFloat")).toBe(true);
        expect(generator.isFloatShadowCurrent("__bits_myFloat")).toBe(false);

        generator.markFloatShadowCurrent("__bits_myFloat");
        expect(generator.isFloatShadowCurrent("__bits_myFloat")).toBe(true);
      });

      it("should clear float shadows on enter/exit function body", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        generator.enterFunctionBody();
        generator.registerFloatBitShadow("__bits_myFloat");
        expect(generator.hasFloatBitShadow("__bits_myFloat")).toBe(true);

        generator.exitFunctionBody();
        expect(generator.hasFloatBitShadow("__bits_myFloat")).toBe(false);
      });
    });

    describe("generateBitMask()", () => {
      it("should generate 32-bit mask", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        const mask = generator.generateBitMask("8", false);
        expect(mask).toContain("0xFFU");
      });

      it("should generate 64-bit mask with ULL suffix", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        const mask = generator.generateBitMask("8", true);
        expect(mask).toContain("ULL");
      });
    });

    describe("getScopeSeparator()", () => {
      it("should return :: for C++ access", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getScopeSeparator(true)).toBe("::");
      });

      it("should return _ for C-Next access", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getScopeSeparator(false)).toBe("_");
      });
    });

    describe("getStringLiteralLength()", () => {
      it("should return correct length for simple string", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        expect(generator.getStringLiteralLength('"hello"')).toBe(5);
      });

      it("should handle escape sequences", () => {
        const generator = createMinimalGenerator(`void foo() { }`);

        // \n is one character
        expect(generator.getStringLiteralLength('"hello\\n"')).toBe(6);
      });
    });

    describe("isParameterPassByValue()", () => {
      it("should check pass-by-value for primitive parameters", () => {
        const generator = createMinimalGenerator(`
          void test(u32 value) { }
        `);

        // Pass-by-value analysis is done during generation
        // Check pass-by-value map exists
        const passByValue = generator.getPassByValueParams();
        expect(passByValue).toBeInstanceOf(Map);
      });
    });

    describe("markParameterModified() / isCalleeParameterModified()", () => {
      it("should track parameter modifications", () => {
        const generator = createMinimalGenerator(`
          void modify(u32 param) {
            param <- 42;
          }
          void caller(u32 x) {
            modify(x);
          }
        `);

        // Modification tracking is done during generation
        expect(generator.isCalleeParameterModified("modify", 0)).toBe(true);
      });

      it("should return false for unmodified parameters", () => {
        const generator = createMinimalGenerator(`
          void noModify(u32 param) { }
        `);

        expect(generator.isCalleeParameterModified("noModify", 0)).toBe(false);
      });
    });

    describe("isCurrentParameter()", () => {
      it("should check if name is a current parameter", () => {
        const generator = createMinimalGenerator(`
          void test(u32 value) { }
        `);

        // Parameters are only current during function body generation
        // After generation, parameters are cleared
        expect(generator.isCurrentParameter("value")).toBe(false);
      });
    });

    describe("getModifiedParameters()", () => {
      it("should return map of modified parameters", () => {
        const generator = createMinimalGenerator(`
          void modify(u32 param) {
            param <- 42;
          }
        `);

        const modifiedParams = generator.getModifiedParameters();
        expect(modifiedParams).toBeInstanceOf(Map);
      });
    });

    describe("getFunctionUnmodifiedParams()", () => {
      it("should return map of unmodified parameters", () => {
        const generator = createMinimalGenerator(`
          void noModify(u32 param) { }
        `);

        const unmodifiedParams = generator.getFunctionUnmodifiedParams();
        expect(unmodifiedParams).toBeInstanceOf(Map);
      });
    });

    describe("getFunctionParamLists()", () => {
      it("should return function parameter lists", () => {
        const generator = createMinimalGenerator(`
          void test(u32 a, u32 b) { }
        `);

        const paramLists = generator.getFunctionParamLists();
        expect(paramLists).toBeInstanceOf(Map);
      });
    });

    describe("getPassByValueParams()", () => {
      it("should return pass-by-value parameters", () => {
        const generator = createMinimalGenerator(`
          void test(u32 value) { }
        `);

        const passByValue = generator.getPassByValueParams();
        expect(passByValue).toBeInstanceOf(Map);
      });
    });
  });

  describe("Type generation", () => {
    it("should map C-Next types to C types", () => {
      const source = `
        u8 a;
        u16 b;
        u32 c;
        u64 d;
        i8 e;
        i16 f;
        i32 g;
        i64 h;
        f32 i;
        f64 j;
        bool k;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint8_t a");
      expect(code).toContain("uint16_t b");
      expect(code).toContain("uint32_t c");
      expect(code).toContain("uint64_t d");
      expect(code).toContain("int8_t e");
      expect(code).toContain("int16_t f");
      expect(code).toContain("int32_t g");
      expect(code).toContain("int64_t h");
      expect(code).toContain("float i");
      expect(code).toContain("double j");
      expect(code).toContain("bool k");
    });
  });

  describe("Assignment operator translation", () => {
    it("should translate <- to =", () => {
      const source = `
        u32 x;
        void main() {
          x <- 42;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("x = 42;");
    });

    it("should translate compound assignment operators", () => {
      // Note: Default is 'clamp' overflow behavior which uses helper functions
      // Use 'wrap' for direct C operators
      const source = `
        wrap u32 x <- 10;
        void main() {
          x +<- 5;
          x -<- 3;
          x *<- 2;
          x /<- 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("x += 5;");
      expect(code).toContain("x -= 3;");
      expect(code).toContain("x *= 2;");
      expect(code).toContain("x /= 2;");
    });
  });

  describe("Equality operator translation", () => {
    it("should translate = to == for comparison", () => {
      const source = `
        u32 x <- 10;
        void main() {
          if (x = 10) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("x == 10");
    });
  });

  describe("Enum generation", () => {
    it("should generate C enum with prefix", () => {
      const source = `
        enum Color { RED, GREEN, BLUE }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef enum");
      expect(code).toContain("Color_RED");
      expect(code).toContain("Color_GREEN");
      expect(code).toContain("Color_BLUE");
    });
  });

  describe("Struct generation", () => {
    it("should generate C struct", () => {
      const source = `
        struct Point {
          i32 x;
          i32 y;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef struct");
      expect(code).toContain("int32_t x");
      expect(code).toContain("int32_t y");
      expect(code).toContain("} Point;");
    });
  });

  describe("Scope generation", () => {
    it("should generate scope members with prefix", () => {
      const source = `
        scope Motor {
          u32 speed;
          public void setSpeed(u32 s) {
            speed <- s;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t Motor_speed");
      expect(code).toContain("void Motor_setSpeed");
      expect(code).toContain("Motor_speed = s;");
    });
  });

  describe("Bitmap generation", () => {
    it("should generate bitmap as uint type", () => {
      // bitmap8 requires exactly 8 bits total
      // Syntax: fieldName for 1-bit, fieldName[N] for N-bit
      const source = `
        bitmap8 Flags {
          bit0,
          bit1,
          bit2,
          bit3,
          bit4,
          bit5,
          bit6,
          bit7
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef uint8_t Flags;");
    });
  });

  describe("Overflow behavior", () => {
    it("should generate clamp helper for compound assignment", () => {
      // Clamp helpers are generated for compound assignment operators
      const source = `
        clamp u8 value <- 200;
        void main() {
          value +<- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("cnx_clamp_add_u8");
      expect(code).toContain("cnx_clamp_add_u8(value, 100)");
    });
  });

  describe("analyzeModificationsOnly()", () => {
    it("should analyze modifications without full generation", () => {
      const source = `
        void modify(u32 param) {
          param <- 42;
        }
      `;
      const { tree } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();

      const result = generator.analyzeModificationsOnly(tree);

      expect(result.modifications).toBeInstanceOf(Map);
      expect(result.paramLists).toBeInstanceOf(Map);
      expect(result.modifications.get("modify")?.has("param")).toBe(true);
    });

    it("should accept cross-file data for transitive propagation", () => {
      const source = `
        void caller(u32 x) {
          externalModify(x);
        }
      `;
      const { tree } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();

      const crossFileModifications = new Map<string, ReadonlySet<string>>([
        ["externalModify", new Set(["param"])],
      ]);
      const crossFileParamLists = new Map<string, readonly string[]>([
        ["externalModify", ["param"]],
      ]);

      const result = generator.analyzeModificationsOnly(
        tree,
        crossFileModifications,
        crossFileParamLists,
      );

      expect(result.modifications).toBeInstanceOf(Map);
    });
  });

  describe("setCrossFileModifications()", () => {
    it("should set cross-file modification data", () => {
      const generator = createMinimalGenerator(`void foo() { }`);

      const modifications = new Map<string, ReadonlySet<string>>([
        ["externalFunc", new Set(["param"])],
      ]);
      const paramLists = new Map<string, readonly string[]>([
        ["externalFunc", ["param"]],
      ]);

      // Verify modifications can be set without throwing
      expect(() =>
        generator.setCrossFileModifications(modifications, paramLists),
      ).not.toThrow();

      // Verify generator state is still valid
      expect(generator.getState()).toBeDefined();
    });
  });

  describe("Target capabilities", () => {
    it("should use default capabilities when no target specified", () => {
      const source = `void foo() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      const input = generator.getInput();
      expect(input.targetCapabilities.wordSize).toBe(32);
    });

    it("should use CLI target when specified", () => {
      const source = `void foo() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
        target: "teensy41",
      });

      const input = generator.getInput();
      expect(input.targetCapabilities.hasLdrexStrex).toBe(true);
      expect(input.targetCapabilities.hasBasepri).toBe(true);
    });

    it("should handle unknown CLI target with warning", () => {
      const source = `void foo() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      // Should not throw, just warn and use default
      generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
        target: "unknown-target",
      });

      const input = generator.getInput();
      expect(input.targetCapabilities.wordSize).toBe(32);
    });
  });

  describe("Control flow generation", () => {
    it("should generate if statement", () => {
      const source = `
        u32 x <- 10;
        void main() {
          if (x = 10) {
            x <- 5;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("if (x == 10)");
      expect(code).toContain("x = 5;");
    });

    it("should generate if-else statement", () => {
      const source = `
        u32 x <- 10;
        void main() {
          if (x = 10) {
            x <- 5;
          } else {
            x <- 20;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("if (x == 10)");
      expect(code).toContain("} else {");
    });

    it("should generate while loop", () => {
      const source = `
        wrap u32 x <- 10;
        void main() {
          while (x > 0) {
            x -<- 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("while (x > 0)");
    });

    it("should generate for loop", () => {
      const source = `
        wrap u32 sum <- 0;
        void main() {
          for (wrap u32 i <- 0; i < 10; i +<- 1) {
            sum +<- i;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("for (");
      expect(code).toContain("i < 10");
    });

    it("should generate do-while loop", () => {
      const source = `
        wrap u32 x <- 10;
        void main() {
          do {
            x -<- 1;
          } while (x > 0);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("do {");
      expect(code).toContain("} while (x > 0);");
    });

    it("should generate switch statement", () => {
      const source = `
        u32 x <- 1;
        u32 result <- 0;
        void main() {
          switch (x) {
            case 1 { result <- 10; }
            case 2 { result <- 20; }
            default { result <- 0; }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("switch (x)");
      expect(code).toContain("case 1:");
      expect(code).toContain("case 2:");
      expect(code).toContain("default:");
      expect(code).toContain("break;");
    });

    it("should generate return statement", () => {
      const source = `
        u32 getNumber() {
          return 42;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("return 42;");
    });
  });

  describe("Array declarations", () => {
    it("should generate array declaration", () => {
      const source = `
        u32 arr[10];
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t arr[10]");
    });

    it("should generate array with initializer", () => {
      const source = `
        u32 arr[3] <- [1, 2, 3];
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("arr[3]");
      expect(code).toContain("{1, 2, 3}");
    });

    it("should generate multi-dimensional array", () => {
      const source = `
        u32 matrix[3][3];
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("matrix[3][3]");
    });
  });

  describe("Function parameters", () => {
    it("should generate function with parameters", () => {
      const source = `
        void add(u32 a, u32 b) { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Parameters should be const if not modified
      expect(code).toContain("uint32_t a");
      expect(code).toContain("uint32_t b");
    });

    it("should generate struct parameter with pointer semantics", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        void setPoint(Point p) {
          p.x <- 10;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Struct params become pointers in C mode
      expect(code).toContain("Point*");
    });

    it("should generate array parameter", () => {
      const source = `
        void process(u32 arr[10]) { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("arr[10]");
    });
  });

  describe("Expression generation", () => {
    it("should generate arithmetic expressions", () => {
      const source = `
        wrap u32 a <- 10;
        wrap u32 b <- 5;
        wrap u32 c;
        void main() {
          c <- a + b * 2 - 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a + b * 2 - 1");
    });

    it("should generate comparison expressions", () => {
      const source = `
        u32 a <- 10;
        u32 b <- 5;
        bool result;
        void main() {
          result <- a > b;
          result <- a >= b;
          result <- a < b;
          result <- a <= b;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a > b");
      expect(code).toContain("a >= b");
      expect(code).toContain("a < b");
      expect(code).toContain("a <= b");
    });

    it("should generate logical expressions", () => {
      const source = `
        bool a <- true;
        bool b <- false;
        bool result;
        void main() {
          result <- a && b;
          result <- a || b;
          result <- !a;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a && b");
      expect(code).toContain("a || b");
      expect(code).toContain("!a");
    });

    it("should generate bitwise expressions", () => {
      const source = `
        wrap u32 a <- 0xFF;
        wrap u32 b <- 0x0F;
        wrap u32 result;
        void main() {
          result <- a & b;
          result <- a | b;
          result <- a ^ b;
          result <- ~a;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a & b");
      expect(code).toContain("a | b");
      expect(code).toContain("a ^ b");
      expect(code).toContain("~a");
    });

    it("should generate shift expressions", () => {
      const source = `
        wrap u32 a <- 1;
        wrap u32 result;
        void main() {
          result <- a << 4;
          result <- a >> 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("<< 4");
      expect(code).toContain(">> 2");
    });

    it("should generate unary expressions", () => {
      const source = `
        i32 a <- 10;
        i32 result;
        void main() {
          result <- -a;
          result <- +a;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("-a");
    });

    it("should generate increment/decrement using compound assignment", () => {
      // C-Next uses +<- 1 for increment instead of ++
      const source = `
        wrap u32 a <- 10;
        void main() {
          a +<- 1;
          a -<- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a += 1");
      expect(code).toContain("a -= 1");
    });
  });

  describe("Struct member access", () => {
    it("should generate struct member access", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        Point p;
        void main() {
          p.x <- 10;
          p.y <- 20;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("p.x = 10");
      expect(code).toContain("p.y = 20");
    });

    it("should generate struct initializer", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        Point p <- {x: 10, y: 20};
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain(".x = 10");
      expect(code).toContain(".y = 20");
    });
  });

  describe("Enum member access", () => {
    it("should generate enum member access with prefix", () => {
      const source = `
        enum Color { RED, GREEN, BLUE }
        Color c;
        void main() {
          c <- Color.RED;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Color_RED");
    });
  });

  describe("Const declarations", () => {
    it("should generate const variable", () => {
      const source = `
        const u32 MAX_SIZE <- 100;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("const uint32_t MAX_SIZE = 100");
    });
  });

  describe("Register declarations", () => {
    it("should generate register definition", () => {
      const source = `
        register GPIO @ 0x40020000 {
          rw u32 DATA @ 0x00
        }
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("0x40020000");
    });
  });

  describe("Function calls", () => {
    it("should generate function call", () => {
      const source = `
        u32 add(u32 a, u32 b) {
          return a + b;
        }
        u32 result;
        void main() {
          result <- add(1, 2);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("result = add(1, 2);");
    });

    it("should generate scope function call", () => {
      const source = `
        scope Math {
          public u32 square(u32 x) {
            return x * x;
          }
        }
        u32 result;
        void main() {
          result <- Math.square(5);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Math_square(5)");
    });
  });

  describe("Float types", () => {
    it("should generate float declarations", () => {
      // Note: C-Next doesn't use 'f' suffix - float literals are just decimals
      const source = `
        f32 a <- 1.5;
        f64 b <- 2.5;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("float a = 1.5");
      expect(code).toContain("double b = 2.5");
    });
  });

  describe("Atomic declarations", () => {
    it("should generate atomic variable", () => {
      const source = `
        atomic u32 counter <- 0;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("volatile uint32_t counter");
    });
  });

  describe("Include directive transformation", () => {
    it("should pass through C header includes unchanged", () => {
      const source = `
        #include <stdio.h>
        #include "myheader.h"
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("#include <stdio.h>");
      expect(code).toContain('#include "myheader.h"');
    });

    it("should throw error for missing .cnx include", () => {
      const source = `
        #include "nonexistent.cnx"
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/not found/);
    });
  });

  describe("Self-include generation", () => {
    it("should generate self-include for public scope members", () => {
      // Public keyword is only valid inside scopes
      const source = `
        scope Motor {
          public void start() { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "myfile.cnx",
        sourceRelativePath: "myfile.cnx",
      });

      expect(code).toContain('#include "myfile.h"');
    });
  });

  describe("Error handling", () => {
    it("should throw on const assignment", () => {
      const source = `
        const u32 VALUE <- 10;
        void main() {
          VALUE <- 20;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/const/i);
    });
  });

  describe("Callback types (ADR-029)", () => {
    it("should generate callback typedef for functions used as field types", () => {
      const source = `
        void onEvent() { }
        struct Handler {
          onEvent callback;
        }
        Handler h;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef");
      expect(code).toContain("onEvent");
    });
  });

  describe("isCppEnumClass()", () => {
    it("should return false when no symbol table", () => {
      const generator = createMinimalGenerator(`void foo() { }`);
      // With symbol table but no C++ symbols
      expect(generator.isCppEnumClass("UnknownEnum")).toBe(false);
    });
  });

  describe("getStructFieldInfo()", () => {
    it("should return field info for known struct", () => {
      const generator = createMinimalGenerator(`
        struct Point { i32 x; i32 y; }
      `);

      const fieldInfo = generator.getStructFieldInfo("Point", "x");
      expect(fieldInfo).not.toBeNull();
      expect(fieldInfo?.type).toBe("i32");
    });

    it("should return null for unknown field", () => {
      const generator = createMinimalGenerator(`
        struct Point { i32 x; i32 y; }
      `);

      const fieldInfo = generator.getStructFieldInfo("Point", "z");
      expect(fieldInfo).toBeNull();
    });
  });

  describe("getMemberTypeInfo()", () => {
    it("should return member type info for known struct", () => {
      const generator = createMinimalGenerator(`
        struct Point { i32 x; i32 y; }
      `);

      const memberInfo = generator.getMemberTypeInfo("Point", "x");
      expect(memberInfo).not.toBeNull();
      expect(memberInfo?.baseType).toBe("i32");
      expect(memberInfo?.isArray).toBe(false);
    });

    it("should return null for unknown struct", () => {
      const generator = createMinimalGenerator(`void foo() { }`);

      const memberInfo = generator.getMemberTypeInfo("Unknown", "field");
      expect(memberInfo).toBeNull();
    });
  });

  describe("indent()", () => {
    it("should indent text with current level", () => {
      const generator = createMinimalGenerator(`void foo() { }`);

      // Default indent level is 0
      const indented = generator.indent("test");
      expect(indented).toBe("test");
    });
  });

  describe("Ternary expressions", () => {
    it("should generate ternary expression with comparison condition", () => {
      const source = `
        u32 a <- 10;
        u32 b <- 5;
        u32 result;
        void main() {
          result <- (a > b) ? 1 : 0;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("(a > b) ? 1 : 0");
    });
  });

  describe("Bit indexing", () => {
    it("should generate bit index expression", () => {
      const source = `
        u32 flags <- 0xFF;
        u32 result;
        void main() {
          result <- flags[4, 4];
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Bit indexing should generate mask and shift
      expect(code).toContain("flags");
      expect(code).toContain(">> 4"); // Shift by start position
    });
  });

  describe("Critical sections", () => {
    it("should generate critical section", () => {
      const source = `
        wrap u32 counter <- 0;
        void main() {
          critical {
            counter +<- 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Critical sections generate interrupt save/restore code
      expect(code).toContain("counter += 1");
    });
  });

  describe("Nested struct access", () => {
    it("should generate nested struct member access", () => {
      const source = `
        struct Inner { i32 value; }
        struct Outer { Inner inner; }
        Outer obj;
        void main() {
          obj.inner.value <- 42;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("obj.inner.value = 42");
    });
  });

  describe("Enum switch", () => {
    it("should generate switch on enum type", () => {
      const source = `
        enum State { IDLE, RUNNING, STOPPED }
        State s <- State.IDLE;
        wrap u32 result <- 0;
        void main() {
          switch (s) {
            case State.IDLE { result <- 0; }
            case State.RUNNING { result <- 1; }
            case State.STOPPED { result <- 2; }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("switch (s)");
      expect(code).toContain("case State_IDLE:");
      expect(code).toContain("case State_RUNNING:");
      expect(code).toContain("case State_STOPPED:");
    });
  });

  describe("Function with return value", () => {
    it("should generate function returning struct", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        Point makePoint() {
          Point p <- {x: 0, y: 0};
          return p;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Point makePoint");
      expect(code).toContain("return p;");
    });
  });

  describe("Local variable declarations", () => {
    it("should generate local variable with initializer", () => {
      const source = `
        void main() {
          wrap u32 localVar <- 100;
          localVar +<- 50;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t localVar = 100");
      expect(code).toContain("localVar += 50");
    });
  });

  describe("Scope with private members", () => {
    it("should generate private scope members with prefix", () => {
      const source = `
        scope Motor {
          u32 privateSpeed;
          public void setSpeed(u32 s) {
            privateSpeed <- s;
          }
          public u32 getSpeed() {
            return privateSpeed;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("static uint32_t Motor_privateSpeed");
      expect(code).toContain("Motor_privateSpeed = s");
      expect(code).toContain("return Motor_privateSpeed");
    });
  });

  describe("Modulo operation", () => {
    it("should generate modulo expression", () => {
      const source = `
        wrap u32 a <- 17;
        wrap u32 result;
        void main() {
          result <- a % 5;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a % 5");
    });
  });

  describe("Division operation", () => {
    it("should generate division expression", () => {
      const source = `
        wrap u32 a <- 20;
        wrap u32 result;
        void main() {
          result <- a / 4;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a / 4");
    });
  });

  describe("String operations", () => {
    it("should generate string variable declaration", () => {
      // string<N> becomes char[N+1] to include null terminator
      const source = `
        string<32> name <- "Hello";
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("char name[33]"); // 32 + 1 for null terminator
      expect(code).toContain('"Hello"');
    });
  });

  describe("Boolean literals", () => {
    it("should generate boolean literals", () => {
      const source = `
        bool a <- true;
        bool b <- false;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("bool a = true");
      expect(code).toContain("bool b = false");
    });
  });

  describe("Hex and binary literals", () => {
    it("should generate hex literal", () => {
      const source = `
        wrap u32 a <- 0xFF;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("0xFF");
    });

    it("should generate binary literal", () => {
      const source = `
        wrap u32 a <- 0b1010;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Binary literals are typically converted to decimal or hex in C
      expect(code).toContain("10"); // 0b1010 = 10
    });
  });

  describe("Main function with void", () => {
    it("should generate void main function", () => {
      const source = `
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("int main(void)");
    });

    it("should generate main with return type", () => {
      const source = `
        u32 main() {
          return 0;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("int main(void)");
      expect(code).toContain("return 0;");
    });
  });

  describe("Parenthesized expressions", () => {
    it("should generate parenthesized expression", () => {
      const source = `
        wrap u32 a <- 10;
        wrap u32 b <- 5;
        wrap u32 c <- 2;
        wrap u32 result;
        void main() {
          result <- (a + b) * c;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("(a + b) * c");
    });
  });

  describe("Array element assignment", () => {
    it("should generate array element assignment", () => {
      const source = `
        wrap u32 arr[10];
        void main() {
          arr[0] <- 42;
          arr[5] <- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("arr[0] = 42");
      expect(code).toContain("arr[5] = 100");
    });
  });

  describe("Enum with explicit values", () => {
    it("should generate enum with explicit member values", () => {
      const source = `
        enum Priority {
          LOW <- 1,
          MEDIUM <- 5,
          HIGH <- 10
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Priority_LOW = 1");
      expect(code).toContain("Priority_MEDIUM = 5");
      expect(code).toContain("Priority_HIGH = 10");
    });
  });

  describe("ISR functions", () => {
    it("should generate ISR function", () => {
      const source = `
        ISR timer_handler() {
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("timer_handler");
    });
  });

  describe("This keyword access", () => {
    it("should generate this. member access inside scope", () => {
      const source = `
        scope Motor {
          u32 speed;
          public void setSpeed(u32 s) {
            this.speed <- s;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Motor_speed = s");
    });
  });

  describe("Global keyword access", () => {
    it("should generate global. variable access inside scope", () => {
      const source = `
        u32 globalCounter <- 0;
        scope Motor {
          public void increment() {
            global.globalCounter <- global.globalCounter + 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("globalCounter = globalCounter + 1");
    });
  });

  describe("Cross-scope function calls", () => {
    it("should generate cross-scope public function call", () => {
      const source = `
        scope Motor {
          public void stop() { }
        }
        void main() {
          Motor.stop();
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Motor_stop()");
    });
  });

  describe("Struct with array member", () => {
    it("should generate struct with array field", () => {
      const source = `
        struct Buffer {
          u8 data[64];
          u32 length;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint8_t data[64]");
      expect(code).toContain("uint32_t length");
    });
  });

  describe("Sizeof expression", () => {
    it("should generate sizeof expression", () => {
      const source = `
        wrap u32 size;
        void main() {
          size <- sizeof(u32);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("sizeof");
    });
  });

  describe("Null literal", () => {
    it("should generate NULL literal", () => {
      const source = `
        void main() {
          bool isNull <- (NULL = NULL);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("NULL");
    });
  });

  describe("Multiple function declarations", () => {
    it("should generate multiple functions", () => {
      const source = `
        u32 add(u32 a, u32 b) { return a + b; }
        u32 sub(u32 a, u32 b) { return a - b; }
        u32 mul(u32 a, u32 b) { return a * b; }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t add(");
      expect(code).toContain("uint32_t sub(");
      expect(code).toContain("uint32_t mul(");
      expect(code).toContain("return a + b");
      expect(code).toContain("return a - b");
      expect(code).toContain("return a * b");
    });
  });

  describe("Volatile variables", () => {
    it("should generate volatile variable", () => {
      const source = `
        volatile u32 sharedData <- 0;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("volatile uint32_t sharedData");
    });
  });

  describe("Signed integer types", () => {
    it("should generate signed integer types", () => {
      const source = `
        i8 a <- -128;
        i16 b <- -32768;
        i32 c <- -2147483648;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("int8_t a = -128");
      expect(code).toContain("int16_t b = -32768");
      expect(code).toContain("int32_t c = -2147483648");
    });
  });

  describe("Negation and comparison", () => {
    it("should generate != comparison", () => {
      const source = `
        u32 a <- 10;
        void main() {
          if (a != 5) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a != 5");
    });
  });

  describe("Bitwise compound assignment", () => {
    it("should generate bitwise compound assignment", () => {
      const source = `
        wrap u32 flags <- 0xFF;
        void main() {
          flags &<- 0x0F;
          flags |<- 0xF0;
          flags ^<- 0xAA;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("flags &= 0x0F");
      expect(code).toContain("flags |= 0xF0");
      expect(code).toContain("flags ^= 0xAA");
    });
  });

  describe("Modulo compound assignment", () => {
    it("should generate modulo compound assignment", () => {
      const source = `
        wrap u32 value <- 100;
        void main() {
          value %<- 7;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("value %= 7");
    });
  });

  describe("Shift compound assignment", () => {
    it("should generate shift compound assignment", () => {
      const source = `
        wrap u32 value <- 1;
        void main() {
          value <<<- 4;
          value >><- 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("value <<= 4");
      expect(code).toContain("value >>= 2");
    });
  });

  describe("Multiple scopes", () => {
    it("should generate multiple scopes with unique prefixes", () => {
      const source = `
        scope Motor {
          u32 speed;
          public void start() { speed <- 100; }
        }
        scope LED {
          bool on;
          public void toggle() { on <- !on; }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Motor_speed");
      expect(code).toContain("Motor_start");
      expect(code).toContain("LED_on");
      expect(code).toContain("LED_toggle");
    });
  });

  describe("Inferred array size", () => {
    it("should generate array with inferred size from initializer", () => {
      const source = `
        u32 values[] <- [1, 2, 3, 4, 5];
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("values[5]"); // Size inferred from initializer
      expect(code).toContain("{1, 2, 3, 4, 5}");
    });
  });

  describe("Char literal", () => {
    it("should generate char literal", () => {
      const source = `
        u8 ch <- 'A';
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("'A'");
    });
  });

  describe("Address-of operator", () => {
    it("should generate address-of expression", () => {
      const source = `
        u32 value <- 42;
        void main() {
          u32 addr <- &value;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("&value");
    });
  });

  describe("Error: private member access", () => {
    it("should throw error when accessing private scope member", () => {
      const source = `
        scope Motor {
          u32 speed;
        }
        void main() {
          Motor.speed <- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/private/i);
    });
  });

  describe("Wrap modifier", () => {
    it("should allow wrap integer overflow without clamping", () => {
      const source = `
        wrap u8 counter <- 255;
        void main() {
          counter +<- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Wrap doesn't use clamp helpers
      expect(code).toContain("counter += 1");
      expect(code).not.toContain("cnx_clamp");
    });
  });

  describe("if-else-if chain", () => {
    it("should generate else-if chain", () => {
      const source = `
        u32 x <- 5;
        u32 result;
        void main() {
          if (x = 1) {
            result <- 10;
          } else if (x = 2) {
            result <- 20;
          } else if (x = 3) {
            result <- 30;
          } else {
            result <- 0;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("if (x == 1)");
      expect(code).toContain("else if (x == 2)");
      expect(code).toContain("else if (x == 3)");
      expect(code).toContain("else");
    });
  });

  describe("Empty function body", () => {
    it("should generate function with empty body", () => {
      const source = `
        void noop() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("void noop(void) {");
      expect(code).toContain("}");
    });
  });

  describe("Nested control flow", () => {
    it("should generate nested loops", () => {
      const source = `
        wrap u32 sum <- 0;
        void main() {
          for (wrap u32 i <- 0; i < 3; i +<- 1) {
            for (wrap u32 j <- 0; j < 3; j +<- 1) {
              sum +<- i * j;
            }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("for (");
      expect(code).toContain("i < 3");
      expect(code).toContain("j < 3");
    });
  });

  describe("Multiple variables declaration", () => {
    it("should generate multiple global variables", () => {
      const source = `
        u32 a <- 1;
        u32 b <- 2;
        u32 c <- 3;
        u32 d <- 4;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t a = 1");
      expect(code).toContain("uint32_t b = 2");
      expect(code).toContain("uint32_t c = 3");
      expect(code).toContain("uint32_t d = 4");
    });
  });

  describe("Preprocessor directives", () => {
    it("should reject #define with value in favor of const", () => {
      // C-Next enforces using const instead of #define for values
      const source = `
        #define MAX_SIZE 100
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/E0502/);
    });

    it("should pass through flag defines without values", () => {
      const source = `
        #define DEBUG_MODE
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("#define DEBUG_MODE");
    });
  });

  describe("Enum variable assignment", () => {
    it("should generate enum variable assignment from member", () => {
      const source = `
        enum State { IDLE, RUNNING, STOPPED }
        State current <- State.IDLE;
        void main() {
          current <- State.RUNNING;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("current = State_RUNNING");
    });
  });

  describe("Struct array member access", () => {
    it("should generate struct with array member access", () => {
      const source = `
        struct Buffer {
          u8 data[64];
        }
        Buffer buf;
        void main() {
          buf.data[0] <- 0xFF;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("buf.data[0] = 0xFF");
    });
  });

  describe("Scope with multiple public methods", () => {
    it("should generate scope with multiple public methods", () => {
      const source = `
        scope Timer {
          u32 count;
          public void reset() { count <- 0; }
          public void increment() { count <- count + 1; }
          public u32 getCount() { return count; }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("void Timer_reset");
      expect(code).toContain("void Timer_increment");
      expect(code).toContain("uint32_t Timer_getCount");
    });
  });

  describe("64-bit types", () => {
    it("should generate 64-bit integer types", () => {
      const source = `
        u64 bigUnsigned <- 0xFFFFFFFFFFFFFFFF;
        i64 bigSigned <- -9223372036854775807;
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint64_t bigUnsigned");
      expect(code).toContain("int64_t bigSigned");
    });
  });

  describe("Bitmap with multi-bit fields", () => {
    it("should generate bitmap with multi-bit fields", () => {
      const source = `
        bitmap8 Status {
          enabled,
          mode[3],
          priority[2],
          reserved[2]
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef uint8_t Status;");
    });
  });

  describe("Bitmap field access", () => {
    it("should generate bitmap field read", () => {
      const source = `
        bitmap8 Flags {
          enabled,
          ready,
          error,
          reserved[5]
        }
        Flags f <- 0;
        bool result;
        void main() {
          result <- f.enabled;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("f");
    });
  });

  describe("Const array", () => {
    it("should generate const array", () => {
      const source = `
        const u32 LOOKUP[4] <- [10, 20, 30, 40];
        void main() { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("const uint32_t LOOKUP[4]");
      expect(code).toContain("{10, 20, 30, 40}");
    });
  });

  describe("Function returning bool", () => {
    it("should generate function returning bool", () => {
      const source = `
        bool isValid(u32 value) {
          return value > 0;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("bool isValid(");
      expect(code).toContain("return value > 0;");
    });
  });

  describe("Multiple conditions with &&", () => {
    it("should generate complex condition", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        void main() {
          if (a > 0 && b < 20) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a > 0 && b < 20");
    });
  });

  describe("Multiple conditions with ||", () => {
    it("should generate OR condition", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        void main() {
          if (a = 0 || b = 0) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a == 0 || b == 0");
    });
  });

  describe("While loop with variable init", () => {
    it("should generate while loop with initialized counter", () => {
      const source = `
        wrap u32 count <- 10;
        void main() {
          while (count > 0) {
            count -<- 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("while (count > 0)");
      expect(code).toContain("count -= 1");
    });
  });

  describe("Break in switch", () => {
    it("should generate break after each case", () => {
      const source = `
        u32 x <- 1;
        void main() {
          switch (x) {
            case 1 { x <- 10; }
            case 2 { x <- 20; }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should have break after each case to prevent fallthrough
      const breakCount = (code.match(/break;/g) || []).length;
      expect(breakCount).toBeGreaterThanOrEqual(2);
    });
  });

  describe("Struct passed to function", () => {
    it("should pass struct by pointer", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        void modifyPoint(Point p) {
          p.x <- 10;
        }
        Point pt;
        void main() {
          modifyPoint(pt);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Struct param becomes pointer
      expect(code).toContain("Point*");
      // Call passes address
      expect(code).toContain("modifyPoint(&pt)");
    });
  });

  describe("Complex expression", () => {
    it("should generate complex arithmetic expression", () => {
      const source = `
        wrap u32 a <- 5;
        wrap u32 b <- 3;
        wrap u32 c <- 2;
        wrap u32 result;
        void main() {
          result <- a * b + c * (a - b);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a * b + c * (a - b)");
    });
  });

  describe("Empty while loop", () => {
    it("should generate while loop with empty body", () => {
      const source = `
        wrap u32 x <- 10;
        void main() {
          while (x > 0) {
            x -<- 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("while (x > 0)");
    });
  });

  describe("Struct with bool member", () => {
    it("should generate struct with bool field", () => {
      const source = `
        struct Config {
          bool enabled;
          u32 timeout;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("bool enabled");
      expect(code).toContain("uint32_t timeout");
    });
  });

  describe("getSimpleIdentifier()", () => {
    it("should return null for complex expressions", () => {
      const generator = createMinimalGenerator(`
        u32 a;
        u32 b;
        void foo() { }
      `);

      // getSimpleIdentifier is tested indirectly through expression parsing
      expect(generator.getInput()).not.toBeNull();
    });
  });

  describe("validateCrossScopeVisibility()", () => {
    it("should not throw for public member access", () => {
      const source = `
        scope Motor {
          public u32 speed;
        }
        void main() {
          Motor.speed <- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      // Should not throw
      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Motor_speed = 100");
    });
  });

  describe("Enum zero initialization", () => {
    it("should initialize enum variable to first member", () => {
      const source = `
        enum State { IDLE, RUNNING, ERROR }
        State current;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should use first enum member (value 0)
      expect(code).toContain("State current = State_IDLE");
    });

    it("should use first member when no member has value 0", () => {
      const source = `
        enum Priority { LOW <- 1, MEDIUM <- 5, HIGH <- 10 }
        Priority p;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should initialize to first member when no 0 value exists
      expect(code).toContain("Priority p =");
    });
  });

  describe("Scoped type zero initialization", () => {
    it("should initialize scoped enum with this.Type", () => {
      const source = `
        scope Motor {
          enum Mode { OFF, ON, AUTO }
          this.Mode currentMode;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should initialize to first member
      expect(code).toContain("Motor_Mode Motor_currentMode =");
    });

    it("should initialize scoped struct with {0}", () => {
      const source = `
        scope Sensor {
          struct Data { i32 value; }
          this.Data latest;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("{0}");
    });
  });

  describe("Global type zero initialization", () => {
    it("should initialize global enum with global.Type", () => {
      const source = `
        enum GlobalState { INIT, READY }
        scope Worker {
          global.GlobalState state;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should initialize to first member
      expect(code).toContain("GlobalState Worker_state =");
    });
  });

  describe("Qualified type zero initialization", () => {
    it("should initialize Scope.Type enum properly", () => {
      const source = `
        scope Config {
          public enum Level { NONE, LOW, HIGH }
        }
        Config.Level setting;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should use qualified type
      expect(code).toContain("Config_Level setting =");
    });
  });

  describe("Array fill-all syntax", () => {
    it("should generate fill-all array [0*]", () => {
      const source = `
        u32 data[10] <- [0*];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should generate {0} for fill-all syntax
      expect(code).toContain("{0}");
    });

    it("should generate fill-all array with non-zero value", () => {
      const source = `
        u8 buffer[4] <- [255*];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Non-zero fill-all expands to all elements
      expect(code).toContain("= {255, 255, 255, 255}");
    });
  });

  describe("Nested array initializers", () => {
    it("should generate 2D array initializer", () => {
      const source = `
        u32 matrix[2][3] <- [[1, 2, 3], [4, 5, 6]];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("{{1, 2, 3}, {4, 5, 6}}");
    });
  });

  describe("Array of structs initialization", () => {
    it("should generate array of struct initializers", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        Point points[2] <- [{x: 1, y: 2}, {x: 3, y: 4}];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain(".x = 1");
      expect(code).toContain(".y = 2");
    });
  });

  describe("Primitive type zero initialization", () => {
    it("should initialize bool to false", () => {
      const source = `bool flag;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("bool flag = false");
    });

    it("should initialize f32 to 0.0f", () => {
      const source = `f32 value;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("float value = 0.0f");
    });

    it("should initialize f64 to 0.0", () => {
      const source = `f64 value;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("double value = 0.0");
    });
  });

  describe("Do-while statement", () => {
    it("should generate do-while loop", () => {
      const source = `
        wrap u32 x <- 0;
        void main() {
          do {
            x +<- 1;
          } while (x < 10);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("do {");
      expect(code).toContain("} while (x < 10)");
    });
  });

  describe("For loop", () => {
    it("should generate for loop with init, condition, update", () => {
      const source = `
        wrap u32 sum <- 0;
        void main() {
          for (wrap u32 i <- 0; i < 10; i +<- 1) {
            sum +<- i;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("for (");
      expect(code).toContain("i < 10");
    });
  });

  describe("Return statement with expression", () => {
    it("should generate return with value", () => {
      const source = `
        u32 getAnswer() {
          return 42;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("return 42");
    });

    it("should generate void return", () => {
      const source = `
        void earlyReturn() {
          return;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("return;");
    });
  });

  describe("Struct auto zero initialization", () => {
    it("should generate zero-initialized struct without explicit initializer", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        Point origin;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // C-Next auto-initializes to {0}
      expect(code).toContain("Point origin = {0}");
    });
  });

  describe("Atomic and volatile modifiers", () => {
    it("should reject both atomic and volatile on same variable", () => {
      const source = `
        atomic volatile u32 badVar;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow("Cannot use both 'atomic' and 'volatile' modifiers");
    });
  });

  describe("Nested if-else", () => {
    it("should generate nested if-else-if chain", () => {
      const source = `
        wrap u32 x <- 5;
        wrap u32 result <- 0;
        void main() {
          if (x < 3) {
            result <- 1;
          } else if (x < 7) {
            result <- 2;
          } else {
            result <- 3;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("if (x < 3)");
      expect(code).toContain("else if (x < 7)");
      expect(code).toContain("else");
    });
  });

  describe("Switch with default case", () => {
    it("should generate switch with default", () => {
      const source = `
        u32 code <- 99;
        u32 output <- 0;
        void main() {
          switch (code) {
            case 1 { output <- 10; }
            case 2 { output <- 20; }
            default { output <- 0; }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("switch (code)");
      expect(code).toContain("case 1:");
      expect(code).toContain("default:");
    });
  });

  describe("Array dimension with const", () => {
    it("should resolve const as array dimension at file scope", () => {
      const source = `
        const u32 SIZE <- 10;
        u32 data[SIZE];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // At file scope, const should be resolved to literal
      expect(code).toContain("[10]");
    });
  });

  describe("Multi-dimensional array", () => {
    it("should generate 3D array declaration", () => {
      const source = `
        u8 cube[2][3][4];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("[2][3][4]");
    });
  });

  describe("Expression statement", () => {
    it("should generate function call as statement", () => {
      const source = `
        void doSomething() { }
        void main() {
          doSomething();
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("doSomething();");
    });
  });

  describe("Block statement", () => {
    it("should generate standalone block", () => {
      const source = `
        wrap u32 x <- 0;
        void main() {
          {
            wrap u32 y <- 10;
            x <- y;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should have nested block
      expect(code).toContain("uint32_t y = 10");
    });
  });

  describe("Unary operators", () => {
    it("should generate logical NOT", () => {
      const source = `
        bool flag <- true;
        bool result <- !flag;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("!flag");
    });

    it("should generate bitwise NOT", () => {
      const source = `
        wrap u8 mask <- 0x0F;
        wrap u8 inverted <- ~mask;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("~mask");
    });

    it("should generate unary minus", () => {
      const source = `
        i32 pos <- 10;
        i32 neg <- -pos;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("-pos");
    });
  });

  describe("Bitwise operators", () => {
    it("should generate bitwise AND", () => {
      const source = `
        wrap u8 a <- 0x0F;
        wrap u8 b <- 0xF0;
        wrap u8 result <- a & b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a & b");
    });

    it("should generate bitwise OR", () => {
      const source = `
        wrap u8 a <- 0x0F;
        wrap u8 b <- 0xF0;
        wrap u8 result <- a | b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a | b");
    });

    it("should generate bitwise XOR", () => {
      const source = `
        wrap u8 a <- 0x55;
        wrap u8 b <- 0xAA;
        wrap u8 result <- a ^ b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a ^ b");
    });

    it("should generate left shift", () => {
      const source = `
        wrap u8 a <- 1;
        wrap u8 result <- a << 4;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a << 4");
    });

    it("should generate right shift", () => {
      const source = `
        wrap u8 a <- 0x80;
        wrap u8 result <- a >> 4;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a >> 4");
    });
  });

  describe("Logical operators", () => {
    it("should generate logical AND", () => {
      const source = `
        bool a <- true;
        bool b <- false;
        bool result <- a && b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a && b");
    });

    it("should generate logical OR", () => {
      const source = `
        bool a <- true;
        bool b <- false;
        bool result <- a || b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a || b");
    });
  });

  describe("Comparison operators", () => {
    it("should generate less than or equal", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        bool result <- a <= b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a <= b");
    });

    it("should generate greater than or equal", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        bool result <- a >= b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a >= b");
    });

    it("should generate not equal", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        bool result <- a != b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a != b");
    });
  });

  describe("Cast expression", () => {
    it("should handle widening cast", () => {
      const source = `
        u8 small <- 100;
        u32 big <- small as u32;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should compile with the cast (implicit widening is allowed)
      expect(code).toContain("big =");
      expect(code).toContain("small");
    });

    it("should generate bit extraction for narrowing", () => {
      const source = `
        u32 big <- 1000;
        u8 small <- big[0, 8];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Bit extraction generates mask and shift
      expect(code).toContain("big");
      expect(code).toContain("&");
    });

    it("should generate float to int cast with clamping", () => {
      const source = `
        f32 floatVal <- 100.5;
        i32 intVal <- floatVal as i32;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Float to int cast generates clamping code
      expect(code).toContain("floatVal");
      expect(code).toContain("int32_t");
    });
  });

  describe("Function with multiple parameters", () => {
    it("should generate function with multiple params", () => {
      const source = `
        u32 add(u32 a, u32 b, u32 c) {
          return a + b + c;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t a, uint32_t b, uint32_t c");
    });
  });

  describe("Nested struct access", () => {
    it("should generate nested struct member access", () => {
      const source = `
        struct Inner { i32 value; }
        struct Outer { Inner child; }
        Outer obj <- {child: {value: 42}};
        void main() {
          obj.child.value <- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("obj.child.value = 100");
    });
  });

  describe("Array indexing with expressions", () => {
    it("should generate array index with arithmetic", () => {
      const source = `
        u32 data[10];
        wrap u32 i <- 2;
        void main() {
          data[i * 2 + 1] <- 42;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("data[i * 2 + 1]");
    });
  });

  describe("Enum assignment", () => {
    it("should generate enum value assignment", () => {
      const source = `
        enum Color { RED, GREEN, BLUE }
        Color c <- Color.RED;
        void main() {
          c <- Color.GREEN;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Color_GREEN");
    });
  });

  describe("String type", () => {
    it("should generate bounded string declaration", () => {
      const source = `string<32> name <- "hello";`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // String capacity + 1 for null terminator
      expect(code).toContain("char name[33]");
    });
  });

  describe("Volatile variable", () => {
    it("should generate volatile declaration", () => {
      const source = `volatile u32 hwReg;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("volatile uint32_t hwReg");
    });
  });

  describe("Const struct", () => {
    it("should generate const struct declaration", () => {
      const source = `
        struct Config { u32 value; }
        const Config defaultConfig <- {value: 100};
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("const Config defaultConfig");
    });
  });

  describe("Critical statement", () => {
    it("should generate critical section with interrupt disable", () => {
      const source = `
        atomic u32 counter <- 0;
        void main() {
          critical {
            counter <- counter + 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should include interrupt disable/enable
      expect(code).toContain("__cnx_disable_irq");
      expect(code).toContain("__primask");
    });
  });

  describe("Atomic variable", () => {
    it("should generate volatile for atomic variable", () => {
      const source = `atomic u32 counter <- 0;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Atomic maps to volatile in C
      expect(code).toContain("volatile uint32_t counter");
    });
  });

  describe("Sizeof expression", () => {
    it("should generate sizeof for type", () => {
      const source = `
        u32 size <- sizeof(u32);
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("sizeof(uint32_t)");
    });

    it("should generate sizeof for struct", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        u32 size <- sizeof(Point);
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("sizeof(Point)");
    });
  });

  describe("Array length", () => {
    it("should generate array length using sizeof", () => {
      const source = `
        u32 data[10];
        u32 len <- data.length;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // .length compiles to sizeof(arr)/sizeof(arr[0]) or constant
      expect(code).toContain("len =");
    });
  });

  describe("Hex and binary literals", () => {
    it("should generate hex literal", () => {
      const source = `u32 mask <- 0xFF00;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("0xFF00");
    });

    it("should generate binary literal", () => {
      const source = `u8 pattern <- 0b10101010;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Binary literals are preserved or converted
      expect(code).toContain("pattern =");
    });
  });

  describe("Character literal", () => {
    it("should generate character literal", () => {
      const source = `u8 ch <- 'A';`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("'A'");
    });
  });

  describe("Scope with multiple functions", () => {
    it("should generate scoped functions with prefix", () => {
      const source = `
        scope Motor {
          public void start() { }
          public void stop() { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("void Motor_start(void)");
      expect(code).toContain("void Motor_stop(void)");
    });
  });

  describe("Scope variable access", () => {
    it("should access scope variable from inside scope", () => {
      const source = `
        scope Counter {
          u32 value <- 0;
          public void increment() {
            value <- value + 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Counter_value");
    });
  });

  describe("Modulo operator", () => {
    it("should generate modulo operation", () => {
      const source = `
        wrap u32 a <- 17;
        wrap u32 b <- 5;
        wrap u32 result <- a % b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a % b");
    });
  });

  describe("Division operator", () => {
    it("should generate division operation", () => {
      const source = `
        wrap u32 a <- 20;
        wrap u32 b <- 4;
        wrap u32 result <- a / b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a / b");
    });
  });

  describe("Compound assignment operators", () => {
    it("should generate bitwise AND compound assignment", () => {
      const source = `
        wrap u8 mask <- 0xFF;
        void main() {
          mask &<- 0x0F;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("&=");
    });

    it("should generate bitwise OR compound assignment", () => {
      const source = `
        wrap u8 flags <- 0x00;
        void main() {
          flags |<- 0x01;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("|=");
    });

    it("should generate bitwise XOR compound assignment", () => {
      const source = `
        wrap u8 bits <- 0x55;
        void main() {
          bits ^<- 0xFF;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("^=");
    });

    it("should generate left shift compound assignment", () => {
      const source = `
        wrap u8 val <- 1;
        void main() {
          val <<<- 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("<<=");
    });

    it("should generate right shift compound assignment", () => {
      const source = `
        wrap u8 val <- 0x80;
        void main() {
          val >><- 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain(">>=");
    });

    it("should generate multiply compound assignment", () => {
      const source = `
        wrap u32 val <- 5;
        void main() {
          val *<- 3;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("*=");
    });

    it("should generate divide compound assignment", () => {
      const source = `
        wrap u32 val <- 20;
        void main() {
          val /<- 4;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("/=");
    });

    it("should generate modulo compound assignment", () => {
      const source = `
        wrap u32 val <- 17;
        void main() {
          val %<- 5;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("%=");
    });
  });

  describe("Parenthesized expression", () => {
    it("should preserve parentheses in complex expression", () => {
      const source = `
        wrap u32 a <- 2;
        wrap u32 b <- 3;
        wrap u32 c <- 4;
        wrap u32 result <- (a + b) * c;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("(a + b) * c");
    });
  });

  describe("Function call with arguments", () => {
    it("should generate function call with multiple arguments", () => {
      const source = `
        u32 add(u32 a, u32 b) {
          return a + b;
        }
        u32 result <- add(10, 20);
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("add(10, 20)");
    });
  });

  describe("Return enum value", () => {
    it("should return enum value from function", () => {
      const source = `
        enum Status { OK, ERROR }
        Status getStatus() {
          return Status.OK;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("return Status_OK");
    });
  });

  describe("Array passed to function", () => {
    it("should pass array without address-of operator", () => {
      const source = `
        void processData(u32 data[]) { }
        u32 myData[5];
        void main() {
          processData(myData);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Arrays decay to pointers, no & needed
      expect(code).toContain("processData(myData)");
    });
  });

  describe("Struct with array member", () => {
    it("should generate struct with array field", () => {
      const source = `
        struct Buffer {
          u8 data[64];
          u32 length;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint8_t data[64]");
    });
  });

  describe("Global reference from scope", () => {
    it("should access global variable with global keyword", () => {
      const source = `
        u32 globalCounter <- 0;
        scope Module {
          public void increment() {
            global.globalCounter <- global.globalCounter + 1;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // global.X should resolve to just X
      expect(code).toContain("globalCounter =");
    });
  });

  describe("String literal", () => {
    it("should generate string literal", () => {
      const source = `string<20> msg <- "Hello World";`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain('"Hello World"');
    });
  });

  describe("Integer type sizes", () => {
    it("should generate all unsigned integer types", () => {
      const source = `
        u8 a;
        u16 b;
        u32 c;
        u64 d;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint8_t a");
      expect(code).toContain("uint16_t b");
      expect(code).toContain("uint32_t c");
      expect(code).toContain("uint64_t d");
    });

    it("should generate all signed integer types", () => {
      const source = `
        i8 a;
        i16 b;
        i32 c;
        i64 d;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("int8_t a");
      expect(code).toContain("int16_t b");
      expect(code).toContain("int32_t c");
      expect(code).toContain("int64_t d");
    });
  });

  describe("Negative number literal", () => {
    it("should generate negative literal", () => {
      const source = `i32 val <- -42;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("-42");
    });
  });

  describe("Float literals", () => {
    it("should generate f32 literal with suffix", () => {
      const source = `f32 val <- 3.14;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("3.14");
    });

    it("should generate f64 literal", () => {
      const source = `f64 val <- 2.718281828;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("2.718281828");
    });
  });

  describe("Boolean literals", () => {
    it("should generate true literal", () => {
      const source = `bool flag <- true;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("true");
    });

    it("should generate false literal", () => {
      const source = `bool flag <- false;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("false");
    });
  });

  describe("Ternary expression", () => {
    it("should generate ternary with comparison condition", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        u32 max <- (a > b) ? a : b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("(a > b) ? a : b");
    });
  });

  describe("Bit indexing read", () => {
    it("should generate bit read with single index", () => {
      const source = `
        u8 flags <- 0xFF;
        bool bit0 <- flags[0, 1] = 1;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Bit extraction generates shift and mask
      expect(code).toContain("flags");
      expect(code).toContain("&");
    });

    it("should generate multi-bit read", () => {
      const source = `
        u8 data <- 0xAB;
        u8 nibble <- data[4, 4];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain(">> 4");
    });
  });

  describe("Error - this outside scope", () => {
    it("should throw error for this keyword outside scope", () => {
      const source = `
        void main() {
          this.foo <- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow("'this' can only be used inside a scope");
    });
  });

  describe("Const assignment error", () => {
    it("should throw error when assigning to const variable", () => {
      const source = `
        const u32 MAX <- 100;
        void main() {
          MAX <- 200;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow("const");
    });
  });

  describe("Private scope member access error", () => {
    it("should throw error when accessing private member from outside", () => {
      const source = `
        scope Motor {
          u32 internalState <- 0;
        }
        void main() {
          Motor.internalState <- 5;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/private|not public|visibility/i);
    });
  });

  describe("Enum with explicit values", () => {
    it("should generate enum with explicit numeric values", () => {
      const source = `
        enum Priority {
          LOW <- 1,
          MEDIUM <- 5,
          HIGH <- 10
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Priority_LOW = 1");
      expect(code).toContain("Priority_HIGH = 10");
    });
  });

  describe("Struct member initializer", () => {
    it("should generate designated initializer", () => {
      const source = `
        struct Vec3 { i32 x; i32 y; i32 z; }
        Vec3 pos <- {x: 1, y: 2, z: 3};
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain(".x = 1");
      expect(code).toContain(".y = 2");
      expect(code).toContain(".z = 3");
    });
  });

  describe("Array bounds checking", () => {
    it("should throw error for out-of-bounds constant index", () => {
      const source = `
        u32 data[5];
        void main() {
          data[10] <- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      expect(() =>
        generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        }),
      ).toThrow(/bound|index|out of range/i);
    });
  });

  describe("Local variable tracking", () => {
    it("should track local variables in function scope", () => {
      const source = `
        void compute() {
          wrap u32 local <- 0;
          local <- local + 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t local = 0");
      expect(code).toContain("local = local + 1");
    });
  });

  describe("Struct parameter as pointer", () => {
    it("should use arrow notation for struct parameter member access", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        void moveRight(Point p) {
          p.x <- p.x + 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Struct parameters become pointers, access uses ->
      expect(code).toContain("p->");
    });
  });

  describe("Multiple struct parameters", () => {
    it("should handle multiple struct parameters", () => {
      const source = `
        struct Point { i32 x; i32 y; }
        void add(Point a, Point b) {
          a.x <- a.x + b.x;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a->x");
      expect(code).toContain("b->x");
    });
  });

  describe("Extern const in header mode", () => {
    it("should add extern for const at file scope", () => {
      const source = `const u32 VERSION <- 1;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("extern const uint32_t VERSION");
    });
  });

  describe("Empty function body", () => {
    it("should generate function with empty body", () => {
      const source = `void noop() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("void noop(void)");
    });
  });

  describe("Function returning bool", () => {
    it("should generate bool return type", () => {
      const source = `
        bool isPositive(i32 x) {
          return x > 0;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("bool isPositive");
      expect(code).toContain("return x > 0");
    });
  });

  describe("Scope enum usage", () => {
    it("should use scoped enum from same scope", () => {
      const source = `
        scope State {
          enum Mode { OFF, ON }
          this.Mode current <- this.Mode.OFF;
          public void turnOn() {
            current <- Mode.ON;
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("State_Mode_ON");
    });
  });

  describe("Bitmap declaration", () => {
    it("should generate bitmap typedef", () => {
      const source = `
        bitmap8 Flags {
          enabled,
          running,
          error,
          reserved[5]
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef uint8_t Flags");
    });
  });

  describe("Sizeof variable", () => {
    it("should generate sizeof for variable", () => {
      const source = `
        u32 arr[10];
        u32 size <- sizeof(arr);
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("sizeof(arr)");
    });
  });

  describe("Const array size at file scope", () => {
    it("should resolve const to literal for file-scope array", () => {
      const source = `
        const u32 BUFFER_SIZE <- 256;
        u8 buffer[BUFFER_SIZE];
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // File scope arrays need literal sizes in C
      expect(code).toContain("buffer[256]");
    });
  });

  describe("Function with array return type simulation", () => {
    it("should handle function returning via output parameter", () => {
      const source = `
        void getData(u8 output[]) {
          output[0] <- 1;
          output[1] <- 2;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("output[0]");
      expect(code).toContain("output[1]");
    });
  });

  describe("Mixed arithmetic operations", () => {
    it("should handle mixed add and subtract", () => {
      const source = `
        wrap u32 a <- 10;
        wrap u32 b <- 5;
        wrap u32 c <- 3;
        wrap u32 result <- a + b - c;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a + b - c");
    });
  });

  describe("Complex nested expression", () => {
    it("should handle deeply nested expression", () => {
      const source = `
        wrap u32 a <- 2;
        wrap u32 b <- 3;
        wrap u32 c <- 4;
        wrap u32 d <- 5;
        wrap u32 result <- ((a + b) * c) - d;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("((a + b) * c) - d");
    });
  });

  describe("Float operations", () => {
    it("should generate float addition", () => {
      const source = `
        f32 a <- 1.5;
        f32 b <- 2.5;
        f32 sum <- a + b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a + b");
    });

    it("should generate float comparison", () => {
      const source = `
        f32 a <- 1.5;
        f32 b <- 2.5;
        bool less <- a < b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a < b");
    });
  });

  describe("Struct array field", () => {
    it("should generate struct with array field access", () => {
      const source = `
        struct Message {
          u8 data[8];
          u8 length;
        }
        Message msg;
        void main() {
          msg.data[0] <- 0x01;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("msg.data[0] = 0x01");
    });
  });

  describe("Enum comparison", () => {
    it("should generate enum equality comparison", () => {
      const source = `
        enum State { IDLE, RUNNING }
        State current <- State.IDLE;
        void main() {
          if (current = State.RUNNING) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // = becomes == in C
      expect(code).toContain("current == State_RUNNING");
    });
  });

  describe("Switch with enum", () => {
    it("should generate switch on enum value", () => {
      const source = `
        enum State { IDLE, RUNNING, ERROR }
        State s <- State.IDLE;
        u32 code <- 0;
        void main() {
          switch (s) {
            case State.IDLE { code <- 1; }
            case State.RUNNING { code <- 2; }
            case State.ERROR { code <- 3; }
          }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("case State_IDLE:");
      expect(code).toContain("case State_RUNNING:");
    });
  });

  describe("Nested struct", () => {
    it("should generate nested struct declaration", () => {
      const source = `
        struct Inner {
          i32 value;
        }
        struct Outer {
          Inner a;
          Inner b;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Inner a");
      expect(code).toContain("Inner b");
    });
  });

  describe("Const local variable", () => {
    it("should track const for array size in function", () => {
      const source = `
        void setup() {
          const u32 SIZE <- 5;
          u32 data[SIZE];
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("SIZE");
      expect(code).toContain("[SIZE]");
    });
  });

  describe("Bit write operation", () => {
    it("should generate bit write assignment", () => {
      const source = `
        u8 flags <- 0;
        void main() {
          flags[0, 1] <- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Bit write generates mask and OR operations
      expect(code).toContain("flags");
      expect(code).toContain("|");
    });
  });

  describe("Long hex literal", () => {
    it("should generate 64-bit hex literal", () => {
      const source = `u64 big <- 0xFFFFFFFFFFFFFFFF;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // 64-bit hex should have ULL suffix or correct literal
      expect(code).toContain("0xFFFFFFFFFFFFFFFF");
    });
  });

  describe("Multiple return statements", () => {
    it("should generate function with early return", () => {
      const source = `
        u32 safeDivide(u32 a, u32 b) {
          if (b = 0) {
            return 0;
          }
          return a / b;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("return 0");
      expect(code).toContain("return a / b");
    });
  });

  describe("Scope struct member", () => {
    it("should access struct through scope", () => {
      const source = `
        struct Config { u32 value; }
        scope Settings {
          public Config cfg;
        }
        void main() {
          Settings.cfg.value <- 200;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Settings_cfg");
    });
  });

  describe("Array parameter bounds", () => {
    it("should handle sized array parameter", () => {
      const source = `
        void process(u32 arr[10]) {
          arr[0] <- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Array params become pointers
      expect(code).toContain("arr[0] = 1");
    });
  });

  describe("Escape sequences in strings", () => {
    it("should preserve escape sequences", () => {
      const source = `string<10> newline <- "\\n";`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("\\n");
    });
  });

  describe("Clamp overflow helper", () => {
    it("should generate clamp add helper for u16", () => {
      const source = `
        clamp u16 val <- 65000;
        void main() {
          val +<- 1000;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should include clamp helper
      expect(code).toContain("cnx_clamp");
    });

    it("should generate clamp sub helper for u16", () => {
      const source = `
        clamp u16 val <- 100;
        void main() {
          val -<- 200;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Should include clamp sub helper
      expect(code).toContain("cnx_clamp_sub");
    });
  });

  describe("Multiple enum declarations", () => {
    it("should handle multiple enums", () => {
      const source = `
        enum Color { RED, GREEN, BLUE }
        enum Size { SMALL, MEDIUM, LARGE }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("typedef enum");
      expect(code).toContain("Color_RED");
      expect(code).toContain("Size_SMALL");
    });
  });

  describe("Comparison chaining prevention", () => {
    it("should generate single comparison", () => {
      const source = `
        u32 a <- 5;
        u32 b <- 10;
        bool result <- a < b;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("a < b");
    });
  });

  describe("Empty scope", () => {
    it("should generate empty scope with comment", () => {
      const source = `
        scope Empty { }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Empty");
    });
  });

  describe("Qualified type access", () => {
    it("should access type from other scope", () => {
      const source = `
        scope Types {
          public enum Mode { AUTO, MANUAL }
        }
        Types.Mode selected <- Types.Mode.AUTO;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Types_Mode");
    });
  });

  describe("Clamp operations for i32", () => {
    it("should generate clamp add for signed type", () => {
      const source = `
        clamp i32 val <- 2000000000;
        void main() {
          val +<- 500000000;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("cnx_clamp");
    });
  });

  describe("Function with const parameter", () => {
    it("should handle const parameter modifier", () => {
      const source = `
        void readOnly(const u32 val) {
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("const");
    });
  });

  describe("Equality operator translation", () => {
    it("should convert = to == for equality", () => {
      const source = `
        u32 x <- 5;
        void main() {
          if (x = 5) { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("x == 5");
    });
  });

  describe("Signed integer operations", () => {
    it("should generate signed arithmetic", () => {
      const source = `
        i32 a <- -10;
        i32 b <- 20;
        i32 diff <- b - a;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("int32_t a = -10");
      expect(code).toContain("b - a");
    });
  });

  describe("Void function call", () => {
    it("should call void function as statement", () => {
      const source = `
        void doWork() { }
        void main() {
          doWork();
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("doWork();");
    });
  });

  describe("Multiple scopes", () => {
    it("should handle multiple scope declarations", () => {
      const source = `
        scope ScopeA {
          public void methodA() { }
        }
        scope ScopeB {
          public void methodB() { }
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("ScopeA_methodA");
      expect(code).toContain("ScopeB_methodB");
    });
  });

  describe("Struct self-assignment prevention", () => {
    it("should detect self-reference in scope", () => {
      const source = `
        scope Motor {
          public u32 speed <- 100;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Motor_speed = 100");
    });
  });

  describe("Wrap modifier for u64", () => {
    it("should generate wrap arithmetic for u64", () => {
      const source = `
        wrap u64 big <- 0xFFFFFFFFFFFFFFFF;
        void main() {
          big +<- 1;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Wrap uses direct operators, no clamp helper
      expect(code).toContain("+=");
    });
  });

  describe("Signed clamp operations", () => {
    it("should generate signed clamp helpers", () => {
      const source = `
        clamp i8 tiny <- -100;
        void main() {
          tiny -<- 50;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("cnx_clamp");
    });
  });

  describe("Array with literal size", () => {
    it("should generate array with integer literal size", () => {
      const source = `u32 buffer[100];`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint32_t buffer[100]");
    });
  });

  describe("Struct field types", () => {
    it("should handle various field types", () => {
      const source = `
        struct Mixed {
          u8 byte;
          u16 word;
          u32 dword;
          u64 qword;
          bool flag;
          f32 single;
          f64 double_;
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("uint8_t byte");
      expect(code).toContain("uint16_t word");
      expect(code).toContain("uint32_t dword");
      expect(code).toContain("uint64_t qword");
      expect(code).toContain("bool flag");
      expect(code).toContain("float single");
      expect(code).toContain("double double_");
    });
  });

  describe("Prefix operations in expressions", () => {
    it("should handle prefix negation in assignment", () => {
      const source = `
        i32 a <- 5;
        i32 b <- -a;
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("-a");
    });
  });

  describe("Comment preservation", () => {
    it("should include generated file header", () => {
      const source = `void main() { }`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("Generated by C-Next Transpiler");
    });
  });

  describe("Stdint include", () => {
    it("should include stdint.h for fixed-width types", () => {
      const source = `u32 val <- 0;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("#include <stdint.h>");
    });
  });

  describe("Stdbool include", () => {
    it("should include stdbool.h for bool type", () => {
      const source = `bool flag <- false;`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("#include <stdbool.h>");
    });
  });

  describe("Array initialization with values", () => {
    it("should generate array with initialization list", () => {
      const source = `u8 data[4] <- [1, 2, 3, 4];`;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      expect(code).toContain("{1, 2, 3, 4}");
    });
  });

  describe("Local array tracking", () => {
    it("should track local arrays for function arguments", () => {
      const source = `
        void process(u8 arr[]) { }
        void main() {
          u8 local[10];
          process(local);
        }
      `;
      const { tree, tokenStream } = CNextSourceParser.parse(source);
      const generator = new CodeGenerator();
      const symbolTable = new SymbolTable();
      const tSymbols = CNextResolver.resolve(tree, "test.cnx");
      const symbols = TSymbolInfoAdapter.convert(tSymbols);

      const code = generator.generate(tree, symbolTable, tokenStream, {
        symbolInfo: symbols,
        sourcePath: "test.cnx",
      });

      // Local arrays don't need & prefix when passed
      expect(code).toContain("process(local)");
    });
  });

  describe("Zero initializer helpers", () => {
    describe("primitive type zero values", () => {
      it("should initialize bool to false", () => {
        const source = `
          void main() {
            bool flag;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("bool flag = false");
      });

      it("should initialize f32 to 0.0f", () => {
        const source = `
          void main() {
            f32 value;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("float value = 0.0f");
      });

      it("should initialize f64 to 0.0", () => {
        const source = `
          void main() {
            f64 value;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("double value = 0.0");
      });

      it("should initialize integer types to 0", () => {
        const source = `
          void main() {
            u32 value;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("uint32_t value = 0");
      });
    });

    describe("enum zero values", () => {
      it("should initialize user-defined enum to first member", () => {
        const source = `
          enum Color { Red, Green, Blue }
          void main() {
            Color c;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Color c = Color_Red");
      });

      it("should initialize scoped enum to first member", () => {
        const source = `
          scope LED {
            enum State { Off, On }
            public void init() {
              this.State s;
            }
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("LED_State s = LED_State_Off");
      });

      it("should initialize qualified enum to first member", () => {
        const source = `
          scope Motor {
            public enum Direction { Forward, Reverse }
          }
          void main() {
            Motor.Direction d;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Motor_Direction d = Motor_Direction_Forward");
      });

      it("should find enum member with explicit value 0", () => {
        const source = `
          enum Status { Unknown <- 1, Success <- 0, Error <- 2 }
          void main() {
            Status s;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        // Should find Success which has explicit value 0
        expect(code).toContain("Status s = Status_Success");
      });
    });

    describe("struct zero values", () => {
      it("should initialize user-defined struct to {0}", () => {
        const source = `
          struct Point { i32 x; i32 y; }
          void main() {
            Point p;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Point p = {0}");
      });

      it("should initialize scoped struct to {0}", () => {
        const source = `
          scope Sensor {
            struct Data { i32 value; }
            public void read() {
              this.Data d;
            }
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Sensor_Data d = {0}");
      });

      it("should initialize qualified struct to {0}", () => {
        const source = `
          scope Config {
            public struct Settings { i32 level; }
          }
          void main() {
            Config.Settings cfg;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Config_Settings cfg = {0}");
      });
    });

    describe("array zero values", () => {
      it("should initialize POD arrays to {0}", () => {
        const source = `
          void main() {
            u32 values[10];
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("uint32_t values[10] = {0}");
      });

      it("should initialize struct arrays to {0}", () => {
        const source = `
          struct Point { i32 x; i32 y; }
          void main() {
            Point points[5];
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
        });

        expect(code).toContain("Point points[5] = {0}");
      });
    });

    describe("C++ mode initialization", () => {
      it("should initialize unknown user types to {} in C++ mode", () => {
        const source = `
          void main() {
            ExternalClass obj;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
          cppMode: true,
        });

        // Unknown types in C++ mode use {} because they may have non-trivial constructors
        expect(code).toContain("ExternalClass obj = {}");
      });

      it("should initialize known structs to {0} even in C++ mode", () => {
        const source = `
          struct Point { i32 x; i32 y; }
          void main() {
            Point p;
          }
        `;
        const { tree, tokenStream } = CNextSourceParser.parse(source);
        const generator = new CodeGenerator();
        const symbolTable = new SymbolTable();
        const tSymbols = CNextResolver.resolve(tree, "test.cnx");
        const symbols = TSymbolInfoAdapter.convert(tSymbols);

        const code = generator.generate(tree, symbolTable, tokenStream, {
          symbolInfo: symbols,
          sourcePath: "test.cnx",
          cppMode: true,
        });

        // Known C-Next structs are POD types, {0} works fine
        expect(code).toContain("Point p = {0}");
      });

      // Note: Template type tests skipped - template argument transformation
      // (i32 -> int32_t) is a separate issue to be addressed in another PR
    });
  });
});
