/**
 * Generated by C-Next Transpiler from: float-bit-union-punning.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

_Static_assert(sizeof(float) == 4, "Float bit indexing requires 32-bit float");
_Static_assert(sizeof(double) == 8, "Float bit indexing requires 64-bit double");

// test-execution
// Test that float bit access uses union-based type punning for MISRA 21.15 compliance
// MISRA Rule 21.15 forbids memcpy between incompatible pointer types (float* and uint32_t*)
int main(void) {
    float testVal = 1.0;
    union { float f; uint32_t u; } __bits_testVal;
    __bits_testVal.f = testVal;
    uint8_t byte3 = ((__bits_testVal.u >> 24U) & 0xFFU);
    if (byte3 != 0x3F) return 1;
    float result = 0.0;
    union { float f; uint32_t u; } __bits_result;
    __bits_result.f = result;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 24)) | (((uint32_t)0x3F & 0xFFU) << 24);
    result = __bits_result.f;
    __bits_result.u = (__bits_result.u & ~(0xFFU << 16)) | (((uint32_t)0x80 & 0xFFU) << 16);
    result = __bits_result.f;
    if (result != 1.0) return 2;
    double testDouble = 1.0;
    union { double f; uint64_t u; } __bits_testDouble;
    __bits_testDouble.f = testDouble;
    uint8_t highByte = ((__bits_testDouble.u >> 56U) & 0xFFULL);
    if (highByte != 0x3F) return 3;
    return 0;
}
