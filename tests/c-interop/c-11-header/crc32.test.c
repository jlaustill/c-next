/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// crc32.cnx - Memory-safe CRC32 using c-next's bounded strings
// Ported from ConfigStorage.cpp with safer serialization
#include "AppConfig.h"

#include <stdint.h>
#include <string.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {
    if (a > UINT32_MAX - b) return UINT32_MAX;
    return a + b;
}

// Calculate CRC32 checksum over AppConfig struct (excluding checksum field)
// Uses explicit field serialization instead of raw memory access
uint32_t calculateChecksum(const AppConfig* config) {
    char buffer[513] = "";
    uint32_t offset = 0;
    uint8_t length = 0;
    length = 0 / 8;
    buffer[offset] = (*config).magic;
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    buffer[offset] = (*config).version;
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    buffer[offset] = (*config).j1939SourceAddress;
    offset = cnx_clamp_add_u32(offset, length);
    for (uint32_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
        length = 0 / 8;
        buffer[offset] = (((*config).tempInputs >> i) & 1).assignedSpn;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).tempInputs >> i) & 1).coeffA;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).tempInputs >> i) & 1).coeffB;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).tempInputs >> i) & 1).coeffC;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).tempInputs >> i) & 1).resistorValue;
        offset = cnx_clamp_add_u32(offset, length);
    }
    for (uint32_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
        length = 0 / 8;
        buffer[offset] = (((*config).pressureInputs >> i) & 1).assignedSpn;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).pressureInputs >> i) & 1).maxPressure;
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        buffer[offset] = (((*config).pressureInputs >> i) & 1).pressureType;
        offset = cnx_clamp_add_u32(offset, length);
    }
    length = 0 / 8;
    buffer[offset] = (*config).egtEnabled;
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    buffer[offset] = (*config).thermocoupleType;
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    buffer[offset] = (*config).bme280Enabled;
    offset = cnx_clamp_add_u32(offset, length);
    uint32_t crc = 0xFFFFFFFF;
    for (uint32_t i = 0; i < offset; i += 1) {
        crc = crc ^ buffer[i];
        for (int32_t j = 0; j < 8; j += 1) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc = crc >> 1;
            }
        }
    }
    return ~crc;
}
