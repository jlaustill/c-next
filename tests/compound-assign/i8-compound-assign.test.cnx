// test-execution
// Tests: i8 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: -128 to 127
u32 main() {
    // ===== ADDITION (+<-) =====
    i8 val <- 50;
    val +<- 25; // pos + pos
    if (val != 75) return 1;

    val <- -50;
    val +<- 25; // neg + pos
    if (val != -25) return 2;

    val <- -50;
    val +<- -25; // neg + neg
    if (val != -75) return 3;

    val <- 100;
    val +<- 0; // Identity: add zero
    if (val != 100) return 4;

    val <- -100;
    val +<- 100; // Cross zero
    if (val != 0) return 5;

    val <- 126;
    val +<- 1; // Near max
    if (val != 127) return 6;

    // ===== SUBTRACTION (-<-) =====
    i8 sub <- 75;
    sub -<- 25; // pos - pos = pos
    if (sub != 50) return 10;

    sub <- 25;
    sub -<- 75; // pos - pos = neg
    if (sub != -50) return 11;

    sub <- -50;
    sub -<- 25; // neg - pos
    if (sub != -75) return 12;

    sub <- -50;
    sub -<- -25; // neg - neg
    if (sub != -25) return 13;

    sub <- 100;
    sub -<- 0; // Identity: subtract zero
    if (sub != 100) return 14;

    sub <- -127;
    sub -<- 1; // Near min
    if (sub != -128) return 15;

    // ===== MULTIPLICATION (*<-) =====
    i8 mul <- 10;
    mul *<- 10; // pos * pos = 100
    if (mul != 100) return 20;

    mul <- -10;
    mul *<- 10; // neg * pos
    if (mul != -100) return 21;

    mul <- -10;
    mul *<- -10; // neg * neg = pos
    if (mul != 100) return 22;

    mul <- 50;
    mul *<- 1; // Identity: multiply by one
    if (mul != 50) return 23;

    mul <- 50;
    mul *<- -1; // Negate
    if (mul != -50) return 24;

    mul <- 100;
    mul *<- 0; // Multiply by zero
    if (mul != 0) return 25;

    // ===== DIVISION (/<-) =====
    i8 div <- 100;
    div /<- 10; // pos / pos
    if (div != 10) return 30;

    div <- -100;
    div /<- 10; // neg / pos
    if (div != -10) return 31;

    div <- -100;
    div /<- -10; // neg / neg
    if (div != 10) return 32;

    div <- 50;
    div /<- 1; // Identity: divide by one
    if (div != 50) return 33;

    div <- -50;
    div /<- -1; // neg / neg = pos
    if (div != 50) return 34;

    div <- 127;
    div /<- 127; // Max / max = 1
    if (div != 1) return 35;

    // ===== MODULO (%<-) =====
    i8 mod <- 107;
    mod %<- 10; // pos % pos
    if (mod != 7) return 40;

    mod <- -107;
    mod %<- 10; // neg % pos (C semantics: sign of dividend)
    if (mod != -7) return 41;

    mod <- 17;
    mod %<- 5; // 17 % 5 = 2
    if (mod != 2) return 42;

    mod <- 100;
    mod %<- 100; // Result zero
    if (mod != 0) return 43;

    mod <- -128;
    mod %<- 127; // Min % (max) = -1
    if (mod != -1) return 44;

    // ===== BITWISE AND (&<-) =====
    i8 and <- 0x7F; // Max positive (127)
    and &<- 0x0F; // Keep low nibble
    if (and != 0x0F) return 50;

    and <- -1; // 0xFF in two's complement
    and &<- 0x0F; // Keep low nibble
    if (and != 0x0F) return 51;

    and <- 0x55;
    and &<- 0xAA; // Non-overlapping
    if (and != 0) return 52;

    and <- 0x7F;
    and &<- 0x7F; // Self AND
    if (and != 0x7F) return 53;

    // ===== BITWISE OR (|<-) =====
    i8 or <- 0x0F;
    or |<- 0x70; // Combine nibbles (keeping sign clear)
    if (or != 0x7F) return 60;

    or <- 0x12;
    or |<- 0x00; // OR with zero = identity
    if (or != 0x12) return 61;

    or <- 0x55;
    or |<- 0x2A; // 0x55 | 0x2A = 0x7F
    if (or != 0x7F) return 62;

    // ===== BITWISE XOR (^<-) =====
    i8 xor <- 0x55;
    xor ^<- 0x55; // XOR with self = 0
    if (xor != 0) return 70;

    xor <- 0x0F;
    xor ^<- 0x70; // 0x0F ^ 0x70 = 0x7F
    if (xor != 0x7F) return 71;

    xor <- -1;
    xor ^<- -1; // -1 XOR -1 = 0
    if (xor != 0) return 72;

    xor <- 0x55;
    xor ^<- 0x2A; // 0x55 ^ 0x2A = 0x7F
    if (xor != 0x7F) return 73;

    // ===== LEFT SHIFT (<<<-) =====
    i8 shl <- 1;
    shl <<<- 0; // Shift by 0 = identity
    if (shl != 1) return 80;

    shl <- 1;
    shl <<<- 1; // 1 << 1 = 2
    if (shl != 2) return 81;

    shl <- 1;
    shl <<<- 4; // 1 << 4 = 16
    if (shl != 16) return 82;

    shl <- 1;
    shl <<<- 6; // 1 << 6 = 64 (max safe positive for i8)
    if (shl != 64) return 83;

    shl <- -1;
    shl <<<- 2; // -1 << 2 = -4
    if (shl != -4) return 84;

    // ===== RIGHT SHIFT (>><-) =====
    i8 shr <- 64;
    shr >><- 0; // Shift by 0 = identity
    if (shr != 64) return 90;

    shr <- 64;
    shr >><- 1; // 64 >> 1 = 32
    if (shr != 32) return 91;

    shr <- 64;
    shr >><- 6; // 64 >> 6 = 1
    if (shr != 1) return 92;

    shr <- -8;
    shr >><- 2; // -8 >> 2 = -2 (arithmetic shift)
    if (shr != -2) return 93;

    shr <- -1;
    shr >><- 4; // -1 >> 4 = -1 (sign extends)
    if (shr != -1) return 94;

    return 0;
}
