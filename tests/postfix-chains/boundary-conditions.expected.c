/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// Postfix Chain Test: Boundary Conditions
// Tests: Edge cases at type boundaries, max indices, etc.
typedef struct {
    uint8_t byte;
    uint16_t word;
    uint32_t dword;
    uint64_t qword;
} Data;

Data items[16] = {0};

// Max reasonable array size for testing
int main(void) {
    items[0].byte = 0xFF;
    items[0].byte = (items[0].byte & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    items[0].byte = (items[0].byte & ~(1 << 7)) | ((false ? 1 : 0) << 7);
    bool b0 = ((items[0].byte >> 0) & 1);
    bool b7 = ((items[0].byte >> 7) & 1);
    items[0].word = 0xFFFF;
    items[0].word = (items[0].word & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    items[0].word = (items[0].word & ~(1 << 15)) | ((false ? 1 : 0) << 15);
    bool w0 = ((items[0].word >> 0) & 1);
    bool w15 = ((items[0].word >> 15) & 1);
    items[0].dword = 0xFFFFFFFF;
    items[0].dword = (items[0].dword & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    items[0].dword = (items[0].dword & ~(1 << 31)) | ((false ? 1 : 0) << 31);
    bool d0 = ((items[0].dword >> 0) & 1);
    bool d31 = ((items[0].dword >> 31) & 1);
    items[0].qword = 0xFFFFFFFFFFFFFFFF;
    items[0].qword = (items[0].qword & ~(1ULL << 0)) | ((true ? 1ULL : 0) << 0);
    items[0].qword = (items[0].qword & ~(1ULL << 63)) | ((false ? 1ULL : 0) << 63);
    bool q0 = ((items[0].qword >> 0) & 1);
    bool q63 = ((items[0].qword >> 63) & 1);
    items[15].byte = 0xAA;
    uint8_t lastByte = items[15].byte;
    uint8_t test8 = 0;
    test8 = (test8 & ~(0xFFU << 0)) | ((0xFF & 0xFFU) << 0);
    uint8_t all8 = ((test8) & 0xFFU);
    uint16_t test16 = 0;
    test16 = (test16 & ~(0xFFFFU << 0)) | ((0xFFFF & 0xFFFFU) << 0);
    uint16_t all16 = ((test16) & 0xFFFFU);
    uint32_t test32 = 0;
    test32 = (test32 & ~(0xFFFFFFFFU << 0)) | ((0xFFFFFFFF & 0xFFFFFFFFU) << 0);
    uint32_t all32 = ((test32) & 0xFFFFFFFFU);
    uint32_t maxBitTest = 0;
    maxBitTest = (maxBitTest & ~(1 << 31)) | ((true ? 1 : 0) << 31);
    bool maxBit = ((maxBitTest >> 31) & 1);
    items[15].dword = 0xFFFFFFFF;
    items[15].dword = (items[15].dword & ~(1 << 31)) | ((false ? 1 : 0) << 31);
    bool complexMax = ((items[15].dword >> 31) & 1);
    items[0].byte = (items[0].byte & ~(1 << 0)) | ((true ? 1 : 0) << 0);
    bool zeroIdx = ((items[0].byte >> 0) & 1);
    uint8_t consecutive = 0xFF;
    consecutive = (consecutive & ~(1 << 0)) | ((false ? 1 : 0) << 0);
    consecutive = (consecutive & ~(1 << 1)) | ((false ? 1 : 0) << 1);
    consecutive = (consecutive & ~(1 << 2)) | ((false ? 1 : 0) << 2);
    consecutive = (consecutive & ~(1 << 3)) | ((false ? 1 : 0) << 3);
    consecutive = (consecutive & ~(1 << 4)) | ((false ? 1 : 0) << 4);
    consecutive = (consecutive & ~(1 << 5)) | ((false ? 1 : 0) << 5);
    consecutive = (consecutive & ~(1 << 6)) | ((false ? 1 : 0) << 6);
    consecutive = (consecutive & ~(1 << 7)) | ((false ? 1 : 0) << 7);
    bool c0 = ((consecutive >> 0) & 1);
    bool c1 = ((consecutive >> 1) & 1);
    bool c2 = ((consecutive >> 2) & 1);
    bool c3 = ((consecutive >> 3) & 1);
    bool c4 = ((consecutive >> 4) & 1);
    bool c5 = ((consecutive >> 5) & 1);
    bool c6 = ((consecutive >> 6) & 1);
    bool c7 = ((consecutive >> 7) & 1);
}
