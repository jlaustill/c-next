/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// test-execution
// Tests: Multiple sequential slice assignments to same buffer
// Validates non-overlapping regions with compile-time constant offsets
// Simulates real-world buffer building with explicit layout
int main(void) {
    uint8_t buffer[256] = {0};
    uint32_t magic = 0x50415255U;
    memcpy(&buffer[0], &magic, 4);
    uint16_t version = 0x0100U;
    memcpy(&buffer[4], &version, 2);
    uint16_t length = 20U;
    memcpy(&buffer[6], &length, 2);
    uint8_t flags = 0x0FU;
    memcpy(&buffer[8], &flags, 1);
    uint8_t reserved = 0U;
    memcpy(&buffer[9], &reserved, 1);
    memcpy(&buffer[10], &reserved, 1);
    memcpy(&buffer[11], &reserved, 1);
    uint64_t data = 0x0102030405060708ULL;
    memcpy(&buffer[12], &data, 8);
    if (buffer[0U] != 0x55) return 1;
    if (buffer[1U] != 0x52) return 2;
    if (buffer[2U] != 0x41) return 3;
    if (buffer[3U] != 0x50) return 4;
    if (buffer[4U] != 0x00) return 5;
    if (buffer[5U] != 0x01) return 6;
    if (buffer[6U] != 20) return 7;
    if (buffer[7U] != 0) return 8;
    if (buffer[8U] != 0x0F) return 9;
    if (buffer[9U] != 0) return 10;
    if (buffer[10U] != 0) return 11;
    if (buffer[11U] != 0) return 12;
    if (buffer[12U] != 0x08) return 13;
    if (buffer[13U] != 0x07) return 14;
    if (buffer[14U] != 0x06) return 15;
    if (buffer[15U] != 0x05) return 16;
    if (buffer[16U] != 0x04) return 17;
    if (buffer[17U] != 0x03) return 18;
    if (buffer[18U] != 0x02) return 19;
    if (buffer[19U] != 0x01) return 20;
    uint32_t newMagic = 0x44434241U;
    memcpy(&buffer[0], &newMagic, 4);
    if (buffer[0U] != 0x41) return 21;
    if (buffer[1U] != 0x42) return 22;
    if (buffer[2U] != 0x43) return 23;
    if (buffer[3U] != 0x44) return 24;
    if (buffer[4U] != 0x00) return 25;
    if (buffer[8U] != 0x0F) return 26;
    return 0;
}
