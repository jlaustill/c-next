# MISRA 10.3 Narrowing Cast Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 106 MISRA C:2012 Rule 10.3 violations by adding explicit casts to generated C code at assignment sites.

**Architecture:** Create `NarrowingCastHelper` static class that wraps expressions with casts when assigning to narrower types. Integrate at 6 assignment sites. Bool targets use `!= 0U` comparison instead of cast (MISRA 10.5).

**Tech Stack:** TypeScript, Vitest, existing `CppModeHelper.cast()` for mode-aware casting

**Design Doc:** `docs/plans/2026-02-23-misra-10.3-narrowing-casts-design.md`

---

## Task 1: Create NarrowingCastHelper with Core Logic

**Files:**

- Create: `src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts`
- Test: `src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

**Step 1: Write failing tests for needsCast()**

Create test file with basic type checking tests:

```typescript
/**
 * Unit tests for NarrowingCastHelper
 * Issue #845: MISRA C:2012 Rule 10.3 compliance
 */

import { describe, it, expect, beforeEach } from "vitest";
import NarrowingCastHelper from "../NarrowingCastHelper";
import CodeGenState from "../../../../state/CodeGenState";

describe("NarrowingCastHelper", () => {
  beforeEach(() => {
    CodeGenState.reset();
  });

  describe("needsCast", () => {
    it("returns false for same type", () => {
      expect(NarrowingCastHelper.needsCast("u32", "u32")).toBe(false);
      expect(NarrowingCastHelper.needsCast("u8", "u8")).toBe(false);
      expect(NarrowingCastHelper.needsCast("bool", "bool")).toBe(false);
    });

    it("returns false for widening (u8 -> u32)", () => {
      expect(NarrowingCastHelper.needsCast("u8", "u32")).toBe(false);
      expect(NarrowingCastHelper.needsCast("u16", "u32")).toBe(false);
      expect(NarrowingCastHelper.needsCast("i8", "i32")).toBe(false);
    });

    it("returns true for narrowing (u32 -> u8)", () => {
      expect(NarrowingCastHelper.needsCast("u32", "u8")).toBe(true);
      expect(NarrowingCastHelper.needsCast("u32", "u16")).toBe(true);
      expect(NarrowingCastHelper.needsCast("i32", "i8")).toBe(true);
    });

    it("returns true for int -> smaller unsigned (C promotion result)", () => {
      expect(NarrowingCastHelper.needsCast("int", "u8")).toBe(true);
      expect(NarrowingCastHelper.needsCast("int", "u16")).toBe(true);
      expect(NarrowingCastHelper.needsCast("int", "i8")).toBe(true);
    });

    it("returns true for int -> bool (different essential type)", () => {
      expect(NarrowingCastHelper.needsCast("int", "bool")).toBe(true);
      expect(NarrowingCastHelper.needsCast("u32", "bool")).toBe(true);
    });

    it("returns true for char literal type -> u8", () => {
      expect(NarrowingCastHelper.needsCast("int", "u8")).toBe(true);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: FAIL with "Cannot find module '../NarrowingCastHelper'"

**Step 3: Create NarrowingCastHelper with needsCast()**

```typescript
/**
 * NarrowingCastHelper - MISRA C:2012 Rule 10.3 compliance
 *
 * Issue #845: Wraps expressions with explicit casts when assigning
 * to narrower types or different essential type categories.
 *
 * C's integer promotion rules mean bit operations on u8/u16 produce int,
 * which MISRA flags when assigned back to narrower types without explicit cast.
 */

import CppModeHelper from "./CppModeHelper";
import TYPE_MAP from "../types/TYPE_MAP";

/** Bit widths for integer types (for narrowing detection) */
const TYPE_WIDTH: Record<string, number> = {
  u8: 8,
  i8: 8,
  u16: 16,
  i16: 16,
  u32: 32,
  i32: 32,
  u64: 64,
  i64: 64,
  int: 32, // C's int after promotion
  bool: 1,
};

/**
 * Helper for adding MISRA 10.3 compliant casts to generated C code.
 */
class NarrowingCastHelper {
  /**
   * Check if a cast is needed for MISRA 10.3 compliance.
   * Returns true if:
   * - Source is wider than target (narrowing)
   * - Source and target are different essential type categories
   *
   * @param sourceType - Type of the expression (C-Next type or "int" for promoted)
   * @param targetType - Type of the target variable (C-Next type)
   */
  static needsCast(sourceType: string, targetType: string): boolean {
    // Same type never needs cast
    if (sourceType === targetType) {
      return false;
    }

    // Bool target from non-bool source always needs conversion
    if (targetType === "bool" && sourceType !== "bool") {
      return true;
    }

    const sourceWidth = TYPE_WIDTH[sourceType];
    const targetWidth = TYPE_WIDTH[targetType];

    // Unknown types - be conservative, no cast
    if (sourceWidth === undefined || targetWidth === undefined) {
      return false;
    }

    // Narrowing: source wider than target
    return sourceWidth > targetWidth;
  }
}

export default NarrowingCastHelper;
```

**Step 4: Run tests to verify needsCast passes**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts \
        src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts
git commit -m "feat(codegen): add NarrowingCastHelper.needsCast() for MISRA 10.3 (#845)"
```

---

## Task 2: Add wrap() Method to NarrowingCastHelper

**Files:**

- Modify: `src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts`
- Modify: `src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

**Step 1: Add failing tests for wrap() in C mode**

Append to test file:

```typescript
describe("wrap (C mode)", () => {
  beforeEach(() => {
    CodeGenState.cppMode = false;
  });

  it("returns expression unchanged for same type", () => {
    expect(NarrowingCastHelper.wrap("x", "u32", "u32")).toBe("x");
  });

  it("returns expression unchanged for widening", () => {
    expect(NarrowingCastHelper.wrap("x", "u8", "u32")).toBe("x");
  });

  it("adds C cast for narrowing u32 -> u8", () => {
    const expr = "((value >> 0U) & 0xFFU)";
    expect(NarrowingCastHelper.wrap(expr, "u32", "u8")).toBe(
      "(uint8_t)((value >> 0U) & 0xFFU)",
    );
  });

  it("adds C cast for narrowing u32 -> u16", () => {
    const expr = "((value >> 0U) & 0xFFFFU)";
    expect(NarrowingCastHelper.wrap(expr, "u32", "u16")).toBe(
      "(uint16_t)((value >> 0U) & 0xFFFFU)",
    );
  });

  it("adds C cast for int -> u8 (C promotion result)", () => {
    const expr = "((flags >> 3) & 0x7)";
    expect(NarrowingCastHelper.wrap(expr, "int", "u8")).toBe(
      "(uint8_t)((flags >> 3) & 0x7)",
    );
  });

  it("uses != 0U comparison for bool target (MISRA 10.5)", () => {
    const expr = "((flags >> 0) & 1)";
    expect(NarrowingCastHelper.wrap(expr, "int", "bool")).toBe(
      "(((flags >> 0) & 1) != 0U)",
    );
  });

  it("adds cast for char literal to u8", () => {
    expect(NarrowingCastHelper.wrap("'A'", "int", "u8")).toBe("(uint8_t)'A'");
  });
});

describe("wrap (C++ mode)", () => {
  beforeEach(() => {
    CodeGenState.cppMode = true;
  });

  it("uses static_cast for narrowing", () => {
    const expr = "((value >> 0U) & 0xFFU)";
    expect(NarrowingCastHelper.wrap(expr, "u32", "u8")).toBe(
      "static_cast<uint8_t>(((value >> 0U) & 0xFFU))",
    );
  });

  it("uses != 0U for bool (same as C mode)", () => {
    const expr = "((flags >> 0) & 1)";
    expect(NarrowingCastHelper.wrap(expr, "int", "bool")).toBe(
      "(((flags >> 0) & 1) != 0U)",
    );
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: FAIL with "wrap is not a function" or similar

**Step 3: Implement wrap() method**

Add to NarrowingCastHelper class:

```typescript
  /**
   * Wrap expression with cast if needed for MISRA 10.3 compliance.
   *
   * @param expr - The generated C expression
   * @param sourceType - Type of the expression (C-Next type or "int")
   * @param targetType - Type of the assignment target (C-Next type)
   * @returns Expression with cast wrapper if needed, or original expression
   */
  static wrap(expr: string, sourceType: string, targetType: string): string {
    if (!NarrowingCastHelper.needsCast(sourceType, targetType)) {
      return expr;
    }

    // Bool target: use comparison instead of cast (MISRA 10.5)
    if (targetType === "bool") {
      return `((${expr}) != 0U)`;
    }

    // Get C type name for the target
    const cType = TYPE_MAP[targetType] ?? targetType;
    return CppModeHelper.cast(cType, expr);
  }
```

**Step 4: Run tests to verify wrap passes**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts \
        src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts
git commit -m "feat(codegen): add NarrowingCastHelper.wrap() for MISRA 10.3 casts (#845)"
```

---

## Task 3: Add getPromotedType() Helper

**Files:**

- Modify: `src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts`
- Modify: `src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

**Step 1: Add failing tests for getPromotedType()**

```typescript
describe("getPromotedType", () => {
  it("returns int for u8 (integer promotion)", () => {
    expect(NarrowingCastHelper.getPromotedType("u8")).toBe("int");
  });

  it("returns int for u16 (integer promotion)", () => {
    expect(NarrowingCastHelper.getPromotedType("u16")).toBe("int");
  });

  it("returns int for i8 (integer promotion)", () => {
    expect(NarrowingCastHelper.getPromotedType("i8")).toBe("int");
  });

  it("returns int for i16 (integer promotion)", () => {
    expect(NarrowingCastHelper.getPromotedType("i16")).toBe("int");
  });

  it("returns u32 unchanged (no promotion needed)", () => {
    expect(NarrowingCastHelper.getPromotedType("u32")).toBe("u32");
  });

  it("returns i32 unchanged (no promotion needed)", () => {
    expect(NarrowingCastHelper.getPromotedType("i32")).toBe("i32");
  });

  it("returns u64 unchanged", () => {
    expect(NarrowingCastHelper.getPromotedType("u64")).toBe("u64");
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: FAIL

**Step 3: Implement getPromotedType()**

Add to NarrowingCastHelper:

```typescript
  /**
   * Get the type after C integer promotion rules.
   * In C, operations on char/short/u8/u16 promote to int.
   *
   * @param type - C-Next type name
   * @returns The type after integer promotion
   */
  static getPromotedType(type: string): string {
    // Types smaller than int get promoted to int
    const smallTypes = ["u8", "i8", "u16", "i16"];
    if (smallTypes.includes(type)) {
      return "int";
    }
    return type;
  }
```

**Step 4: Run tests**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts`

Expected: PASS

**Step 5: Commit**

```bash
git add src/transpiler/output/codegen/helpers/NarrowingCastHelper.ts \
        src/transpiler/output/codegen/helpers/__tests__/NarrowingCastHelper.test.ts
git commit -m "feat(codegen): add NarrowingCastHelper.getPromotedType() (#845)"
```

---

## Task 4: Integrate with BitRangeHelper

**Files:**

- Modify: `src/transpiler/output/codegen/helpers/BitRangeHelper.ts`
- Modify: `src/transpiler/output/codegen/helpers/__tests__/BitRangeHelper.test.ts`

**Step 1: Read existing BitRangeHelper to understand interface**

Review `src/transpiler/output/codegen/helpers/BitRangeHelper.ts` and its tests.

**Step 2: Add failing test for cast-wrapped bit read**

Add to BitRangeHelper.test.ts:

```typescript
describe("buildIntegerBitReadExpr with target type", () => {
  beforeEach(() => {
    CodeGenState.reset();
    CodeGenState.cppMode = false;
  });

  it("adds cast when target type is narrower than source", () => {
    const result = BitRangeHelper.buildIntegerBitReadExpr({
      varName: "value",
      start: "0",
      mask: "0xFFU",
      sourceType: "u32",
      targetType: "u8",
    });
    expect(result).toBe("(uint8_t)((value) & 0xFFU)");
  });

  it("returns plain expression when no narrowing", () => {
    const result = BitRangeHelper.buildIntegerBitReadExpr({
      varName: "value",
      start: "8",
      mask: "0xFFFFU",
      sourceType: "u32",
      targetType: "u32",
    });
    expect(result).toBe("((value >> 8) & 0xFFFFU)");
  });
});
```

**Step 3: Run tests to verify they fail**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/BitRangeHelper.test.ts`

Expected: FAIL (interface doesn't accept sourceType/targetType yet)

**Step 4: Update BitRangeHelper interface and implementation**

Modify `IIntegerBitReadOptions` interface and `buildIntegerBitReadExpr`:

```typescript
interface IIntegerBitReadOptions {
  varName: string;
  start: string;
  mask: string;
  sourceType?: string;  // Optional: source variable type for cast detection
  targetType?: string;  // Optional: target variable type for cast
}

static buildIntegerBitReadExpr(options: IIntegerBitReadOptions): string {
  const { varName, start, mask, sourceType, targetType } = options;

  let expr: string;
  if (start === "0") {
    expr = `((${varName}) & ${mask})`;
  } else {
    expr = `((${varName} >> ${start}) & ${mask})`;
  }

  // If target type provided, wrap with MISRA cast if needed
  if (sourceType && targetType) {
    return NarrowingCastHelper.wrap(expr, sourceType, targetType);
  }

  return expr;
}
```

**Step 5: Run tests**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/BitRangeHelper.test.ts`

Expected: PASS

**Step 6: Commit**

```bash
git add src/transpiler/output/codegen/helpers/BitRangeHelper.ts \
        src/transpiler/output/codegen/helpers/__tests__/BitRangeHelper.test.ts
git commit -m "feat(codegen): integrate NarrowingCastHelper with BitRangeHelper (#845)"
```

---

## Task 5: Update ArrayAccessHelper to Pass Types

**Files:**

- Modify: `src/transpiler/output/codegen/helpers/ArrayAccessHelper.ts`
- Modify: `src/transpiler/output/codegen/helpers/__tests__/ArrayAccessHelper.test.ts`
- Modify: `src/transpiler/output/codegen/types/IArrayAccessInfo.ts`

**Step 1: Update IArrayAccessInfo to include targetType**

Add `targetType?: string` to the interface.

**Step 2: Update ArrayAccessHelper.generateIntegerBitRange()**

Pass sourceType and targetType to BitRangeHelper:

```typescript
static generateIntegerBitRange(
  info: IArrayAccessInfo,
  deps: IArrayAccessDeps,
): string {
  const mask = deps.generateBitMask(info.widthExpr ?? "0");
  return BitRangeHelper.buildIntegerBitReadExpr({
    varName: info.resolvedName,
    start: info.startExpr ?? "0",
    mask,
    sourceType: info.typeInfo?.baseType,
    targetType: info.targetType,
  });
}
```

**Step 3: Add tests verifying casts appear in output**

**Step 4: Run tests**

Run: `npm run unit -- src/transpiler/output/codegen/helpers/__tests__/ArrayAccessHelper.test.ts`

**Step 5: Commit**

```bash
git add src/transpiler/output/codegen/helpers/ArrayAccessHelper.ts \
        src/transpiler/output/codegen/helpers/__tests__/ArrayAccessHelper.test.ts \
        src/transpiler/output/codegen/types/IArrayAccessInfo.ts
git commit -m "feat(codegen): pass target type through ArrayAccessHelper for MISRA casts (#845)"
```

---

## Task 6: Update Integration Tests - Bit Indexing

**Files:**

- Regenerate: `tests/basics/bit-indexing.expected.c`
- Regenerate: `tests/basics/bit-indexing.expected.cpp`
- Regenerate: Related bit-indexing test expected files

**Step 1: Run transpiler to regenerate expected files**

```bash
npm test -- tests/basics/bit-indexing.test.cnx --update
```

**Step 2: Verify casts appear in generated output**

Check that `bit-indexing.expected.c` now contains:

- `(uint8_t)((value >> 0U) & 0xFFU)`
- `(uint16_t)((value >> 0U) & 0xFFFFU)`

**Step 3: Run MISRA validation on regenerated file**

```bash
cppcheck --addon=misra tests/basics/bit-indexing.test.c 2>&1 | grep "10.3"
```

Expected: No 10.3 violations for this file

**Step 4: Commit**

```bash
git add tests/basics/bit-indexing.expected.c tests/basics/bit-indexing.expected.cpp \
        tests/basics/bit-indexing.test.c tests/basics/bit-indexing.test.cpp
git commit -m "test: regenerate bit-indexing expected files with MISRA casts (#845)"
```

---

## Task 7: Handle Bool Assignments from Bitmap Fields

**Files:**

- Modify: `src/transpiler/output/codegen/assignment/handlers/BitmapHandlers.ts` (if exists)
- Or modify the relevant bitmap field read generator

**Step 1: Find where bitmap field reads are generated**

Search for `((flags >> n) & 1)` generation pattern.

**Step 2: Add MISRA cast wrapper for bool targets**

When generating single-bit bitmap field reads assigned to bool:

- Current: `((flags >> 0) & 1)`
- After: `(((flags >> 0) & 1) != 0U)`

**Step 3: Update tests**

**Step 4: Regenerate bitmap expected files**

```bash
npm test -- tests/bitmap/basic-bitmap.test.cnx --update
```

**Step 5: Verify MISRA compliance**

```bash
cppcheck --addon=misra tests/bitmap/basic-bitmap.test.c 2>&1 | grep "10.3"
```

**Step 6: Commit**

```bash
git add <modified files>
git commit -m "feat(codegen): add bool comparison for bitmap field reads (#845)"
```

---

## Task 8: Handle Character Literals

**Files:**

- Find: Character literal generation in CodeGenerator or LiteralGenerator
- Modify: Add cast when assigning char literal to u8

**Step 1: Find where char literals are generated**

Search for `'A'` or character literal handling.

**Step 2: When assigning char literal to u8, wrap with cast**

Current: `uint8_t ch = 'A'`
After: `uint8_t ch = (uint8_t)'A'`

**Step 3: Update char-contexts and char-escape-sequences tests**

```bash
npm test -- tests/literals/char-contexts.test.cnx --update
npm test -- tests/literals/char-escape-sequences.test.cnx --update
```

**Step 4: Verify MISRA compliance**

```bash
cppcheck --addon=misra tests/literals/char-contexts.test.c 2>&1 | grep "10.3"
```

**Step 5: Commit**

```bash
git add <modified files>
git commit -m "feat(codegen): cast char literals to uint8_t for MISRA 10.3 (#845)"
```

---

## Task 9: Handle Compound Assignments

**Files:**

- Find: Compound assignment generation (`&=`, `|=`, etc.)
- Modify: Expand to cast expression

**Step 1: Find compound assignment codegen**

Search for `&=` or `CompoundAssignment` patterns.

**Step 2: For narrower types, expand with cast**

Current: `andVal &= 0xAAAA`
After: `andVal = (int16_t)(andVal & 0xAAAA)`

**Step 3: Update compound-assign tests**

```bash
npm test -- tests/compound-assign/i16-compound-assign.test.cnx --update
npm test -- tests/compound-assign/i8-compound-assign.test.cnx --update
```

**Step 4: Verify MISRA compliance**

**Step 5: Commit**

---

## Task 10: Regenerate All Affected Expected Files

**Files:**

- All ~26 test files with MISRA 10.3 violations

**Step 1: Run full test suite with update flag**

```bash
npm test -- --update
```

**Step 2: Review changes to expected files**

Verify casts are correctly applied.

**Step 3: Run full MISRA validation**

```bash
npm run validate:c 2>&1 | grep -c "misra-c2012-10.3"
```

Expected: 0 (or significantly reduced)

**Step 4: Commit all expected file changes**

```bash
git add tests/
git commit -m "test: regenerate all expected files with MISRA 10.3 casts (#845)"
```

---

## Task 11: Update ADR-024 Documentation

**Files:**

- Modify: `docs/decisions/adr-024-type-casting.md`

**Step 1: Add new section after "Implementation Notes"**

```markdown
---

## Generated C Code MISRA Compliance

While C-Next enforces type safety at the source level (requiring explicit bit extraction for narrowing), the generated C code must satisfy MISRA C:2012 Rule 10.3 compliance.

### The Issue

C's integer promotion rules mean bitwise operations produce wider types:

- `((u8_var >> 0) & 0xFF)` has type `int` (due to promotion)
- Assigning this to `uint8_t` is implicit narrowing

MISRA 10.3 requires explicit casts for such assignments.

### The Solution

The transpiler adds explicit casts in generated C code:

| Pattern         | Before                            | After                                      |
| --------------- | --------------------------------- | ------------------------------------------ |
| Bit extraction  | `uint8_t x = ((val >> n) & 0xFF)` | `uint8_t x = (uint8_t)((val >> n) & 0xFF)` |
| Bool from bits  | `bool b = ((flags >> n) & 1)`     | `bool b = (((flags >> n) & 1) != 0U)`      |
| Char literal    | `uint8_t c = 'A'`                 | `uint8_t c = (uint8_t)'A'`                 |
| Compound assign | `x &= mask`                       | `x = (T)(x & mask)`                        |

### Implementation

- `NarrowingCastHelper.wrap()` handles all cast insertion
- Bool targets use `!= 0U` comparison per MISRA 10.5
- C++ mode uses `static_cast<T>()` instead of C-style casts

See Issue #845 for implementation details.
```

**Step 2: Commit**

```bash
git add docs/decisions/adr-024-type-casting.md
git commit -m "docs: add MISRA 10.3 generated code compliance to ADR-024 (#845)"
```

---

## Task 12: Final Verification and PR

**Step 1: Run full test suite**

```bash
npm run test:all
```

Expected: All tests pass

**Step 2: Run MISRA validation**

```bash
npm run validate:c 2>&1 | grep -c "misra-c2012-10.3"
```

Expected: 0

**Step 3: Check unit test coverage**

```bash
npm run unit:coverage
```

Verify NarrowingCastHelper has â‰¥80% coverage.

**Step 4: Create PR**

```bash
gh pr create --title "fix(codegen): MISRA C:2012 Rule 10.3 compliance - explicit narrowing casts (#845)" \
  --body "## Summary
Fixes 106 MISRA C:2012 Rule 10.3 violations by adding explicit casts to generated C code.

## Changes
- Add \`NarrowingCastHelper\` for centralized cast insertion
- Integrate with BitRangeHelper, BitmapHandlers, LiteralGenerator
- Bool targets use \`!= 0U\` comparison (MISRA 10.5)
- Update ADR-024 with generated code compliance section

## Testing
- Unit tests for NarrowingCastHelper
- Regenerated ~26 expected files
- MISRA validation passes (0 Rule 10.3 violations)

Closes #845"
```

---

## Summary

| Task | Description                                 | Estimated Steps |
| ---- | ------------------------------------------- | --------------- |
| 1    | Create NarrowingCastHelper with needsCast() | 5               |
| 2    | Add wrap() method                           | 5               |
| 3    | Add getPromotedType() helper                | 5               |
| 4    | Integrate with BitRangeHelper               | 6               |
| 5    | Update ArrayAccessHelper                    | 5               |
| 6    | Update bit-indexing tests                   | 4               |
| 7    | Handle bool from bitmap                     | 6               |
| 8    | Handle char literals                        | 5               |
| 9    | Handle compound assignments                 | 5               |
| 10   | Regenerate all expected files               | 4               |
| 11   | Update ADR-024                              | 2               |
| 12   | Final verification and PR                   | 4               |

**Total: 12 tasks, ~56 steps**
