/**
 * Generated by C-Next Transpiler from: switch-integer-types.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// ADR-025: Switch statement test for all integer types
// Tests: u8, u16, u32, u64, i8, i16, i32, i64 switch expressions
// Coverage: Section 7 (Control Flow) - switch with all integer types
uint32_t result = 0;

// === UNSIGNED TYPE HELPERS ===
void testSwitchU8(uint8_t val) {
    switch (val) {
        case 0: {
            result = 100U;
            break;
        }
        case 10: {
            result = 110U;
            break;
        }
        case 255: {
            result = 355U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchU16(uint16_t val) {
    switch (val) {
        case 0: {
            result = 200U;
            break;
        }
        case 1000: {
            result = 1200U;
            break;
        }
        case 65535: {
            result = 65735U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchU32(uint32_t val) {
    switch (val) {
        case 0: {
            result = 300U;
            break;
        }
        case 1000000: {
            result = 1000300U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchU64(uint64_t val) {
    switch (val) {
        case 0: {
            result = 400U;
            break;
        }
        case 1000000000000: {
            result = 401U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

// === SIGNED TYPE HELPERS ===
// Note: Case labels must use positive literals (grammar limitation).
// Signed types are still tested - negative values fall to default.
void testSwitchI8(int8_t val) {
    switch (val) {
        case 0: {
            result = 500U;
            break;
        }
        case 50: {
            result = 501U;
            break;
        }
        case 127: {
            result = 502U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchI16(int16_t val) {
    switch (val) {
        case 0: {
            result = 600U;
            break;
        }
        case 5000: {
            result = 601U;
            break;
        }
        case 32767: {
            result = 602U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchI32(int32_t val) {
    switch (val) {
        case 0: {
            result = 700U;
            break;
        }
        case 1000000: {
            result = 701U;
            break;
        }
        case 2000000: {
            result = 702U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

void testSwitchI64(int64_t val) {
    switch (val) {
        case 0: {
            result = 800U;
            break;
        }
        case 5000000000: {
            result = 801U;
            break;
        }
        case 9000000000: {
            result = 802U;
            break;
        }
        default: {
            result = 999U;
            break;
        }
    }
}

int main(void) {
    uint8_t u8_zero = 0U;
    uint8_t u8_ten = 10U;
    uint8_t u8_max = 255U;
    uint8_t u8_other = 50U;
    testSwitchU8(u8_zero);
    if (result != 100) return 1;
    testSwitchU8(u8_ten);
    if (result != 110) return 2;
    testSwitchU8(u8_max);
    if (result != 355) return 3;
    testSwitchU8(u8_other);
    if (result != 999) return 4;
    uint16_t u16_zero = 0U;
    uint16_t u16_mid = 1000U;
    uint16_t u16_max = 65535U;
    uint16_t u16_other = 5000U;
    testSwitchU16(u16_zero);
    if (result != 200) return 5;
    testSwitchU16(u16_mid);
    if (result != 1200) return 6;
    testSwitchU16(u16_max);
    if (result != 65735) return 7;
    testSwitchU16(u16_other);
    if (result != 999) return 8;
    uint32_t u32_zero = 0U;
    uint32_t u32_mid = 1000000U;
    uint32_t u32_other = 12345U;
    testSwitchU32(u32_zero);
    if (result != 300) return 9;
    testSwitchU32(u32_mid);
    if (result != 1000300) return 10;
    testSwitchU32(u32_other);
    if (result != 999) return 11;
    uint64_t u64_zero = 0ULL;
    uint64_t u64_large = 1000000000000ULL;
    uint64_t u64_other = 9999ULL;
    testSwitchU64(u64_zero);
    if (result != 400) return 12;
    testSwitchU64(u64_large);
    if (result != 401) return 13;
    testSwitchU64(u64_other);
    if (result != 999) return 14;
    int8_t i8_zero = 0;
    int8_t i8_mid = 50;
    int8_t i8_max = 127;
    int8_t i8_neg = -50;
    testSwitchI8(i8_zero);
    if (result != 500) return 15;
    testSwitchI8(i8_mid);
    if (result != 501) return 16;
    testSwitchI8(i8_max);
    if (result != 502) return 17;
    testSwitchI8(i8_neg);
    if (result != 999) return 18;
    int16_t i16_zero = 0;
    int16_t i16_mid = 5000;
    int16_t i16_max = 32767;
    int16_t i16_neg = -5000;
    testSwitchI16(i16_zero);
    if (result != 600) return 19;
    testSwitchI16(i16_mid);
    if (result != 601) return 20;
    testSwitchI16(i16_max);
    if (result != 602) return 21;
    testSwitchI16(i16_neg);
    if (result != 999) return 22;
    int32_t i32_zero = 0;
    int32_t i32_mid = 1000000;
    int32_t i32_high = 2000000;
    int32_t i32_neg = -1000000;
    testSwitchI32(i32_zero);
    if (result != 700) return 23;
    testSwitchI32(i32_mid);
    if (result != 701) return 24;
    testSwitchI32(i32_high);
    if (result != 702) return 25;
    testSwitchI32(i32_neg);
    if (result != 999) return 26;
    int64_t i64_zero = 0;
    int64_t i64_mid = 5000000000;
    int64_t i64_high = 9000000000;
    int64_t i64_neg = -5000000000;
    testSwitchI64(i64_zero);
    if (result != 800) return 27;
    testSwitchI64(i64_mid);
    if (result != 801) return 28;
    testSwitchI64(i64_high);
    if (result != 802) return 29;
    testSwitchI64(i64_neg);
    if (result != 999) return 30;
    return 0;
}
