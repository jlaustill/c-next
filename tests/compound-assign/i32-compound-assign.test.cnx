// test-execution
// Tests: i32 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: -2147483648 to 2147483647
u32 main() {
    // ===== ADDITION (+<-) =====
    i32 val <- 1000000000;
    val +<- 500000000; // pos + pos
    if (val != 1500000000) return 1;

    val <- -1000000000;
    val +<- 500000000; // neg + pos
    if (val != -500000000) return 2;

    val <- -1000000000;
    val +<- -500000000; // neg + neg
    if (val != -1500000000) return 3;

    val <- 1000000;
    val +<- 0; // Identity: add zero
    if (val != 1000000) return 4;

    val <- -1000000;
    val +<- 1000000; // Cross zero
    if (val != 0) return 5;

    val <- 2147483646;
    val +<- 1; // Near max
    if (val != 2147483647) return 6;

    // ===== SUBTRACTION (-<-) =====
    i32 sub <- 1500000000;
    sub -<- 500000000; // pos - pos = pos
    if (sub != 1000000000) return 10;

    sub <- 500000000;
    sub -<- 1000000000; // pos - pos = neg
    if (sub != -500000000) return 11;

    sub <- -1000000000;
    sub -<- 500000000; // neg - pos
    if (sub != -1500000000) return 12;

    sub <- -1000000000;
    sub -<- -500000000; // neg - neg
    if (sub != -500000000) return 13;

    sub <- 1000000;
    sub -<- 0; // Identity: subtract zero
    if (sub != 1000000) return 14;

    sub <- -2147483647;
    sub -<- 1; // Near min
    if (sub != -2147483648) return 15;

    // ===== MULTIPLICATION (*<-) =====
    i32 mul <- 10000;
    mul *<- 10000; // pos * pos = 100M
    if (mul != 100000000) return 20;

    mul <- -10000;
    mul *<- 10000; // neg * pos
    if (mul != -100000000) return 21;

    mul <- -10000;
    mul *<- -10000; // neg * neg = pos
    if (mul != 100000000) return 22;

    mul <- 1000000;
    mul *<- 1; // Identity: multiply by one
    if (mul != 1000000) return 23;

    mul <- 1000000;
    mul *<- -1; // Negate
    if (mul != -1000000) return 24;

    mul <- 123456;
    mul *<- 0; // Multiply by zero
    if (mul != 0) return 25;

    // ===== DIVISION (/<-) =====
    i32 div <- 1000000000;
    div /<- 1000; // pos / pos
    if (div != 1000000) return 30;

    div <- -1000000000;
    div /<- 1000; // neg / pos
    if (div != -1000000) return 31;

    div <- -1000000000;
    div /<- -1000; // neg / neg
    if (div != 1000000) return 32;

    div <- 1000000;
    div /<- 1; // Identity: divide by one
    if (div != 1000000) return 33;

    div <- -1000000;
    div /<- -1; // neg / neg = pos
    if (div != 1000000) return 34;

    div <- 2147483647;
    div /<- 2147483647; // Max / max = 1
    if (div != 1) return 35;

    // ===== MODULO (%<-) =====
    i32 mod <- 1000000007;
    mod %<- 1000000; // pos % pos
    if (mod != 7) return 40;

    mod <- -1000000007;
    mod %<- 1000000; // neg % pos (C semantics)
    if (mod != -7) return 41;

    mod <- 12345;
    mod %<- 7; // 12345 % 7 = 4
    if (mod != 4) return 42;

    mod <- -12345;
    mod %<- 7; // -12345 % 7 = -4
    if (mod != -4) return 43;

    mod <- 1000000;
    mod %<- 1000000; // Result zero
    if (mod != 0) return 44;

    // ===== BITWISE AND (&<-) =====
    i32 andVal <- 0x7FFFFFFF; // Max positive
    andVal &<- 0x0000FFFF; // Keep low 16 bits
    if (andVal != 0x0000FFFF) return 50;

    andVal <- -1; // All bits set
    andVal &<- 0x0000FFFF;
    if (andVal != 0x0000FFFF) return 51;

    andVal <- 0x55555555;
    andVal &<- 0xAAAAAAAA; // Non-overlapping = 0
    if (andVal != 0) return 52;

    andVal <- 0x0F0F0F0F;
    andVal &<- 0xF0F0F0F0; // Non-overlapping
    if (andVal != 0) return 53;

    // ===== BITWISE OR (|<-) =====
    i32 orVal <- 0x0000FFFF;
    orVal |<- 0x7FFF0000; // Combine (keep sign clear)
    if (orVal != 0x7FFFFFFF) return 60;

    orVal <- 0x12340000;
    orVal |<- 0x00005678; // OR non-overlapping
    if (orVal != 0x12345678) return 61;

    orVal <- 0x12345678;
    orVal |<- 0x00000000; // OR with zero = identity
    if (orVal != 0x12345678) return 62;

    // ===== BITWISE XOR (^<-) =====
    i32 xorVal <- 0x55555555;
    xorVal ^<- 0x55555555; // XOR with self = 0
    if (xorVal != 0) return 70;

    xorVal <- 0x0F0F0F0F;
    xorVal ^<- 0x70707070; // Partial overlap
    if (xorVal != 0x7F7F7F7F) return 71;

    xorVal <- -1;
    xorVal ^<- -1; // -1 XOR -1 = 0
    if (xorVal != 0) return 72;

    xorVal <- 0x55555555;
    xorVal ^<- 0x2AAAAAAA; // 0x55555555 ^ 0x2AAAAAAA = 0x7FFFFFFF
    if (xorVal != 0x7FFFFFFF) return 73;

    // ===== LEFT SHIFT (<<<-) =====
    i32 shl <- 1;
    shl <<<- 0; // Shift by 0 = identity
    if (shl != 1) return 80;

    shl <- 1;
    shl <<<- 1; // 1 << 1 = 2
    if (shl != 2) return 81;

    shl <- 1;
    shl <<<- 16; // 1 << 16 = 65536
    if (shl != 65536) return 82;

    shl <- 1;
    shl <<<- 30; // 1 << 30 = 1073741824
    if (shl != 1073741824) return 83;

    shl <- -1;
    shl <<<- 4; // -1 << 4 = -16
    if (shl != -16) return 84;

    // ===== RIGHT SHIFT (>><-) =====
    i32 shr <- 65536;
    shr >><- 0; // Shift by 0 = identity
    if (shr != 65536) return 90;

    shr <- 65536;
    shr >><- 1; // 65536 >> 1 = 32768
    if (shr != 32768) return 91;

    shr <- 65536;
    shr >><- 16; // 65536 >> 16 = 1
    if (shr != 1) return 92;

    shr <- -16;
    shr >><- 2; // -16 >> 2 = -4 (arithmetic shift)
    if (shr != -4) return 93;

    shr <- -1;
    shr >><- 10; // -1 >> 10 = -1 (sign extends)
    if (shr != -1) return 94;

    return 0;
}
