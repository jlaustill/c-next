/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// Comprehensive C++ Interop Test
// Tests: C++ syntax patterns for scope resolution and type handling
// This is a compilation-only test (no test-execution marker)
// Note: C-Next doesn't have native pointer syntax, so pointer tests are omitted
#include "comprehensive-cpp.hpp"

#include <stdint.h>
#include <stdbool.h>

// ============================================================================
// SECTION 1: NAMESPACE ACCESS
// ============================================================================
// Test namespace function calls and constant access
void testNamespaces(void) {
    hw::init();
    hw::shutdown();
    int32_t ver = hw::VERSION;
    int32_t maxDev = hw::MAX_DEVICES;
    hw::nested::configure();
    int32_t bufSize = hw::nested::BUFFER_SIZE;
}

// ============================================================================
// SECTION 2: ENUM CLASS ACCESS
// ============================================================================
// Test enum class values (C++11 scoped enums)
void testEnumClasses(void) {
    EMode mode1 = EMode::OFF;
    EMode mode2 = EMode::ON;
    EMode mode3 = EMode::AUTO;
    EMode mode4 = EMode::MANUAL;
    EColor color1 = EColor::RED;
    EColor color2 = EColor::GREEN;
    EColor color3 = EColor::BLUE;
}

// ============================================================================
// SECTION 3: TYPED ENUM ACCESS (not class)
// ============================================================================
// Test typed enums (C++11) and C-style enums
void testTypedEnums(void) {
    EFlags flags1 = FLAG_NONE;
    EFlags flags2 = FLAG_READ;
    uint16_t flags3 = FLAG_WRITE | FLAG_EXEC;
    ELegacy leg1 = LEGACY_A;
    ELegacy leg2 = LEGACY_B;
}

// ============================================================================
// SECTION 4: STATIC METHODS
// ============================================================================
// Test class static method calls
void testStaticMethods(void) {
    bool ok = CommandHandler::execute(1U);
    int32_t status = CommandHandler::getStatus();
    CommandHandler::reset();
    int32_t absVal = MathUtils::abs(-5);
    int32_t minVal = MathUtils::min(10, 20);
    int32_t maxVal = MathUtils::max(10, 20);
    int32_t pi = MathUtils::PI_INT;
    EMode computed = MathUtils::computeMode(0x05U);
}

// ============================================================================
// SECTION 5: STRUCT INITIALIZATION
// ============================================================================
// Test struct with constructors and factory methods
void testStructInit(void) {
    Result r1 = {};
    Result success = Result::success();
    Result error = Result::error(404);
    Point p = {};
    p.x = 10;
    p.y = 20;
    Settings s = {};
    s.enabled = false;
    s.timeout = 1000;
    s.mode = EMode::OFF;
    bool enabled = s.enabled;
    int32_t timeout = s.timeout;
    EMode mode = s.mode;
}

// ============================================================================
// SECTION 6: CONSTEXPR CONSTANTS
// ============================================================================
// Test constexpr access
void testConstexpr(void) {
    int32_t maxSize = MAX_SIZE;
    int32_t minSize = MIN_SIZE;
    int32_t timeout = DEFAULT_TIMEOUT;
    uint32_t magic = MAGIC_NUMBER;
    int32_t sq = square(5);
    int32_t fact = factorial(5);
}

// ============================================================================
// SECTION 7: FUNCTION OVERLOADS
// ============================================================================
// Test function overload resolution
void testOverloads(void) {
    int32_t r1 = process(10);
    int32_t r2 = process(10, 20);
    float r3 = process(3.14);
    double r4 = process(3.14159);
    Result r5 = process("test");
}

// ============================================================================
// SECTION 8: TYPE CONVERSIONS (Issue #252)
// ============================================================================
// Test enum and bool to u8 conversions
uint32_t processByte(uint32_t crc, uint8_t byte) {
    return crc ^ byte;
}

void testTypeConversions(void) {
    SensorConfig cfg = {};
    cfg.enabled = true;
    cfg.mode = EMode::ON;
    cfg.flags = 0x0FU;
    cfg.permissions = FLAG_READ;
    uint32_t crc = 0U;
    crc = processByte(crc, cfg.enabled);
    crc = processByte(crc, static_cast<uint8_t>(cfg.mode));
    crc = processByte(crc, cfg.flags);
    crc = processByte(crc, static_cast<uint8_t>(cfg.permissions));
}

// ============================================================================
// SECTION 9: ARRAY MEMBER ACCESS (Issue #256)
// ============================================================================
// Test array of structs member access
void testArrayMembers(void) {
    DeviceConfig device = {};
    device.sensors[0].enabled = true;
    device.sensors[0].mode = EMode::ON;
    device.sensors[0].flags = 0x01U;
    device.sensors[1].enabled = false;
    device.sensors[1].mode = EMode::OFF;
    device.sensors[2].flags = 0x0FU;
    bool enabled = device.sensors[0U].enabled;
    EMode mode = device.sensors[1U].mode;
    uint8_t flags = device.sensors[2U].flags;
    uint32_t crc = 0U;
    crc = processByte(crc, device.sensors[0U].enabled);
    crc = processByte(crc, static_cast<uint8_t>(device.sensors[0U].mode));
    crc = processByte(crc, device.sensors[0U].flags);
}

// ============================================================================
// SECTION 10: COMPLEX STRUCT ACCESS
// ============================================================================
// Test nested struct member access
void testComplexStructs(void) {
    Message msg = {};
    msg.id = 0x100U;
    msg.length = 8U;
    msg.flags = FLAG_READ;
    msg.result.code = 0;
    msg.result.dataLen = 0U;
    msg.result.data[0] = 0x42U;
    int32_t code = msg.result.code;
    uint8_t firstByte = msg.result.data[0U];
}

// ============================================================================
// SECTION 11: SINGLETON ACCESS
// ============================================================================
// Test singleton pattern and static registries
void testSingleton(void) {
    Registry::callHandler(1);
    int32_t count = Registry::getHandlerCount();
}

// ============================================================================
// SECTION 12: REFERENCES AND POINTERS
// ============================================================================
// Test reference and pointer passing
void testRefsAndPtrs(void) {
    int32_t val = 42;
    modifyRef(val);
    readRef(val);
    modifyPtr(&val);
    readPtr(&val);
}

// ============================================================================
// SECTION 13: STRICT INITIALIZATION (Issue #304.3)
// ============================================================================
// Test types that FAIL with {0} but work with {}
// This section will FAIL to compile if transpiler generates {0}
void testStrictInit(void) {
    StrictResult sr1 = {};
    sr1.code = 0;
    StrictResult sr2 = StrictResult::success();
    StrictResult sr3 = StrictResult::error(404);
    CommandResult cr1 = {};
    cr1.errorCode = 0;
    cr1.responseLen = 0U;
    CommandResult cr2 = CommandResult::ok();
    CommandResult cr3 = CommandResult::fail(500, "error");
    int32_t code1 = sr1.code;
    int32_t code2 = cr1.errorCode;
}

// ============================================================================
// SECTION 14: ARRAY PARAMETERS (Issue #304.4)
// ============================================================================
// Test passing array members to functions - should NOT add spurious &
void testArrayParams(void) {
    ResponsePacket packet = {};
    packet.statusCode = 200;
    packet.payloadLen = 8U;
    packet.payload[0] = 0x01U;
    packet.payload[1] = 0x02U;
    sendData(1, packet.statusCode, packet.payload, packet.payloadLen);
    Result res = {};
    res.code = 0;
    res.dataLen = 4U;
    res.data[0] = 0xABU;
    sendData(2, res.code, res.data, res.dataLen);
}

// ============================================================================
// SECTION 15: CALLBACK INTEROP (Issue #409)
// ============================================================================
// Test passing C-Next callbacks to C++ registration functions
// Define callback matching C++ Callback typedef: void(*)()
void simpleCallback(void) {
}

// Define callback matching C++ IntCallback typedef: void(*)(int)
void intCallback(int32_t value) {
}

// Define callback matching C++ ResultCallback typedef: void(*)(const Result&)
void resultCallback(const Result& result) {
}

void testCallbackInterop(void) {
    registerCallback(simpleCallback);
    registerIntCallback(intCallback);
    registerResultCallback(resultCallback);
    Registry::registerHandler(1, simpleCallback);
    Registry::registerHandler(2, simpleCallback);
    int32_t count = Registry::getHandlerCount();
}

// ============================================================================
// MAIN - Call all test sections
// ============================================================================
int main(void) {
    testNamespaces();
    testEnumClasses();
    testTypedEnums();
    testStaticMethods();
    testStructInit();
    testConstexpr();
    testOverloads();
    testTypeConversions();
    testArrayMembers();
    testComplexStructs();
    testSingleton();
    testRefsAndPtrs();
    testStrictInit();
    testArrayParams();
    testCallbackInterop();
}
