/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-execution
// Test: ADR-016 Private method validation
// Verifies that private methods work correctly within scopes
// Tests: private calling private, private accessing this., private accessing global.
// Note: Avoids passing computed expressions to functions (transpiler generates pointer params)
// Global variables for private method global. access testing
uint32_t globalCounter = 100;

bool globalFlag = true;

int32_t globalOffset = -50;

/* Scope: PrivateMethodTest */
static uint32_t PrivateMethodTest_privateState = 0;
static bool PrivateMethodTest_privateFlag = false;
static int32_t PrivateMethodTest_privateAccumulator = 0;
static uint8_t PrivateMethodTest_callCount = 0;
uint32_t PrivateMethodTest_publicResult = 0;
bool PrivateMethodTest_publicFlag = false;
int32_t PrivateMethodTest_publicAccumulator = 0;

static uint32_t PrivateMethodTest_getPrivateState(void) {
    return PrivateMethodTest_privateState;
}

static bool PrivateMethodTest_getPrivateFlag(void) {
    return PrivateMethodTest_privateFlag;
}

static int32_t PrivateMethodTest_getPrivateAccumulator(void) {
    return PrivateMethodTest_privateAccumulator;
}

static void PrivateMethodTest_incrementCallCount(void) {
    PrivateMethodTest_callCount = PrivateMethodTest_callCount + 1;
}

static uint8_t PrivateMethodTest_getCallCount(void) {
    return PrivateMethodTest_callCount;
}

static uint32_t PrivateMethodTest_readGlobalCounter(void) {
    return globalCounter;
}

static bool PrivateMethodTest_readGlobalFlag(void) {
    return globalFlag;
}

static int32_t PrivateMethodTest_readGlobalOffset(void) {
    return globalOffset;
}

static uint32_t PrivateMethodTest_combineStateAndGlobal(void) {
    return PrivateMethodTest_privateState + globalCounter;
}

static bool PrivateMethodTest_checkBothFlags(void) {
    return PrivateMethodTest_privateFlag && globalFlag;
}

static uint32_t PrivateMethodTest_getStateViaHelper(void) {
    return PrivateMethodTest_getPrivateState();
}

static void PrivateMethodTest_performPrivateChain(void) {
    PrivateMethodTest_incrementCallCount();
    PrivateMethodTest_privateState = PrivateMethodTest_privateState + 10;
    PrivateMethodTest_privateFlag = !PrivateMethodTest_privateFlag;
}

static void PrivateMethodTest_addValue(int32_t* amount) {
    PrivateMethodTest_privateAccumulator = PrivateMethodTest_privateAccumulator + (*amount);
    PrivateMethodTest_incrementCallCount();
}

uint32_t PrivateMethodTest_exposePrivateState(void) {
    return PrivateMethodTest_getPrivateState();
}

void PrivateMethodTest_setPrivateState(uint32_t* val) {
    PrivateMethodTest_privateState = (*val);
}

bool PrivateMethodTest_exposePrivateFlag(void) {
    return PrivateMethodTest_getPrivateFlag();
}

void PrivateMethodTest_setPrivateFlag(bool* val) {
    PrivateMethodTest_privateFlag = (*val);
}

int32_t PrivateMethodTest_exposePrivateAccumulator(void) {
    return PrivateMethodTest_getPrivateAccumulator();
}

void PrivateMethodTest_addToAccumulator(int32_t* val) {
    PrivateMethodTest_addValue(val);
}

uint32_t PrivateMethodTest_exposeGlobalCounter(void) {
    return PrivateMethodTest_readGlobalCounter();
}

uint32_t PrivateMethodTest_exposeCombinedStateAndGlobal(void) {
    return PrivateMethodTest_combineStateAndGlobal();
}

bool PrivateMethodTest_exposeBothFlagsCheck(void) {
    return PrivateMethodTest_checkBothFlags();
}

uint32_t PrivateMethodTest_exposeStateViaHelper(void) {
    return PrivateMethodTest_getStateViaHelper();
}

uint8_t PrivateMethodTest_exposeCallCount(void) {
    return PrivateMethodTest_getCallCount();
}

void PrivateMethodTest_triggerPrivateChain(void) {
    PrivateMethodTest_performPrivateChain();
}

void PrivateMethodTest_copyPrivateToPublic(void) {
    PrivateMethodTest_publicResult = PrivateMethodTest_getPrivateState();
    PrivateMethodTest_publicFlag = PrivateMethodTest_getPrivateFlag();
    PrivateMethodTest_publicAccumulator = PrivateMethodTest_getPrivateAccumulator();
}

int main(void) {
    if (PrivateMethodTest_exposePrivateState() != 0) return 1;
    PrivateMethodTest_setPrivateState(&(uint32_t){42});
    if (PrivateMethodTest_exposePrivateState() != 42) return 2;
    if (PrivateMethodTest_exposePrivateFlag() != false) return 3;
    PrivateMethodTest_setPrivateFlag(&(bool){true});
    if (PrivateMethodTest_exposePrivateFlag() != true) return 4;
    if (PrivateMethodTest_exposePrivateAccumulator() != 0) return 5;
    PrivateMethodTest_addToAccumulator(&(int32_t){100});
    if (PrivateMethodTest_exposePrivateAccumulator() != 100) return 6;
    PrivateMethodTest_addToAccumulator(&(int32_t){-30});
    if (PrivateMethodTest_exposePrivateAccumulator() != 70) return 7;
    if (PrivateMethodTest_exposeGlobalCounter() != 100) return 8;
    if (PrivateMethodTest_exposeCombinedStateAndGlobal() != 142) return 9;
    if (PrivateMethodTest_exposeBothFlagsCheck() != true) return 10;
    PrivateMethodTest_setPrivateFlag(&(bool){false});
    if (PrivateMethodTest_exposeBothFlagsCheck() != false) return 11;
    if (PrivateMethodTest_exposeStateViaHelper() != 42) return 12;
    PrivateMethodTest_setPrivateState(&(uint32_t){990});
    if (PrivateMethodTest_exposePrivateState() != 990) return 13;
    if (PrivateMethodTest_exposeCallCount() != 2) return 14;
    PrivateMethodTest_triggerPrivateChain();
    if (PrivateMethodTest_exposePrivateState() != 1000) return 15;
    if (PrivateMethodTest_exposePrivateFlag() != true) return 16;
    if (PrivateMethodTest_exposeCallCount() != 3) return 17;
    PrivateMethodTest_setPrivateState(&(uint32_t){777});
    PrivateMethodTest_setPrivateFlag(&(bool){true});
    PrivateMethodTest_copyPrivateToPublic();
    if (PrivateMethodTest_publicResult != 777) return 18;
    if (PrivateMethodTest_publicFlag != true) return 19;
    if (PrivateMethodTest_publicAccumulator != 70) return 20;
    return 0;
}
