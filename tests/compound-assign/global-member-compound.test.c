/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "global-member-compound.test.h"

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int32_t cnx_clamp_mul_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a * b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

static inline int32_t cnx_clamp_sub_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a - b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

// test-execution
// test-coverage: 2.3-global-member, 2.4-global-member, 2.5-global-member, 2.6-global-member, 2.7-global-member, 2.8-global-member, 2.9-global-member, 2.10-global-member, 2.11-global-member
// Tests: All compound assignment operators with global.member syntax
// Validates: Compound operators -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><- on global members from within scope
// Note: +<- is already tested in scope/global-compound-assign.test.cnx
// Global variables accessed via global.* from within scope
int32_t gValue = 0;

uint32_t gBits = 0;

/* Scope: Worker */

int32_t Worker_testSubtraction(void) {
    gValue = 100;
    gValue = cnx_clamp_sub_i32(gValue, 30);
    if (gValue != 70) return 1;
    gValue = 50;
    gValue = cnx_clamp_sub_i32(gValue, 50);
    if (gValue != 0) return 2;
    return 0;
}

int32_t Worker_testMultiplication(void) {
    gValue = 7;
    gValue = cnx_clamp_mul_i32(gValue, 6);
    if (gValue != 42) return 10;
    gValue = 100;
    gValue = cnx_clamp_mul_i32(gValue, 1);
    if (gValue != 100) return 11;
    gValue = 25;
    gValue = cnx_clamp_mul_i32(gValue, 0);
    if (gValue != 0) return 12;
    return 0;
}

int32_t Worker_testDivision(void) {
    gValue = 100;
    gValue /= 5;
    if (gValue != 20) return 20;
    gValue = 81;
    gValue /= 9;
    if (gValue != 9) return 21;
    gValue = 50;
    gValue /= 1;
    if (gValue != 50) return 22;
    return 0;
}

int32_t Worker_testModulo(void) {
    gValue = 17;
    gValue %= 5;
    if (gValue != 2) return 30;
    gValue = 100;
    gValue %= 7;
    if (gValue != 2) return 31;
    gValue = 25;
    gValue %= 25;
    if (gValue != 0) return 32;
    return 0;
}

int32_t Worker_testBitwiseAnd(void) {
    gBits = 0xFF;
    gBits &= 0x0F;
    if (gBits != 0x0F) return 40;
    gBits = 0xAA;
    gBits &= 0x55;
    if (gBits != 0) return 41;
    gBits = 0x12345678;
    gBits &= 0xFFFFFFFF;
    if (gBits != 0x12345678) return 42;
    return 0;
}

int32_t Worker_testBitwiseOr(void) {
    gBits = 0xF0;
    gBits |= 0x0F;
    if (gBits != 0xFF) return 50;
    gBits = 0x00;
    gBits |= 0xAB;
    if (gBits != 0xAB) return 51;
    gBits = 0x12340000;
    gBits |= 0x00005678;
    if (gBits != 0x12345678) return 52;
    return 0;
}

int32_t Worker_testBitwiseXor(void) {
    gBits = 0xFF;
    gBits ^= 0xFF;
    if (gBits != 0) return 60;
    gBits = 0xAA;
    gBits ^= 0x55;
    if (gBits != 0xFF) return 61;
    gBits = 0x12345678;
    gBits ^= 0x00000000;
    if (gBits != 0x12345678) return 62;
    return 0;
}

int32_t Worker_testLeftShift(void) {
    gBits = 1;
    gBits <<= 4;
    if (gBits != 16) return 70;
    gBits = 0xFF;
    gBits <<= 8;
    if (gBits != 0xFF00) return 71;
    gBits = 1;
    gBits <<= 0;
    if (gBits != 1) return 72;
    return 0;
}

int32_t Worker_testRightShift(void) {
    gBits = 256;
    gBits >>= 4;
    if (gBits != 16) return 80;
    gBits = 0xFF00;
    gBits >>= 8;
    if (gBits != 0xFF) return 81;
    gBits = 128;
    gBits >>= 0;
    if (gBits != 128) return 82;
    return 0;
}

int main(void) {
    int32_t result = 0;
    result = Worker_testSubtraction();
    if (result != 0) return result;
    result = Worker_testMultiplication();
    if (result != 0) return result;
    result = Worker_testDivision();
    if (result != 0) return result;
    result = Worker_testModulo();
    if (result != 0) return result;
    result = Worker_testBitwiseAnd();
    if (result != 0) return result;
    result = Worker_testBitwiseOr();
    if (result != 0) return result;
    result = Worker_testBitwiseXor();
    if (result != 0) return result;
    result = Worker_testLeftShift();
    if (result != 0) return result;
    result = Worker_testRightShift();
    if (result != 0) return result;
    return 0;
}
