/**
 * Generated by C-Next Transpiler from: issue-69-struct-array-indexing.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Regression test for issue #69: Array indexing transpiles as bitshift operation
//
// Bug: Array indexing on struct array members like config.tempInputs[index].assignedSpn
// was incorrectly transpiling as bitshift: ((config.tempInputs >> index) & 1).assignedSpn
//
// Expected: config->tempInputs[index].assignedSpn
//
// This test ensures the bug does not regress in future changes.
typedef struct InputData {
    uint16_t assignedSpn;
    float coeffA;
} InputData;

typedef struct Configuration {
    InputData tempInputs[8];
} Configuration;

// Function that exposes the bug - passing struct by value with array member access
uint16_t getSpn(const Configuration& conf, uint32_t idx) {
    return conf.tempInputs[idx].assignedSpn;
}

float getCoeff(const Configuration& data, uint32_t pos) {
    return data.tempInputs[pos].coeffA;
}

// Test writing to struct parameter array members (non-const)
void setSpn(Configuration& conf, uint32_t idx, uint16_t value) {
    conf.tempInputs[idx].assignedSpn = value;
}

void setCoeff(Configuration& data, uint32_t pos, float value) {
    data.tempInputs[pos].coeffA = value;
}

// Test writing in a for-loop (the original OSSM bug pattern)
void initializeAll(Configuration& conf, uint16_t spnValue, float coeffValue) {
    for (uint32_t i = 0; i < 8; i += 1) {
        conf.tempInputs[i].assignedSpn = spnValue;
        conf.tempInputs[i].coeffA = coeffValue;
    }
}

int main(void) {
    Configuration cfg = {0};
    cfg.tempInputs[0].assignedSpn = 100U;
    cfg.tempInputs[0].coeffA = 1.5;
    cfg.tempInputs[1].assignedSpn = 200U;
    cfg.tempInputs[1].coeffA = 2.5;
    cfg.tempInputs[2].assignedSpn = 300U;
    cfg.tempInputs[2].coeffA = 3.5;
    cfg.tempInputs[5].assignedSpn = 999U;
    cfg.tempInputs[5].coeffA = 9.5;
    uint32_t idx0 = 0U;
    uint32_t idx1 = 1U;
    uint32_t idx2 = 2U;
    uint32_t idx5 = 5U;
    uint16_t spn0 = getSpn(cfg, idx0);
    if (spn0 != 100) return 1;
    uint16_t spn1 = getSpn(cfg, idx1);
    if (spn1 != 200) return 2;
    uint16_t spn2 = getSpn(cfg, idx2);
    if (spn2 != 300) return 3;
    uint16_t spn5 = getSpn(cfg, idx5);
    if (spn5 != 999) return 4;
    float coeff0 = getCoeff(cfg, idx0);
    if (coeff0 != 1.5) return 5;
    float coeff1 = getCoeff(cfg, idx1);
    if (coeff1 != 2.5) return 6;
    float coeff2 = getCoeff(cfg, idx2);
    if (coeff2 != 3.5) return 7;
    if (cfg.tempInputs[0U].assignedSpn != 100) return 8;
    if (cfg.tempInputs[1U].assignedSpn != 200) return 9;
    if (cfg.tempInputs[2U].assignedSpn != 300) return 10;
    uint16_t sum = cfg.tempInputs[0U].assignedSpn + cfg.tempInputs[1U].assignedSpn;
    if (sum != 300) return 11;
    uint16_t val = getSpn(cfg, idx2);
    if (val != 300) return 12;
    if ((cfg.tempInputs[0U].assignedSpn + cfg.tempInputs[2U].assignedSpn) != 400) return 13;
    setSpn(cfg, idx0, 500U);
    if (cfg.tempInputs[0U].assignedSpn != 500) return 14;
    setCoeff(cfg, idx1, 7.5);
    if (cfg.tempInputs[1U].coeffA != 7.5) return 15;
    initializeAll(cfg, 42U, 4.5);
    for (uint32_t j = 0; j < 8; j += 1) {
        if (cfg.tempInputs[j].assignedSpn != 42) return 16;
        if (cfg.tempInputs[j].coeffA != 4.5) return 17;
    }
    return 0;
}
