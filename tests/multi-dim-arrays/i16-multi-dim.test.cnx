/* test-execution */
// Tests: multi-dimensional i16 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: sensor readings, coordinate systems, signed offsets

i16 matrix2d[4][8];
i16 cube3d[2][3][4];

u32 main() {
    // 2D array: Write operations with positive and negative values
    matrix2d[0][0] <- -32768;
    matrix2d[0][7] <- 32767;
    matrix2d[1][3] <- -10000;
    matrix2d[3][7] <- 20000;

    // 2D array: Read and verify
    if (matrix2d[0][0] != -32768) return 1;
    if (matrix2d[0][7] != 32767) return 2;
    if (matrix2d[1][3] != -10000) return 3;
    if (matrix2d[3][7] != 20000) return 4;

    // 3D array: Write operations
    cube3d[0][0][0] <- -15000;
    cube3d[0][0][3] <- -5000;
    cube3d[0][2][3] <- 0;
    cube3d[1][0][0] <- 10000;
    cube3d[1][2][3] <- 30000;

    // 3D array: Read and verify
    if (cube3d[0][0][0] != -15000) return 5;
    if (cube3d[0][0][3] != -5000) return 6;
    if (cube3d[0][2][3] != 0) return 7;
    if (cube3d[1][0][0] != 10000) return 8;
    if (cube3d[1][2][3] != 30000) return 9;

    // Test .length property at each dimension
    // 2D array dimensions
    if (matrix2d.length != 4) return 10;        // First dimension
    if (matrix2d[0].length != 8) return 11;     // Second dimension
    if (matrix2d[0][0].length != 16) return 12; // Element bit width

    // 3D array dimensions
    if (cube3d.length != 2) return 13;          // First dimension
    if (cube3d[0].length != 3) return 14;       // Second dimension
    if (cube3d[0][0].length != 4) return 15;    // Third dimension
    if (cube3d[0][0][0].length != 16) return 16; // Element bit width

    // Nested loop iteration - populate 2D array
    for (u32 i <- 0; i < 4; i +<- 1) {
        for (u32 j <- 0; j < 8; j +<- 1) {
            matrix2d[i][j] <- i * 100 + j;
        }
    }

    // Verify populated values
    if (matrix2d[0][0] != 0) return 17;
    if (matrix2d[0][7] != 7) return 18;
    if (matrix2d[1][3] != 103) return 19;
    if (matrix2d[3][7] != 307) return 20;

    // Nested loop iteration - populate and sum 3D array
    i32 sum <- 0;
    for (u32 i <- 0; i < 2; i +<- 1) {
        for (u32 j <- 0; j < 3; j +<- 1) {
            for (u32 k <- 0; k < 4; k +<- 1) {
                cube3d[i][j][k] <- i * 100 + j * 10 + k;
                sum +<- cube3d[i][j][k];
            }
        }
    }

    // Verify sum: 6+46+86+406+446+486 = 1476
    if (sum != 1476) return 21;

    // Test modification after initialization
    matrix2d[2][4] <- -32768;
    if (matrix2d[2][4] != -32768) return 22;

    // Test boundary access
    matrix2d[matrix2d.length - 1][matrix2d[0].length - 1] <- -1000;
    if (matrix2d[3][7] != -1000) return 23;

    // Test i16 specific edge cases
    i16 testArray[4][2];
    // Initialize all elements first
    for (u32 ti <- 0; ti < 4; ti +<- 1) {
        for (u32 tj <- 0; tj < 2; tj +<- 1) {
            testArray[ti][tj] <- 0;
        }
    }
    testArray[0][0] <- -32768;  // Min value
    testArray[0][1] <- 32767;   // Max value
    testArray[1][0] <- 0;       // Zero
    testArray[1][1] <- -1;      // Negative
    testArray[2][0] <- 1;       // Positive
    testArray[3][1] <- -15000;  // Mid negative

    if (testArray[0][0] != -32768) return 24;
    if (testArray[0][1] != 32767) return 25;
    if (testArray[1][0] != 0) return 26;
    if (testArray[1][1] != -1) return 27;
    if (testArray[2][0] != 1) return 28;
    if (testArray[3][1] != -15000) return 29;

    // Test 2D array with coordinate system pattern
    i16 coords[3][3];
    // Initialize all elements first
    for (u32 ci <- 0; ci < 3; ci +<- 1) {
        for (u32 cj <- 0; cj < 3; cj +<- 1) {
            coords[ci][cj] <- 0;
        }
    }
    coords[0][0] <- -1000;  // X coordinate
    coords[0][1] <- 500;    // Y coordinate
    coords[1][0] <- 0;      // Origin X
    coords[1][1] <- 0;      // Origin Y
    coords[2][0] <- 2000;   // Positive X
    coords[2][1] <- -3000;  // Negative Y

    if (coords[0][0] != -1000) return 30;
    if (coords[0][1] != 500) return 31;
    if (coords[1][0] != 0) return 32;
    if (coords[1][1] != 0) return 33;
    if (coords[2][0] != 2000) return 34;
    if (coords[2][1] != -3000) return 35;

    // Test negative value calculations
    i16 deltas[2][2];
    // Initialize all elements first
    for (u32 di <- 0; di < 2; di +<- 1) {
        for (u32 dj <- 0; dj < 2; dj +<- 1) {
            deltas[di][dj] <- 0;
        }
    }
    deltas[0][0] <- -5000;
    deltas[0][1] <- 3000;
    i32 deltaSum <- deltas[0][0] + deltas[0][1];
    if (deltaSum != -2000) return 36;

    // Test with altitude values (meters, can be negative)
    i16 altitudes[2][3];
    // Initialize all elements first
    for (u32 ai <- 0; ai < 2; ai +<- 1) {
        for (u32 aj <- 0; aj < 3; aj +<- 1) {
            altitudes[ai][aj] <- 0;
        }
    }
    altitudes[0][0] <- -400;   // Dead Sea
    altitudes[0][1] <- 0;      // Sea level
    altitudes[0][2] <- 8849;   // Mt. Everest
    altitudes[1][0] <- -10994; // Mariana Trench
    altitudes[1][1] <- 5895;   // Kilimanjaro
    altitudes[1][2] <- 1000;   // Hills

    if (altitudes[0][0] != -400) return 37;
    if (altitudes[0][2] != 8849) return 38;
    if (altitudes[1][0] != -10994) return 39;

    return 0;
}
