/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)(UINT64_MAX - a)) return UINT64_MAX;
    uint64_t result;
    if (__builtin_add_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

// test-execution
// Tests: u64 array initialization, access, and modification
// Validates array operations with u64 element type
// Includes typical embedded use cases (timestamps, counters, buffers)
// Fixed size with explicit values (typical timestamps)
uint64_t timestamps[4] = {1000000000000, 2000000000000, 3000000000000, 4000000000000};

// Size inference
uint64_t counters[5] = {100, 200, 300, 400, 500};

// Fill syntax - zero initialized buffer
uint64_t buffer[100] = {0};

// Fill syntax - ones
uint64_t ones[50] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

// Const lookup table (factorials)
const uint64_t factorials[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};

int main(void) {
    if (timestamps[0] != 1000000000000) return 1;
    if (timestamps[1] != 2000000000000) return 2;
    if (timestamps[2] != 3000000000000) return 3;
    if (timestamps[3] != 4000000000000) return 4;
    if (counters[0] != 100) return 5;
    if (counters[2] != 300) return 6;
    if (counters[4] != 500) return 7;
    if (buffer[0] != 0) return 8;
    if (buffer[50] != 0) return 9;
    if (buffer[99] != 0) return 10;
    if (ones[0] != 1) return 11;
    if (ones[25] != 1) return 12;
    if (ones[49] != 1) return 13;
    uint64_t mutable[5] = {10, 20, 30, 40, 50};
    mutable[2] = 999;
    if (mutable[2] != 999) return 14;
    if (mutable[0] != 10) return 15;
    if (mutable[4] != 50) return 16;
    uint64_t sum = 0;
    for (uint32_t i = 0; i < 5; i += 1) {
        sum = cnx_clamp_add_u64(sum, counters[i]);
    }
    if (sum != 1500) return 17;
    if (factorials[0] != 1) return 18;
    if (factorials[5] != 120) return 19;
    if (factorials[9] != 362880) return 20;
    uint64_t large_vals[3] = {9000000000000000000, 8000000000000000000, 7000000000000000000};
    if (large_vals[0] != 9000000000000000000) return 21;
    if (large_vals[2] != 7000000000000000000) return 22;
    uint64_t sequence[10] = {0};
    for (uint32_t i = 0; i < 10; i += 1) {
        sequence[i] = i * 1000000;
    }
    if (sequence[0] != 0) return 23;
    if (sequence[5] != 5000000) return 24;
    if (sequence[9] != 9000000) return 25;
    if (4 != 4) return 26;
    if (5 != 5) return 27;
    if (100 != 100) return 28;
    if (64 != 64) return 29;
    if (64 != 64) return 30;
    uint64_t computed[3] = {0};
    computed[0] = 1000000;
    computed[1] = 1000000000;
    computed[2] = computed[0] + computed[1];
    if (computed[2] != 1001000000) return 31;
    return 0;
}
