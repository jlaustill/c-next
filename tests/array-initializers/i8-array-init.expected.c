/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int8_t cnx_clamp_add_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a + b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

// test-execution
// Tests: i8 as array element type
// Coverage: Section 1.2 i8 array element type
int main(void) {
    int8_t values[5] = {-128, -1, 0, 1, 127};
    if (values[0U] != -128) return 1;
    if (values[1U] != -1) return 2;
    if (values[2U] != 0) return 3;
    if (values[3U] != 1) return 4;
    if (values[4U] != 127) return 5;
    int8_t data[4] = {0};
    data[0] = -50;
    data[1] = 50;
    data[2] = -100;
    data[3] = 100;
    if (data[0U] != -50) return 6;
    if (data[1U] != 50) return 7;
    if (data[2U] != -100) return 8;
    if (data[3U] != 100) return 9;
    int8_t inferred[3] = {10, 20, 30};
    if (inferred[0U] != 10) return 10;
    if (inferred[1U] != 20) return 11;
    if (inferred[2U] != 30) return 12;
    int8_t loop_arr[3] = {1, 2, 3};
    int8_t sum = 0;
    for (uint32_t i = 0; i < 3; i += 1) {
        sum = cnx_clamp_add_i8(sum, loop_arr[i]);
    }
    if (sum != 6) return 13;
    int8_t modify[2] = {10, 20};
    modify[0] = -10;
    modify[1] = -20;
    if (modify[0U] != -10) return 14;
    if (modify[1U] != -20) return 15;
    return 0;
}
