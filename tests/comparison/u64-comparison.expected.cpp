/**
 * Generated by C-Next Transpiler from: u64-comparison.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)(UINT64_MAX - a)) return UINT64_MAX;
    uint64_t result;
    if (__builtin_add_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

// test-coverage: 1.1-u64-in-comparison
// test-execution
// Tests: u64 comparison operations (<, >, <=, >=, =, !=)
// Validates all comparison operators with u64 type
// Includes edge cases with zero, max values, and typical embedded use cases
int main(void) {
    uint64_t a = 1000000000000ULL;
    uint64_t b = 1000000000000ULL;
    uint64_t c = 2000000000000ULL;
    if ((a == b) != true) return 1;
    if ((a == c) != false) return 2;
    if ((a != c) != true) return 3;
    if ((a != b) != false) return 4;
    uint64_t zero = 0ULL;
    if ((zero == 0) != true) return 5;
    if ((zero != 1) != true) return 6;
    uint64_t small = 1000ULL;
    uint64_t large = 1000000000000ULL;
    if ((small < large) != true) return 7;
    if ((large < small) != false) return 8;
    if ((small < small) != false) return 9;
    if ((small <= large) != true) return 10;
    if ((small <= small) != true) return 11;
    if ((large <= small) != false) return 12;
    if ((zero < 1) != true) return 13;
    if ((zero <= 0) != true) return 14;
    if ((large > small) != true) return 15;
    if ((small > large) != false) return 16;
    if ((small > small) != false) return 17;
    if ((large >= small) != true) return 18;
    if ((small >= small) != true) return 19;
    if ((small >= large) != false) return 20;
    if ((1 > zero) != true) return 21;
    if ((zero >= 0) != true) return 22;
    uint64_t val = 1000000000000ULL;
    if ((val == 1000000000000) != true) return 23;
    if ((val != 1000000000000) != false) return 24;
    if ((val < 2000000000000) != true) return 25;
    if ((val < 500000000000) != false) return 26;
    if ((val > 500000000000) != true) return 27;
    if ((val > 2000000000000) != false) return 28;
    if ((val <= 1000000000000) != true) return 29;
    if ((val <= 2000000000000) != true) return 30;
    if ((val >= 1000000000000) != true) return 31;
    if ((val >= 500000000000) != true) return 32;
    uint64_t counter = 0ULL;
    while (counter < 100) {
        counter = cnx_clamp_add_u64(counter, 1ULL);
        if (counter >= 50) {
            counter = 100ULL;
        }
    }
    if (counter != 100) return 33;
    uint64_t threshold = 1000000000ULL;
    bool nested_passed = false;
    if (counter > 0) {
        if (counter < threshold) {
            nested_passed = true;
        }
    }
    if (nested_passed != true) return 34;
    if ((zero < 1) != true) return 35;
    if ((zero == 0) != true) return 36;
    if ((0 <= zero) != true) return 37;
    uint64_t max = 18446744073709551615ULL;
    uint64_t near_max = 18446744073709551614ULL;
    if ((zero < max) != true) return 38;
    if ((max >= max) != true) return 39;
    if ((max == max) != true) return 40;
    if ((near_max < max) != true) return 41;
    if ((near_max != max) != true) return 42;
    if ((near_max <= max) != true) return 43;
    uint64_t timestamp_2020 = 1577836800000ULL;
    uint64_t timestamp_2021 = 1609459200000ULL;
    if ((timestamp_2021 > timestamp_2020) != true) return 44;
    if ((timestamp_2021 != timestamp_2020) != true) return 45;
    uint64_t chain_a = 1000ULL;
    uint64_t chain_b = 5000ULL;
    uint64_t chain_c = 10000ULL;
    bool chain_result = false;
    if (chain_a < chain_b) {
        if (chain_b < chain_c) {
            chain_result = true;
        }
    }
    if (chain_result != true) return 46;
    bool less = (chain_a < chain_b);
    bool greater = (chain_c > chain_b);
    if (less != true) return 47;
    if (greater != true) return 48;
    if ((chain_a < chain_b) != true) return 49;
    return 0;
}
