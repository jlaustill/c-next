/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-coverage: 5.5-i8-left-shift, 5.6-i8-right-shift-arithmetic */
/* test-execution */
// Test i8 shift operations: arithmetic right shift preserves sign
// Coverage: Section 5.5-5.6 for i8 type
uint32_t main(void) {
    int8_t a = 1;
    int8_t left1 = a << 1;
    int8_t left4 = a << 4;
    int8_t left6 = a << 6;
    int8_t b = 64;
    int8_t right1 = b >> 1;
    int8_t right2 = b >> 2;
    int8_t right6 = b >> 6;
    int8_t c = -64;
    int8_t neg_right1 = c >> 1;
    int8_t neg_right2 = c >> 2;
    int8_t neg_right6 = c >> 6;
    int8_t minus_one = -1;
    int8_t shift_minus_one = minus_one >> 4;
    int8_t d = 16;
    int8_t shift_amount = 2;
    int8_t left_var = d << shift_amount;
    int8_t right_var = d >> shift_amount;
    int8_t e = -8;
    int8_t neg_shift = e >> 1;
    if (left1 == 2 && left4 == 16 && left6 == 64) {
        if (right1 == 32 && right2 == 16 && right6 == 1) {
            if (neg_right1 == -32 && neg_right2 == -16 && neg_right6 == -1) {
                if (shift_minus_one == -1 && left_var == 64 && right_var == 4) {
                    if (neg_shift == -4) {
                        return 0;
                    }
                }
            }
        }
    }
    return 1;
}
