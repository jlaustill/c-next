/* test-execution */ // Tests: wrap modifier for i16 type (-32768 to 32767)
// Validates: overflow wraps to -32768, underflow wraps to 32767
// Issue #19: Add wrap modifier tests for all integer types
u32 main() {
    // === OVERFLOW WRAPPING (wraps to negative) ===
    // Test 1: Basic overflow - add past max
    wrap i16 val <- 32767;
    val +<- 1; // 32767 + 1 = 32768, should wrap to -32768
    if (val != -32768) return 1;

    // Test 2: Overflow with larger addition
    wrap i16 val2 <- 32760;
    val2 +<- 10; // 32760 + 10 = 32770, should wrap to -32766
    if (val2 != -32766) return 2;

    // Test 3: Large overflow
    val <- 30000;
    val +<- 10000; // 30000 + 10000 = 40000, should wrap to -25536
    if (val != -25536) return 3;

    // Test 4: Overflow from zero
    val <- 0;
    val +<- 40000; // 0 + 40000 = 40000, should wrap to -25536
    if (val != -25536) return 4;

    // Test 5: Multiple overflows in sequence
    val <- 32767;
    val +<- 1; // -32768
    if (val != -32768) return 5;
    val +<- 65535; // -32768 + 65535 = 32767 (wraps back to max)
    if (val != 32767) return 6;

    // === UNDERFLOW WRAPPING (wraps to positive) ===
    // Test 7: Basic underflow - subtract below min
    val <- -32768;
    val -<- 1; // -32768 - 1 = -32769, should wrap to 32767
    if (val != 32767) return 7;

    // Test 8: Underflow with larger subtraction
    val <- -32760;
    val -<- 10; // -32760 - 10 = -32770, should wrap to 32766
    if (val != 32766) return 8;

    // Test 9: Large underflow
    val <- -30000;
    val -<- 10000; // -30000 - 10000 = -40000, should wrap to 25536
    if (val != 25536) return 9;

    // Test 10: Multiple underflows in sequence
    val <- -32768;
    val -<- 1; // 32767
    if (val != 32767) return 10;
    val -<- 65535; // 32767 - 65535 = -32768 (wraps back to min)
    if (val != -32768) return 11;

    // === CROSS-ZERO OPERATIONS ===
    // Test 12: Positive to negative (no wrap needed)
    val <- 10000;
    val -<- 20000; // 10000 - 20000 = -10000, no wrap
    if (val != -10000) return 12;

    // Test 13: Negative to positive (no wrap needed)
    val <- -10000;
    val +<- 20000; // -10000 + 20000 = 10000, no wrap
    if (val != 10000) return 13;

    // Test 14: Cross zero exactly
    val <- 1000;
    val -<- 1000; // 0
    if (val != 0) return 14;

    // Test 15: Negative to zero exactly
    val <- -1000;
    val +<- 1000; // 0
    if (val != 0) return 15;

    // === NORMAL OPERATIONS (no wrapping needed) ===
    // Test 16: Normal positive addition
    val <- 15000;
    val +<- 10000; // 25000
    if (val != 25000) return 16;

    // Test 17: Normal negative subtraction
    val <- -15000;
    val -<- 10000; // -25000
    if (val != -25000) return 17;

    // Test 18: Add negative (same as subtract)
    val <- 10000;
    val +<- -5000; // 5000
    if (val != 5000) return 18;

    // Test 19: Subtract negative (same as add)
    val <- -10000;
    val -<- -5000; // -5000
    if (val != -5000) return 19;

    // === BOUNDARY TESTS ===
    // Test 20: Add 1 to 32766 (just under max, no wrap)
    val <- 32766;
    val +<- 1;
    if (val != 32767) return 20;

    // Test 21: Subtract 1 from -32767 (just above min, no wrap)
    val <- -32767;
    val -<- 1;
    if (val != -32768) return 21;

    // Test 22: Add 0 (no change)
    val <- 16384;
    val +<- 0;
    if (val != 16384) return 22;

    // Test 23: Subtract 0 (no change)
    val <- -16384;
    val -<- 0;
    if (val != -16384) return 23;

    // === WRAP-AROUND CYCLES ===
    // Test 24: Full wrap cycle (max -> min -> max)
    val <- 32767;
    val +<- 1; // -32768
    if (val != -32768) return 24;
    val -<- 1; // 32767
    if (val != 32767) return 25;

    // All tests passed
    return 0;
}
