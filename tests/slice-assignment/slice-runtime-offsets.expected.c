/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

// test-execution
// Tests: Slice assignment with runtime variable offsets and lengths
// Validates that offset and length can be variables or expressions
// Ensures the code generator handles non-literal indices correctly
int main(void) {
    uint8_t buffer[128] = {0};
    uint32_t offset = 0;
    uint32_t value1 = 0x11223344;
    if (offset + 4 <= sizeof(buffer)) { memcpy(&buffer[offset], &value1, 4); }
    if (buffer[0] != 0x44) return 1;
    if (buffer[1] != 0x33) return 2;
    if (buffer[2] != 0x22) return 3;
    if (buffer[3] != 0x11) return 4;
    uint8_t len = 4;
    uint32_t value2 = 0x55667788;
    if (10 + len <= sizeof(buffer)) { memcpy(&buffer[10], &value2, len); }
    if (buffer[10] != 0x88) return 5;
    if (buffer[11] != 0x77) return 6;
    if (buffer[12] != 0x66) return 7;
    if (buffer[13] != 0x55) return 8;
    offset = 20;
    len = 8;
    uint64_t value3 = 0xAABBCCDDEEFF0011;
    if (offset + len <= sizeof(buffer)) { memcpy(&buffer[offset], &value3, len); }
    if (buffer[20] != 0x11) return 9;
    if (buffer[21] != 0x00) return 10;
    if (buffer[22] != 0xFF) return 11;
    if (buffer[23] != 0xEE) return 12;
    if (buffer[24] != 0xDD) return 13;
    if (buffer[25] != 0xCC) return 14;
    if (buffer[26] != 0xBB) return 15;
    if (buffer[27] != 0xAA) return 16;
    uint32_t base = 5;
    uint16_t value4 = 0x9988;
    if (base + 30 + 2 <= sizeof(buffer)) { memcpy(&buffer[base + 30], &value4, 2); }
    if (buffer[35] != 0x88) return 17;
    if (buffer[36] != 0x99) return 18;
    uint8_t multiplier = 2;
    uint32_t value5 = 0x12345678;
    if (40 + multiplier * 2 <= sizeof(buffer)) { memcpy(&buffer[40], &value5, multiplier * 2); }
    if (buffer[40] != 0x78) return 19;
    if (buffer[41] != 0x56) return 20;
    if (buffer[42] != 0x34) return 21;
    if (buffer[43] != 0x12) return 22;
    return 0;
}
