import { describe, it, expect, beforeEach } from "vitest";
import CppEntryPointScanner from "../CppEntryPointScanner";
import IFileSystem from "../../types/IFileSystem";

describe("CppEntryPointScanner", () => {
  let mockFs: IFileSystem;
  let files: Map<string, string>;

  beforeEach(() => {
    files = new Map();
    mockFs = {
      readFile: (path: string) => {
        const content = files.get(path);
        if (!content) throw new Error(`File not found: ${path}`);
        return content;
      },
      exists: (path: string) => files.has(path),
      isDirectory: () => false,
      isFile: (path: string) => files.has(path),
      writeFile: () => {},
      mkdir: () => {},
      readdir: () => [],
      stat: () => ({ mtimeMs: Date.now() }),
    };
  });

  describe("scan", () => {
    it("should find .cnx source from header with marker", () => {
      files.set("/project/main.cpp", '#include "led.h"\nint main() {}');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */
void led_on(void);`,
      );
      files.set("/project/led.cnx", "scope LED { public void on() {} }");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(1);
      expect(result.cnextSources[0]).toBe("/project/led.cnx");
    });

    it("should return empty when no C-Next markers found", () => {
      files.set("/project/main.cpp", '#include "utils.h"\nint main() {}');
      files.set("/project/utils.h", "void utils_init(void);");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(0);
      expect(result.noCNextFound).toBe(true);
    });

    it("should follow transitive includes through .cnx sources", () => {
      files.set("/project/main.cpp", '#include "middleware.h"');
      files.set(
        "/project/middleware.h",
        `/**
 * Generated by C-Next Transpiler from: middleware.cnx
 */`,
      );
      files.set("/project/middleware.cnx", '#include "led.h"');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      files.set("/project/led.cnx", "scope LED {}");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toContain("/project/middleware.cnx");
      expect(result.cnextSources).toContain("/project/led.cnx");
    });

    it("should report error when marker points to missing .cnx", () => {
      files.set("/project/main.cpp", '#include "led.h"');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      // led.cnx does NOT exist

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toContain("led.cnx");
      expect(result.errors[0]).toContain("led.h");
    });

    it("should handle cycle detection", () => {
      files.set("/project/main.cpp", '#include "a.h"');
      files.set(
        "/project/a.h",
        `/**
 * Generated by C-Next Transpiler from: a.cnx
 */`,
      );
      files.set("/project/a.cnx", '#include "b.h"');
      files.set(
        "/project/b.h",
        `/**
 * Generated by C-Next Transpiler from: b.cnx
 */`,
      );
      files.set("/project/b.cnx", '#include "a.h"'); // cycle back to a.h

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      // Should not infinite loop
      expect(result.cnextSources).toContain("/project/a.cnx");
      expect(result.cnextSources).toContain("/project/b.cnx");
    });

    it("should handle multiple includes in one file", () => {
      files.set(
        "/project/main.cpp",
        `#include "led.h"
#include "motor.h"
int main() {}`,
      );
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      files.set("/project/led.cnx", "scope LED {}");
      files.set(
        "/project/motor.h",
        `/**
 * Generated by C-Next Transpiler from: motor.cnx
 */`,
      );
      files.set("/project/motor.cnx", "scope Motor {}");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(2);
      expect(result.cnextSources).toContain("/project/led.cnx");
      expect(result.cnextSources).toContain("/project/motor.cnx");
    });

    it("should skip system includes", () => {
      files.set(
        "/project/main.cpp",
        `#include <stdio.h>
#include "led.h"
int main() {}`,
      );
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      files.set("/project/led.cnx", "scope LED {}");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      // Should only find led.cnx, not fail on stdio.h
      expect(result.cnextSources).toHaveLength(1);
      expect(result.cnextSources[0]).toBe("/project/led.cnx");
    });

    it("should scan non-C-Next headers for nested includes", () => {
      files.set("/project/main.cpp", '#include "wrapper.h"');
      files.set("/project/wrapper.h", '#include "led.h"\nvoid wrapper_init();');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */`,
      );
      files.set("/project/led.cnx", "scope LED {}");

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(1);
      expect(result.cnextSources[0]).toBe("/project/led.cnx");
    });

    it("should handle old-style C-Next markers without source path", () => {
      files.set("/project/main.cpp", '#include "led.h"');
      files.set(
        "/project/led.h",
        `/**
 * Generated by C-Next Transpiler
 */
void led_on(void);`,
      );

      const scanner = new CppEntryPointScanner(["/project"], mockFs);
      const result = scanner.scan("/project/main.cpp");

      // Old marker without source path - should be treated as C-Next generated
      // but without a source path, we can't add it to cnextSources
      expect(result.cnextSources).toHaveLength(0);
      // Should not follow includes from old-style C-Next headers (they're leaf nodes)
    });

    it("should find .cnx source via search paths when --header-out is used", () => {
      // Simulate --header-out: headers in include/, sources in src/
      files.set("/project/main.cpp", '#include "led.h"');
      files.set(
        "/project/include/led.h",
        `/**
 * Generated by C-Next Transpiler from: led.cnx
 */
void led_on(void);`,
      );
      // Source is in src/, not include/
      files.set("/project/src/led.cnx", "scope LED { public void on() {} }");

      // Scanner search paths include src/
      const scanner = new CppEntryPointScanner(
        ["/project/include", "/project/src"],
        mockFs,
      );
      const result = scanner.scan("/project/main.cpp");

      expect(result.cnextSources).toHaveLength(1);
      expect(result.cnextSources[0]).toBe("/project/src/led.cnx");
      expect(result.errors).toHaveLength(0);
    });
  });
});
