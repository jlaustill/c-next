/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint16_t cnx_clamp_add_u16(uint16_t a, uint16_t b) {
    if (a > UINT16_MAX - b) return UINT16_MAX;
    return a + b;
}

static inline uint16_t cnx_clamp_mul_u16(uint16_t a, uint16_t b) {
    if (b != 0 && a > UINT16_MAX / b) return UINT16_MAX;
    return a * b;
}

static inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint16_t b) {
    if (a < b) return 0;
    return a - b;
}

/* test-execution */
// Tests: u16 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: 0 to 65535
uint32_t main(void) {
    uint16_t val = 30000;
    val = cnx_clamp_add_u16(val, 20000);
    if (val != 50000) return 1;
    val = 60000;
    val = cnx_clamp_add_u16(val, 0);
    if (val != 60000) return 2;
    val = 0;
    val = cnx_clamp_add_u16(val, 65535);
    if (val != 65535) return 3;
    val = 65534;
    val = cnx_clamp_add_u16(val, 1);
    if (val != 65535) return 4;
    uint16_t sub = 50000;
    sub = cnx_clamp_sub_u16(sub, 20000);
    if (sub != 30000) return 10;
    sub = 30000;
    sub = cnx_clamp_sub_u16(sub, 0);
    if (sub != 30000) return 11;
    sub = 65535;
    sub = cnx_clamp_sub_u16(sub, 65534);
    if (sub != 1) return 12;
    sub = 30000;
    sub = cnx_clamp_sub_u16(sub, 30000);
    if (sub != 0) return 13;
    sub = 1;
    sub = cnx_clamp_sub_u16(sub, 1);
    if (sub != 0) return 14;
    uint16_t mul = 200;
    mul = cnx_clamp_mul_u16(mul, 200);
    if (mul != 40000) return 20;
    mul = 1000;
    mul = cnx_clamp_mul_u16(mul, 1);
    if (mul != 1000) return 21;
    mul = 255;
    mul = cnx_clamp_mul_u16(mul, 257);
    if (mul != 65535) return 22;
    mul = 256;
    mul = cnx_clamp_mul_u16(mul, 256);
    if (mul != 65535) return 23;
    mul = 1000;
    mul = cnx_clamp_mul_u16(mul, 0);
    if (mul != 0) return 24;
    uint16_t div = 50000;
    div /= 100;
    if (div != 500) return 30;
    div = 1000;
    div /= 1;
    if (div != 1000) return 31;
    div = 65535;
    div /= 65535;
    if (div != 1) return 32;
    div = 10000;
    div /= 3;
    if (div != 3333) return 33;
    div = 0;
    div /= 100;
    if (div != 0) return 34;
    uint16_t mod = 10007;
    mod %= 1000;
    if (mod != 7) return 40;
    mod = 50000;
    mod %= 10000;
    if (mod != 0) return 41;
    mod = 12345;
    mod %= 7;
    if (mod != 4) return 42;
    mod = 65535;
    mod %= 256;
    if (mod != 255) return 43;
    mod = 1;
    mod %= 2;
    if (mod != 1) return 44;
    uint16_t and = 0xFFFF;
    and &= 0x00FF;
    if (and != 0x00FF) return 50;
    and = 0xAAAA;
    and &= 0x5555;
    if (and != 0) return 51;
    and = 0x5555;
    and &= 0xFFFF;
    if (and != 0x5555) return 52;
    and = 0xFF00;
    and &= 0x00FF;
    if (and != 0) return 53;
    uint16_t or = 0x00FF;
    or |= 0xFF00;
    if (or != 0xFFFF) return 60;
    or = 0x5555;
    or |= 0x0000;
    if (or != 0x5555) return 61;
    or = 0xAAAA;
    or |= 0x5555;
    if (or != 0xFFFF) return 62;
    uint16_t xor = 0xAAAA;
    xor ^= 0x5555;
    if (xor != 0xFFFF) return 70;
    xor = 0xFFFF;
    xor ^= 0xFFFF;
    if (xor != 0) return 71;
    xor = 0x5555;
    xor ^= 0x5555;
    if (xor != 0) return 72;
    xor = 0x00FF;
    xor ^= 0xFF00;
    if (xor != 0xFFFF) return 73;
    uint16_t shl = 1;
    shl <<= 0;
    if (shl != 1) return 80;
    shl = 1;
    shl <<= 1;
    if (shl != 2) return 81;
    shl = 1;
    shl <<= 8;
    if (shl != 256) return 82;
    shl = 1;
    shl <<= 15;
    if (shl != 32768) return 83;
    shl = 0x00FF;
    shl <<= 8;
    if (shl != 0xFF00) return 84;
    uint16_t shr = 32768;
    shr >>= 0;
    if (shr != 32768) return 90;
    shr = 32768;
    shr >>= 1;
    if (shr != 16384) return 91;
    shr = 32768;
    shr >>= 15;
    if (shr != 1) return 92;
    shr = 0xFF00;
    shr >>= 8;
    if (shr != 0x00FF) return 93;
    shr = 65535;
    shr >>= 8;
    if (shr != 255) return 94;
    return 0;
}
