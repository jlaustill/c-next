// test-execution
// Test: ADR-016 + ADR-044 Wrap overflow modifier inside scopes
// Verifies that wrap modifier works correctly with integer types inside scope methods
// Tests: wrap variables accessed via this. accessor with compound assignment operators

scope WrapTest {
    // Wrap scope variables - unsigned integers
    wrap u8 byteCounter <- 250;
    wrap u16 tickCount <- 65530;
    wrap u32 cycleCounter <- 4294967290;

    // Wrap scope variables - smaller values for testing wrap-around
    wrap u8 brightness <- 10;
    wrap u16 sensorValue <- 100;
    wrap u32 position <- 50;

    // Public getter methods using this. accessor for wrap variables
    public u8 getByteCounter() {
        return this.byteCounter;
    }

    public u16 getTickCount() {
        return this.tickCount;
    }

    public u32 getCycleCounter() {
        return this.cycleCounter;
    }

    public u8 getBrightness() {
        return this.brightness;
    }

    public u16 getSensorValue() {
        return this.sensorValue;
    }

    public u32 getPosition() {
        return this.position;
    }

    // Increment methods using wrap compound add (+<-)
    // These test overflow wrapping (back to 0 and continue)
    public void incrementByteCounter() {
        this.byteCounter +<- 10;  // 250 + 10 = 260 -> wraps to 4
    }

    public void incrementTickCount() {
        this.tickCount +<- 10;  // 65530 + 10 = 65540 -> wraps to 4
    }

    public void incrementCycleCounter() {
        this.cycleCounter +<- 10;  // Would overflow and wrap
    }

    // Simple increment (no overflow expected)
    public void incrementBrightness() {
        this.brightness +<- 5;  // Normal increment, no wrap
    }

    public void incrementSensorValue() {
        this.sensorValue +<- 100;  // Normal increment, no wrap
    }

    public void incrementPosition() {
        this.position +<- 1000;  // Normal increment, no wrap
    }

    // Decrement methods using wrap compound subtract (-<-)
    // These test underflow wrapping (back to MAX and continue)
    public void decrementBrightness() {
        this.brightness -<- 20;  // 10 - 20 = -10 -> wraps to 246
    }

    public void decrementSensorValue() {
        this.sensorValue -<- 150;  // 100 - 150 = -50 -> wraps to 65486
    }

    public void decrementPosition() {
        this.position -<- 100;  // 50 - 100 = -50 -> wraps to UINT32_MAX - 49
    }

    // Normal decrements (no underflow expected)
    public void decrementByteCounter() {
        this.byteCounter -<- 1;  // Normal decrement
    }

    public void decrementTickCount() {
        this.tickCount -<- 1;  // Normal decrement
    }

    public void decrementCycleCounter() {
        this.cycleCounter -<- 1;  // Normal decrement
    }

    // Setter methods for resetting state
    public void setByteCounter(u8 val) {
        this.byteCounter <- val;
    }

    public void setBrightness(u8 val) {
        this.brightness <- val;
    }

    public void setSensorValue(u16 val) {
        this.sensorValue <- val;
    }

    public void setPosition(u32 val) {
        this.position <- val;
    }
}

u32 main() {

// Test 1-6: Validate initial values
    u8 byteResult <- WrapTest.getByteCounter();
    if (byteResult != 250) return 1;
    u16 tickResult <- WrapTest.getTickCount();
    if (tickResult != 65530) return 2;
    u32 cycleResult <- WrapTest.getCycleCounter();
    if (cycleResult != 4294967290) return 3;
    u8 brightResult <- WrapTest.getBrightness();
    if (brightResult != 10) return 4;
    u16 sensorResult <- WrapTest.getSensorValue();
    if (sensorResult != 100) return 5;
    u32 posResult <- WrapTest.getPosition();
    if (posResult != 50) return 6;


// Test 7: u8 overflow wraps around (250 + 10 = 260 -> 4)
    WrapTest.incrementByteCounter();
    byteResult <- WrapTest.getByteCounter();
    if (byteResult != 4) return 7;


// Test 8: u16 overflow wraps around (65530 + 10 = 65540 -> 4)
    WrapTest.incrementTickCount();
    tickResult <- WrapTest.getTickCount();
    if (tickResult != 4) return 8;


// Test 9: u32 overflow wraps around (4294967290 + 10 = 4294967300 -> 4)
    WrapTest.incrementCycleCounter();
    cycleResult <- WrapTest.getCycleCounter();
    if (cycleResult != 4) return 9;


// Test 10: Normal u8 increment (10 + 5 = 15)
    brightResult <- WrapTest.getBrightness();
    if (brightResult != 10) return 100;  // Verify initial
    WrapTest.incrementBrightness();
    brightResult <- WrapTest.getBrightness();
    if (brightResult != 15) return 10;


// Test 11: Normal u16 increment (100 + 100 = 200)
    WrapTest.incrementSensorValue();
    sensorResult <- WrapTest.getSensorValue();
    if (sensorResult != 200) return 11;


// Test 12: Normal u32 increment (50 + 1000 = 1050)
    WrapTest.incrementPosition();
    posResult <- WrapTest.getPosition();
    if (posResult != 1050) return 12;


// Test 13: u8 underflow wraps around
    // Reset brightness to 10 first
    WrapTest.setBrightness(10);
    WrapTest.decrementBrightness();  // 10 - 20 = -10 -> wraps to 246
    brightResult <- WrapTest.getBrightness();
    if (brightResult != 246) return 13;


// Test 14: u16 underflow wraps around
    // Reset sensorValue to 100 first
    WrapTest.setSensorValue(100);
    WrapTest.decrementSensorValue();  // 100 - 150 = -50 -> wraps to 65486
    sensorResult <- WrapTest.getSensorValue();
    if (sensorResult != 65486) return 14;


// Test 15: u32 underflow wraps around
    // Reset position to 50 first
    WrapTest.setPosition(50);
    WrapTest.decrementPosition();  // 50 - 100 = -50 -> wraps to UINT32_MAX - 49 = 4294967246
    posResult <- WrapTest.getPosition();
    if (posResult != 4294967246) return 15;


// Test 16: Normal decrement (byteCounter persists from test 7)
    // byteCounter is 4 after test 7 (250 + 10 wrapped to 4)
    WrapTest.decrementByteCounter();  // 4 - 1 = 3
    byteResult <- WrapTest.getByteCounter();
    if (byteResult != 3) return 16;

    // All 16 validations passed
    return 0;
}
