/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// test-execution
// Tests: multi-dimensional u16 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: sensor data, medium-range counters, port numbers
uint16_t matrix2d[4][8] = {0};

uint16_t cube3d[2][3][4] = {0};

int main(void) {
    matrix2d[0][0] = 1000U;
    matrix2d[0][7] = 20000U;
    matrix2d[1][3] = 30000U;
    matrix2d[3][7] = 65535U;
    if (matrix2d[0][0] != 1000) return 1;
    if (matrix2d[0][7] != 20000) return 2;
    if (matrix2d[1][3] != 30000) return 3;
    if (matrix2d[3][7] != 65535) return 4;
    cube3d[0][0][0] = 100U;
    cube3d[0][0][3] = 500U;
    cube3d[0][2][3] = 1000U;
    cube3d[1][0][0] = 10000U;
    cube3d[1][2][3] = 50000U;
    if (cube3d[0][0][0] != 100) return 5;
    if (cube3d[0][0][3] != 500) return 6;
    if (cube3d[0][2][3] != 1000) return 7;
    if (cube3d[1][0][0] != 10000) return 8;
    if (cube3d[1][2][3] != 50000) return 9;
    if (4 != 4) return 10;
    if (8 != 8) return 11;
    if (16 != 16) return 12;
    if (2 != 2) return 13;
    if (3 != 3) return 14;
    if (4 != 4) return 15;
    if (16 != 16) return 16;
    for (uint32_t i = 0; i < 4; i += 1) {
        for (uint32_t j = 0; j < 8; j += 1) {
            matrix2d[i][j] = i * 100U + j;
        }
    }
    if (matrix2d[0][0] != 0) return 17;
    if (matrix2d[0][7] != 7) return 18;
    if (matrix2d[1][3] != 103) return 19;
    if (matrix2d[3][7] != 307) return 20;
    uint32_t sum = 0U;
    for (uint32_t i = 0; i < 2; i += 1) {
        for (uint32_t j = 0; j < 3; j += 1) {
            for (uint32_t k = 0; k < 4; k += 1) {
                cube3d[i][j][k] = i * 100U + j * 10U + k;
                sum = cnx_clamp_add_u32(sum, cube3d[i][j][k]);
            }
        }
    }
    if (sum != 1476) return 21;
    matrix2d[2][4] = 60000U;
    if (matrix2d[2][4] != 60000) return 22;
    matrix2d[3][7] = 555U;
    if (matrix2d[3][7] != 555) return 23;
    uint16_t testArray[3][2] = {0};
    for (uint32_t ti = 0; ti < 3; ti += 1) {
        for (uint32_t tj = 0; tj < 2; tj += 1) {
            testArray[ti][tj] = 0U;
        }
    }
    testArray[0][0] = 0U;
    testArray[0][1] = 65535U;
    testArray[1][0] = 32768U;
    testArray[2][1] = 1000U;
    if (testArray[0][0] != 0) return 24;
    if (testArray[0][1] != 65535) return 25;
    if (testArray[1][0] != 32768) return 26;
    if (testArray[2][1] != 1000) return 27;
    uint16_t ports[3][3] = {0};
    for (uint32_t pi = 0; pi < 3; pi += 1) {
        for (uint32_t pj = 0; pj < 3; pj += 1) {
            ports[pi][pj] = 0U;
        }
    }
    ports[0][0] = 80U;
    ports[0][1] = 443U;
    ports[1][0] = 22U;
    ports[1][1] = 3306U;
    ports[2][0] = 5432U;
    ports[2][1] = 8080U;
    if (ports[0][0] != 80) return 28;
    if (ports[0][1] != 443) return 29;
    if (ports[1][0] != 22) return 30;
    if (ports[1][1] != 3306) return 31;
    if (ports[2][0] != 5432) return 32;
    if (ports[2][1] != 8080) return 33;
    uint16_t data[2][2] = {0};
    for (uint32_t di = 0; di < 2; di += 1) {
        for (uint32_t dj = 0; dj < 2; dj += 1) {
            data[di][dj] = 0U;
        }
    }
    data[0][0] = 30000U;
    data[0][1] = 35000U;
    uint32_t largeSum = data[0U][0U] + data[0U][1U];
    if (largeSum != 65000) return 34;
    return 0;
}
