/**
 * Generated by C-Next Transpiler from: struct-compound-all-ops.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// Test: All compound assignment operators on struct members
// Covers: +<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-
typedef struct Data {
    uint32_t add_val;
    uint32_t sub_val;
    uint32_t mul_val;
    uint32_t div_val;
    uint32_t mod_val;
    uint32_t and_val;
    uint32_t or_val;
    uint32_t xor_val;
    uint32_t shl_val;
    uint32_t shr_val;
} Data;

Data d = {0};

int main(void) {
    d.add_val = 100U;
    d.sub_val = 50U;
    d.mul_val = 10U;
    d.div_val = 100U;
    d.mod_val = 17U;
    d.and_val = 0b11110000U;
    d.or_val = 0b00001111U;
    d.xor_val = 0b10101010U;
    d.shl_val = 8U;
    d.shr_val = 128U;
    d.add_val += 25U;
    d.sub_val -= 15U;
    d.mul_val *= 7U;
    d.div_val /= 4U;
    d.mod_val %= 5U;
    d.and_val &= 0b11001100U;
    d.or_val |= 0b11110000U;
    d.xor_val ^= 0b11111111U;
    d.shl_val <<= 2U;
    d.shr_val >>= 3U;
    if (d.add_val != 125) {
        return 1;
    }
    if (d.sub_val != 35) {
        return 2;
    }
    if (d.mul_val != 70) {
        return 3;
    }
    if (d.div_val != 25) {
        return 4;
    }
    if (d.mod_val != 2) {
        return 5;
    }
    if (d.and_val != 192) {
        return 6;
    }
    if (d.or_val != 255) {
        return 7;
    }
    if (d.xor_val != 85) {
        return 8;
    }
    if (d.shl_val != 32) {
        return 9;
    }
    if (d.shr_val != 16) {
        return 10;
    }
    return 0;
}
