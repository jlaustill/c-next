/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// ADR-013: Short-circuit evaluation prevents unsafe operations
// Critical for embedded systems where bounds checking and validation matter
uint32_t accessCount = 0;

uint32_t dangerousValue = 0;

bool isIndexSafe(const uint32_t* index) {
    return (*index) < 5;
}

uint32_t performDangerousOperation(const uint32_t* index) {
    accessCount = cnx_clamp_add_u32(accessCount, 1);
    dangerousValue = (*index) * 2;
    return dangerousValue;
}

void testSafeGuardPattern(void) {
    accessCount = 0;
    bool result = isIndexSafe(&(uint32_t){10}) && (performDangerousOperation(&(uint32_t){10}) > 0);
}

void testSafeGuardPatternValid(void) {
    accessCount = 0;
    bool result = isIndexSafe(&(uint32_t){2}) && (performDangerousOperation(&(uint32_t){2}) >= 0);
}

void testOrSafetyPattern(void) {
    accessCount = 0;
    uint32_t invalidIndex = 100;
    bool shouldUseDefault = (invalidIndex >= 5) || (performDangerousOperation(&invalidIndex) == 0);
}

typedef struct {
    uint32_t enabled;
    uint32_t value;
} TStatusRegister;

TStatusRegister status = {0};

void testNullLikeCheck(void) {
    status.enabled = 0;
    accessCount = 0;
    bool shouldRead = (status.enabled != 0) && (status.value > 0);
}
