/**
 * C Header Generator
 *
 * Generates C header (.h) files from C-Next source with C semantics
 * (pointer-based pass-by-reference).
 */

import ISymbol from "../../../utils/types/ISymbol";
import IParameterSymbol from "../../../utils/types/IParameterSymbol";
import IHeaderOptions from "../codegen/types/IHeaderOptions";
import IHeaderTypeInput from "./generators/IHeaderTypeInput";
import typeUtils from "./generators/mapType";
import generateEnumHeader from "./generators/generateEnumHeader";
import generateStructHeader from "./generators/generateStructHeader";
import generateBitmapHeader from "./generators/generateBitmapHeader";
import HeaderGeneratorUtils from "./HeaderGeneratorUtils";

const { mapType } = typeUtils;

/** Pass-by-value parameter info from CodeGenerator */
type TPassByValueParams = ReadonlyMap<string, ReadonlySet<string>>;

/**
 * Generates C header files with pointer-based semantics
 */
class CHeaderGenerator {
  /**
   * Generate a C header file from symbols
   */
  generate(
    symbols: ISymbol[],
    filename: string,
    options: IHeaderOptions = {},
    typeInput?: IHeaderTypeInput,
    passByValueParams?: TPassByValueParams,
    allKnownEnums?: ReadonlySet<string>,
  ): string {
    const lines: string[] = [];
    const guard = HeaderGeneratorUtils.makeGuard(filename, options.guardPrefix);

    // Filter to exported symbols if requested
    const exportedSymbols = options.exportedOnly
      ? symbols.filter((s) => s.isExported)
      : symbols;

    // Group symbols by kind
    const groups = HeaderGeneratorUtils.groupSymbolsByKind(exportedSymbols);

    // Get local type names for external type detection
    const localTypes = HeaderGeneratorUtils.getLocalTypeNames(groups);

    // Collect external type dependencies
    const externalTypes = HeaderGeneratorUtils.collectExternalTypes(
      groups.functions,
      groups.variables,
      localTypes.localStructNames,
      localTypes.localEnumNames,
      localTypes.localTypeNames,
      localTypes.localBitmapNames,
      allKnownEnums,
    );

    // Build external type header includes
    const { typesWithHeaders, headersToInclude } =
      HeaderGeneratorUtils.buildExternalTypeIncludes(
        externalTypes,
        options.externalTypeHeaders,
      );

    // Get symbol table for C++ namespace detection
    const symbolTable = typeInput?.symbolTable;

    // Header guard and comment
    lines.push(
      `#ifndef ${guard}`,
      `#define ${guard}`,
      "",
      "/**",
      " * Generated by C-Next Transpiler",
      " * Header file for cross-language interoperability",
      " */",
      "",
    );

    // System includes
    if (options.includeSystemHeaders !== false) {
      lines.push("#include <stdint.h>", "#include <stdbool.h>");
    }

    // User includes
    if (options.userIncludes && options.userIncludes.length > 0) {
      for (const include of options.userIncludes) {
        lines.push(include);
      }
    }

    // External type header includes
    if (headersToInclude.size > 0) {
      for (const directive of headersToInclude) {
        lines.push(directive);
      }
    }

    // Blank line after includes
    const hasIncludes =
      options.includeSystemHeaders !== false ||
      (options.userIncludes && options.userIncludes.length > 0) ||
      headersToInclude.size > 0;
    if (hasIncludes) {
      lines.push("");
    }

    // C++ compatibility wrapper
    lines.push("#ifdef __cplusplus", 'extern "C" {', "#endif", "");

    // Forward declarations for external types without known headers
    const cCompatibleExternalTypes =
      HeaderGeneratorUtils.filterCCompatibleTypes(
        externalTypes,
        typesWithHeaders,
        symbolTable,
      );
    if (cCompatibleExternalTypes.length > 0) {
      lines.push(
        "/* External type dependencies - include appropriate headers */",
      );
      for (const typeName of cCompatibleExternalTypes) {
        lines.push(`typedef struct ${typeName} ${typeName};`);
      }
      lines.push("");
    }

    // Enums (before structs - structs may reference enums)
    if (groups.enums.length > 0) {
      lines.push("/* Enumerations */");
      for (const sym of groups.enums) {
        if (typeInput) {
          lines.push(generateEnumHeader(sym.name, typeInput));
        } else {
          lines.push(`/* Enum: ${sym.name} (see implementation for values) */`);
        }
      }
      lines.push("");
    }

    // Bitmaps
    if (groups.bitmaps.length > 0) {
      lines.push("/* Bitmaps */");
      for (const sym of groups.bitmaps) {
        if (typeInput) {
          lines.push(generateBitmapHeader(sym.name, typeInput));
        } else {
          lines.push(
            `/* Bitmap: ${sym.name} (see implementation for layout) */`,
          );
        }
      }
      lines.push("");
    }

    // Type aliases
    if (groups.types.length > 0) {
      lines.push("/* Type aliases */");
      for (const sym of groups.types) {
        if (sym.type) {
          const cType = mapType(sym.type);
          lines.push(`typedef ${cType} ${sym.name};`);
        }
      }
      lines.push("");
    }

    // Structs and classes
    if (groups.structs.length > 0 || groups.classes.length > 0) {
      if (typeInput) {
        lines.push("/* Struct definitions */");
        for (const sym of groups.structs) {
          lines.push(generateStructHeader(sym.name, typeInput));
        }
        for (const sym of groups.classes) {
          lines.push(generateStructHeader(sym.name, typeInput));
        }
      } else {
        lines.push("/* Forward declarations */");
        for (const sym of groups.structs) {
          lines.push(`typedef struct ${sym.name} ${sym.name};`);
        }
        for (const sym of groups.classes) {
          lines.push(`typedef struct ${sym.name} ${sym.name};`);
        }
      }
      lines.push("");
    }

    // Extern variables (C-compatible only)
    const cCompatibleVariables =
      HeaderGeneratorUtils.filterCCompatibleVariables(
        groups.variables,
        symbolTable,
      );
    if (cCompatibleVariables.length > 0) {
      lines.push("/* External variables */");
      for (const sym of cCompatibleVariables) {
        const constPrefix = sym.isConst ? "const " : "";
        const volatilePrefix = sym.isAtomic ? "volatile " : "";
        const arrayDims =
          sym.isArray && sym.arrayDimensions
            ? sym.arrayDimensions.map((d) => `[${d}]`).join("")
            : "";

        const declaration = HeaderGeneratorUtils.formatVariableDeclaration(
          sym.type || "int",
          sym.name,
          arrayDims,
          constPrefix,
          volatilePrefix,
        );
        lines.push(`extern ${declaration};`);
      }
      lines.push("");
    }

    // Function prototypes
    if (groups.functions.length > 0) {
      lines.push("/* Function prototypes */");
      for (const sym of groups.functions) {
        const proto = this.generateFunctionPrototype(
          sym,
          passByValueParams,
          allKnownEnums,
        );
        if (proto) {
          lines.push(proto);
        }
      }
      lines.push("");
    }

    // C++ compatibility end and header guard
    lines.push(
      "#ifdef __cplusplus",
      "}",
      "#endif",
      "",
      `#endif /* ${guard} */`,
      "",
    );

    return lines.join("\n");
  }

  /**
   * Generate a C function prototype with pointer-based pass-by-reference
   */
  private generateFunctionPrototype(
    sym: ISymbol,
    passByValueParams?: TPassByValueParams,
    allKnownEnums?: ReadonlySet<string>,
  ): string | null {
    // Map return type (main() always returns int)
    const mappedType = sym.type ? mapType(sym.type) : "void";
    const returnType = sym.name === "main" ? "int" : mappedType;

    // Get pass-by-value parameter names for this function
    const passByValueSet = passByValueParams?.get(sym.name);

    // Build parameter list
    let params = "void";

    if (sym.parameters && sym.parameters.length > 0) {
      const translatedParams = sym.parameters.map((p) =>
        this.generateParameter(p, passByValueSet, allKnownEnums),
      );
      params = translatedParams.join(", ");
    }

    return `${returnType} ${sym.name}(${params});`;
  }

  /**
   * Generate a single C parameter with pointer semantics
   */
  private generateParameter(
    p: IParameterSymbol,
    passByValueSet?: ReadonlySet<string>,
    allKnownEnums?: ReadonlySet<string>,
  ): string {
    const baseType = mapType(p.type);
    const constMod = p.isConst ? "const " : "";
    const autoConst = p.isAutoConst ? "const " : "";

    // Array parameters - pass naturally as pointers per C semantics
    if (p.isArray && p.arrayDimensions) {
      const dims = p.arrayDimensions.map((d) => `[${d}]`).join("");
      if (p.type === "string") {
        return `${autoConst}${constMod}char* ${p.name}${dims}`;
      }
      return `${autoConst}${constMod}${baseType} ${p.name}${dims}`;
    }

    // ISR is a function pointer typedef - no pointer needed
    if (p.type === "ISR") {
      return `${constMod}${baseType} ${p.name}`;
    }

    // Float types use standard C pass-by-value
    if (p.type === "f32" || p.type === "f64") {
      return `${constMod}${baseType} ${p.name}`;
    }

    // Enum types use pass-by-value (like primitives in C)
    if (allKnownEnums?.has(p.type)) {
      return `${constMod}${baseType} ${p.name}`;
    }

    // Check if parameter should be passed by value
    if (passByValueSet?.has(p.name)) {
      return `${constMod}${baseType} ${p.name}`;
    }

    // Default: pass by pointer (C semantics)
    return `${autoConst}${constMod}${baseType}* ${p.name}`;
  }
}

export default CHeaderGenerator;
