/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-execution
// Tests: Struct parameters are always pass-by-reference (ADR-006)
// Coverage: Struct modification visible to caller
typedef struct Point {
    int32_t x;
    int32_t y;
} Point;

typedef struct Counter {
    uint32_t value;
    uint32_t maxValue;
} Counter;

// Struct params are ALWAYS pass-by-reference in C-Next
// Modifications are visible to caller
void movePoint(Point& p, int32_t dx, int32_t dy) {
    p.x += dx;
    p.y += dy;
}

void resetPoint(Point& p) {
    p.x = 0;
    p.y = 0;
}

void incrementCounter(Counter& c) {
    if (c.value < c.maxValue) {
        c.value += 1;
    }
}

void setCounterMax(Counter& c, uint32_t newMax) {
    c.maxValue = newMax;
}

// Read-only struct access (still pass-by-reference, but const)
int32_t getPointSum(const Point& p) {
    return p.x + p.y;
}

uint32_t getCounterValue(const Counter& c) {
    return c.value;
}

bool isCounterAtMax(const Counter& c) {
    return c.value == c.maxValue;
}

int main(void) {
    Point pt = (Point){ .x = 10, .y = 20 };
    movePoint(pt, 5, -3);
    if (pt.x != 15) return 1;
    if (pt.y != 17) return 2;
    resetPoint(pt);
    if (pt.x != 0) return 3;
    if (pt.y != 0) return 4;
    Counter cnt = (Counter){ .value = 0, .maxValue = 5 };
    incrementCounter(cnt);
    if (cnt.value != 1) return 5;
    incrementCounter(cnt);
    incrementCounter(cnt);
    if (cnt.value != 3) return 6;
    cnt.value = 5;
    incrementCounter(cnt);
    if (cnt.value != 5) return 7;
    setCounterMax(cnt, 10);
    if (cnt.maxValue != 10) return 8;
    incrementCounter(cnt);
    if (cnt.value != 6) return 9;
    Point readPt = (Point){ .x = 100, .y = 200 };
    int32_t sum = getPointSum(readPt);
    if (sum != 300) return 10;
    if (readPt.x != 100) return 11;
    if (readPt.y != 200) return 12;
    Counter readCnt = (Counter){ .value = 42, .maxValue = 100 };
    uint32_t val = getCounterValue(readCnt);
    if (val != 42) return 13;
    bool atMax = isCounterAtMax(readCnt);
    if (atMax != false) return 14;
    readCnt.value = 100;
    atMax = isCounterAtMax(readCnt);
    if (atMax != true) return 15;
    return 0;
}
