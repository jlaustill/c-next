/**
 * Generated by C-Next Transpiler from: u8-compound-assign.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint32_t b) {
    if (b > (uint32_t)(UINT8_MAX - a)) return UINT8_MAX;
    uint8_t result;
    if (__builtin_add_overflow(a, (uint8_t)b, &result)) return UINT8_MAX;
    return result;
}

static inline uint8_t cnx_clamp_mul_u8(uint8_t a, uint32_t b) {
    if (b != 0 && a > UINT8_MAX / b) return UINT8_MAX;
    uint8_t result;
    if (__builtin_mul_overflow(a, (uint8_t)b, &result)) return UINT8_MAX;
    return result;
}

static inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint32_t b) {
    if (b > (uint32_t)a) return 0;
    uint8_t result;
    if (__builtin_sub_overflow(a, (uint8_t)b, &result)) return 0;
    return result;
}

// test-execution
// Tests: u8 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: 0 to 255
int main(void) {
    uint8_t val = 100U;
    val = cnx_clamp_add_u8(val, 50U);
    if (val != 150) return 1;
    val = 200U;
    val = cnx_clamp_add_u8(val, 0U);
    if (val != 200) return 2;
    val = 0U;
    val = cnx_clamp_add_u8(val, 255U);
    if (val != 255) return 3;
    val = 254U;
    val = cnx_clamp_add_u8(val, 1U);
    if (val != 255) return 4;
    uint8_t sub = 200U;
    sub = cnx_clamp_sub_u8(sub, 50U);
    if (sub != 150) return 10;
    sub = 100U;
    sub = cnx_clamp_sub_u8(sub, 0U);
    if (sub != 100) return 11;
    sub = 255U;
    sub = cnx_clamp_sub_u8(sub, 254U);
    if (sub != 1) return 12;
    sub = 100U;
    sub = cnx_clamp_sub_u8(sub, 100U);
    if (sub != 0) return 13;
    sub = 1U;
    sub = cnx_clamp_sub_u8(sub, 1U);
    if (sub != 0) return 14;
    uint8_t mul = 10U;
    mul = cnx_clamp_mul_u8(mul, 10U);
    if (mul != 100) return 20;
    mul = 50U;
    mul = cnx_clamp_mul_u8(mul, 1U);
    if (mul != 50) return 21;
    mul = 17U;
    mul = cnx_clamp_mul_u8(mul, 15U);
    if (mul != 255) return 22;
    mul = 128U;
    mul = cnx_clamp_mul_u8(mul, 2U);
    if (mul != 255) return 23;
    mul = 100U;
    mul = cnx_clamp_mul_u8(mul, 0U);
    if (mul != 0) return 24;
    uint8_t div = 200U;
    div = static_cast<uint8_t>((div / 10U));
    if (div != 20) return 30;
    div = 50U;
    div = static_cast<uint8_t>((div / 1U));
    if (div != 50) return 31;
    div = 255U;
    div = static_cast<uint8_t>((div / 255U));
    if (div != 1) return 32;
    div = 100U;
    div = static_cast<uint8_t>((div / 3U));
    if (div != 33) return 33;
    div = 0U;
    div = static_cast<uint8_t>((div / 10U));
    if (div != 0) return 34;
    uint8_t mod = 107U;
    mod = static_cast<uint8_t>((mod % 10U));
    if (mod != 7) return 40;
    mod = 200U;
    mod = static_cast<uint8_t>((mod % 100U));
    if (mod != 0) return 41;
    mod = 17U;
    mod = static_cast<uint8_t>((mod % 5U));
    if (mod != 2) return 42;
    mod = 255U;
    mod = static_cast<uint8_t>((mod % 16U));
    if (mod != 15) return 43;
    mod = 1U;
    mod = static_cast<uint8_t>((mod % 2U));
    if (mod != 1) return 44;
    uint8_t andVal = 0xFFU;
    andVal = static_cast<uint8_t>((andVal & 0x0FU));
    if (andVal != 0x0F) return 50;
    andVal = 0xAAU;
    andVal = static_cast<uint8_t>((andVal & 0x55U));
    if (andVal != 0) return 51;
    andVal = 0x55U;
    andVal = static_cast<uint8_t>((andVal & 0xFFU));
    if (andVal != 0x55) return 52;
    andVal = 0xF0U;
    andVal = static_cast<uint8_t>((andVal & 0x0FU));
    if (andVal != 0) return 53;
    uint8_t orVal = 0x0FU;
    orVal = static_cast<uint8_t>((orVal | 0xF0U));
    if (orVal != 0xFF) return 60;
    orVal = 0x55U;
    orVal = static_cast<uint8_t>((orVal | 0x00U));
    if (orVal != 0x55) return 61;
    orVal = 0xAAU;
    orVal = static_cast<uint8_t>((orVal | 0x55U));
    if (orVal != 0xFF) return 62;
    uint8_t xorVal = 0xAAU;
    xorVal = static_cast<uint8_t>((xorVal ^ 0x55U));
    if (xorVal != 0xFF) return 70;
    xorVal = 0xFFU;
    xorVal = static_cast<uint8_t>((xorVal ^ 0xFFU));
    if (xorVal != 0) return 71;
    xorVal = 0x55U;
    xorVal = static_cast<uint8_t>((xorVal ^ 0x55U));
    if (xorVal != 0) return 72;
    xorVal = 0x0FU;
    xorVal = static_cast<uint8_t>((xorVal ^ 0xF0U));
    if (xorVal != 0xFF) return 73;
    uint8_t shl = 1U;
    shl = static_cast<uint8_t>((shl << 0U));
    if (shl != 1) return 80;
    shl = 1U;
    shl = static_cast<uint8_t>((shl << 1U));
    if (shl != 2) return 81;
    shl = 1U;
    shl = static_cast<uint8_t>((shl << 4U));
    if (shl != 16) return 82;
    shl = 1U;
    shl = static_cast<uint8_t>((shl << 7U));
    if (shl != 128) return 83;
    shl = 0x0FU;
    shl = static_cast<uint8_t>((shl << 4U));
    if (shl != 0xF0) return 84;
    uint8_t shr = 128U;
    shr = static_cast<uint8_t>((shr >> 0U));
    if (shr != 128) return 90;
    shr = 128U;
    shr = static_cast<uint8_t>((shr >> 1U));
    if (shr != 64) return 91;
    shr = 128U;
    shr = static_cast<uint8_t>((shr >> 7U));
    if (shr != 1) return 92;
    shr = 0xF0U;
    shr = static_cast<uint8_t>((shr >> 4U));
    if (shr != 0x0F) return 93;
    shr = 255U;
    shr = static_cast<uint8_t>((shr >> 4U));
    if (shr != 15) return 94;
    return 0;
}
