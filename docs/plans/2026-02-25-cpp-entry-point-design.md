# C/C++ Entry Point Support for Incremental Adoption

**Date:** 2026-02-25
**Status:** Approved

## Problem Statement

Currently, developers wanting to incrementally adopt C-Next face a frustrating workflow. If they convert a single leaf file to `.cnx` and try to run `cnext main.cpp`, they get:

```
Error: Cannot process implementation file 'main.cpp'. C-Next only compiles .cnx files.
```

This means developers must manually track and transpile each `.cnx` file separately, which is a major adoption barrier.

## Solution

Allow C/C++ implementation files (`.c`, `.cpp`, `.cc`, `.cxx`, `.c++`) as entry points to the transpiler. When given a C/C++ file, the transpiler:

1. Parses the include tree transitively
2. Identifies headers generated by C-Next (via marker comments)
3. Extracts the source `.cnx` path from each marker
4. Transpiles all discovered `.cnx` files in dependency order

## User Workflow

```bash
# Step 1: Convert a leaf file to C-Next
cnext led.cnx              # Generates led.h (with marker) and led.c

# Step 2: Include generated header in existing C/C++ code
# main.cpp: #include "led.h"

# Step 3: Run transpiler on entry point
cnext main.cpp             # Discovers and re-transpiles led.cnx
```

## Design Decisions

### 1. Generated Header Marker Format

Extend the existing generation comment to include the source path:

```c
/*
 * Generated by C-Next Transpiler from: led.cnx
 */
```

- Path is relative to the header's location
- First line of file for fast scanning
- Explicit prefix avoids false positives

### 2. Discovery Flow

```
main.cpp
    ↓ extract #includes, resolve paths
    ↓
[middleware.h, utils.h, ...]
    ↓ for each header:
    │   1. Read first lines, check for marker
    │   2. If marker found:
    │      a. Record the .cnx source path
    │      b. Parse the .cnx file's #includes
    │      c. Continue walking those includes transitively
    │   3. If no marker:
    │      a. Recursively extract its #includes
    ↓
[middleware.cnx, led.cnx]  ← full dependency tree
    ↓
Transpile in dependency order
```

**Key insight:** When we find a C-Next generated header, we pivot to scanning the **source `.cnx` file** for its includes, not the generated header. This ensures we follow the actual source dependency chain through nested includes.

### 3. Bootstrap Requirement

Developers must run `cnext file.cnx` once initially to generate the header with the marker. This is intentional:

- Avoids false positives from coincidental `.cnx`/`.h` name matches
- Provides explicit confirmation that a file is C-Next managed
- Simple two-step adoption path

### 4. Output Behavior

- Only `.cnx` files are transpiled — the entry C/C++ file is untouched
- Generated `.c` and `.h` files written to disk (same location as source)
- Existing `--header-out` flag works for placing headers elsewhere
- All discovered `.cnx` files are re-transpiled for consistency

### 5. CLI Messages

**Success case:**

```
Scanning main.cpp for C-Next includes...
Found 2 C-Next source files: led.cnx, config.cnx
Transpiling led.cnx... done
Transpiling config.cnx... done
```

**No C-Next files found:**

```
Scanning main.cpp for C-Next includes...
No C-Next files found in include tree. To get started:
  1. Create a .cnx file (e.g., led.cnx)
  2. Run: cnext led.cnx
  3. Include the generated header in your C/C++ code
  4. Re-run: cnext main.cpp
```

## Error Handling

| Scenario                        | Behavior                                                        |
| ------------------------------- | --------------------------------------------------------------- |
| Entry file doesn't exist        | Error: `File not found: main.cpp`                               |
| Marker points to missing `.cnx` | Error: `C-Next source not found: led.cnx (referenced by led.h)` |
| `.cnx` file has syntax errors   | Normal transpilation error                                      |
| Circular `.cnx` dependencies    | Existing `DependencyGraph` handles this                         |
| Header not readable             | Warning, skip and continue                                      |

## Files to Modify

| File                      | Changes                                         |
| ------------------------- | ----------------------------------------------- |
| `InputExpansion.ts`       | Accept C/C++ extensions as entry points         |
| `IncludeResolver.ts`      | Add marker detection and `.cnx` path extraction |
| `Transpiler.ts`           | New discovery flow for C/C++ entry points       |
| `HeaderGeneratorUtils.ts` | Add source path to generation marker            |
| `CodeGenerator.ts`        | Add source path to generation marker            |

## Testing Strategy

**Integration tests:**

| Test                       | Description                                                     |
| -------------------------- | --------------------------------------------------------------- |
| `cpp-entry-basic`          | `main.cpp` → `led.h` (marker) → transpiles `led.cnx`            |
| `cpp-entry-transitive`     | `main.cpp` → `utils.h` → `led.h` → transpiles `led.cnx`         |
| `cpp-entry-cnx-chain`      | `main.cpp` → `middleware.h` → `middleware.cnx` → `led.h` → both |
| `cpp-entry-no-cnx`         | No C-Next includes → helpful message                            |
| `cpp-entry-missing-source` | Marker points to nonexistent `.cnx` → clear error               |
| `cpp-entry-multiple`       | Multiple `.cnx` files → all transpiled in order                 |
| `c-entry-basic`            | Same with `.c` entry point                                      |

**Unit tests:**

- `InputExpansion`: Accept C/C++ extensions, classify correctly
- `IncludeResolver`: Marker detection, path extraction
- `Transpiler`: C/C++ entry point flow

## Reusable Infrastructure

The following existing components can be reused:

- `FileDiscovery` — Already classifies C/C++ files correctly
- `IncludeDiscovery.extractIncludesWithInfo()` — Works on any C-family source
- `IncludeResolver.resolveHeadersTransitively()` — Cycle-safe tree walking
- `DependencyGraph` — Topological sort for transpilation order
