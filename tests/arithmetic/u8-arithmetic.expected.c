/**
 * Generated by C-Next Transpiler from: u8-arithmetic.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: u8 arithmetic operations (+, -, *, /, %)
// Coverage: Section 4.1-4.5 for u8 type
int main(void) {
    uint8_t a = 100U;
    uint8_t b = 50U;
    uint8_t sum = a + b;
    if (sum != 150) return 1;
    uint8_t sum_zero = a + 0U;
    if (sum_zero != 100) return 2;
    uint8_t c = 200U;
    uint8_t d = 55U;
    uint8_t sum_large = c + d;
    if (sum_large != 255) return 3;
    uint8_t diff = a - b;
    if (diff != 50) return 4;
    uint8_t e = 100U;
    uint8_t f = 100U;
    uint8_t diff_zero = e - f;
    if (diff_zero != 0) return 5;
    uint8_t diff_zero2 = a - 0U;
    if (diff_zero2 != 100) return 6;
    uint8_t g = 10U;
    uint8_t h = 5U;
    uint8_t product = g * h;
    if (product != 50) return 7;
    uint8_t product_zero = g * 0U;
    if (product_zero != 0) return 8;
    uint8_t product_one = g * 1U;
    if (product_one != 10) return 9;
    uint8_t i = 15U;
    uint8_t j = 17U;
    uint8_t product_large = i * j;
    if (product_large != 255) return 10;
    uint8_t k = 100U;
    uint8_t l = 5U;
    uint8_t quotient = k / l;
    if (quotient != 20) return 11;
    uint8_t quotient_one = k / 1U;
    if (quotient_one != 100) return 12;
    uint8_t m = 100U;
    uint8_t n = 7U;
    uint8_t quotient_trunc = m / n;
    if (quotient_trunc != 14) return 13;
    uint8_t zero = 0U;
    uint8_t quotient_zero = zero / 5U;
    if (quotient_zero != 0) return 14;
    uint8_t o = 100U;
    uint8_t p = 7U;
    uint8_t remainder = o % p;
    if (remainder != 2) return 15;
    uint8_t q = 100U;
    uint8_t r = 5U;
    uint8_t remainder_zero = q % r;
    if (remainder_zero != 0) return 16;
    uint8_t s = 3U;
    uint8_t t = 10U;
    uint8_t remainder_small = s % t;
    if (remainder_small != 3) return 17;
    uint8_t remainder_zero2 = zero % 5U;
    if (remainder_zero2 != 0) return 18;
    uint8_t max_val = 255U;
    uint8_t one = 1U;
    uint8_t max_div = max_val / max_val;
    if (max_div != 1) return 19;
    uint8_t max_mod = max_val % max_val;
    if (max_mod != 0) return 20;
    uint8_t max_minus_one = max_val - one;
    if (max_minus_one != 254) return 21;
    uint8_t combined = (10U + 20U) * 2U;
    if (combined != 60) return 22;
    return 0;
}
