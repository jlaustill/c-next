/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int16_t cnx_clamp_add_i16(int16_t a, int32_t b) {
    int32_t result = (int32_t)a + b;
    if (result > INT16_MAX) return INT16_MAX;
    if (result < INT16_MIN) return INT16_MIN;
    return (int16_t)result;
}

static inline int16_t cnx_clamp_mul_i16(int16_t a, int32_t b) {
    int32_t result = (int32_t)a * b;
    if (result > INT16_MAX) return INT16_MAX;
    if (result < INT16_MIN) return INT16_MIN;
    return (int16_t)result;
}

static inline int16_t cnx_clamp_sub_i16(int16_t a, int32_t b) {
    int32_t result = (int32_t)a - b;
    if (result > INT16_MAX) return INT16_MAX;
    if (result < INT16_MIN) return INT16_MIN;
    return (int16_t)result;
}

// test-execution
// Tests: i16 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: -32768 to 32767
int main(void) {
    int16_t val = 10000;
    val = cnx_clamp_add_i16(val, 5000);
    if (val != 15000) return 1;
    val = -10000;
    val = cnx_clamp_add_i16(val, 5000);
    if (val != -5000) return 2;
    val = -10000;
    val = cnx_clamp_add_i16(val, -5000);
    if (val != -15000) return 3;
    val = 1000;
    val = cnx_clamp_add_i16(val, 0);
    if (val != 1000) return 4;
    val = -1000;
    val = cnx_clamp_add_i16(val, 1000);
    if (val != 0) return 5;
    val = 32766;
    val = cnx_clamp_add_i16(val, 1);
    if (val != 32767) return 6;
    int16_t sub = 15000;
    sub = cnx_clamp_sub_i16(sub, 5000);
    if (sub != 10000) return 10;
    sub = 5000;
    sub = cnx_clamp_sub_i16(sub, 10000);
    if (sub != -5000) return 11;
    sub = -10000;
    sub = cnx_clamp_sub_i16(sub, 5000);
    if (sub != -15000) return 12;
    sub = -10000;
    sub = cnx_clamp_sub_i16(sub, -5000);
    if (sub != -5000) return 13;
    sub = 1000;
    sub = cnx_clamp_sub_i16(sub, 0);
    if (sub != 1000) return 14;
    sub = -32767;
    sub = cnx_clamp_sub_i16(sub, 1);
    if (sub != -32768) return 15;
    int16_t mul = 100;
    mul = cnx_clamp_mul_i16(mul, 100);
    if (mul != 10000) return 20;
    mul = -100;
    mul = cnx_clamp_mul_i16(mul, 100);
    if (mul != -10000) return 21;
    mul = -100;
    mul = cnx_clamp_mul_i16(mul, -100);
    if (mul != 10000) return 22;
    mul = 1000;
    mul = cnx_clamp_mul_i16(mul, 1);
    if (mul != 1000) return 23;
    mul = 1000;
    mul = cnx_clamp_mul_i16(mul, -1);
    if (mul != -1000) return 24;
    mul = 123;
    mul = cnx_clamp_mul_i16(mul, 0);
    if (mul != 0) return 25;
    int16_t div = 10000;
    div = (int16_t)(div / 100);
    if (div != 100) return 30;
    div = -10000;
    div = (int16_t)(div / 100);
    if (div != -100) return 31;
    div = -10000;
    div = (int16_t)(div / -100);
    if (div != 100) return 32;
    div = 1000;
    div = (int16_t)(div / 1);
    if (div != 1000) return 33;
    div = -1000;
    div = (int16_t)(div / -1);
    if (div != 1000) return 34;
    div = 32767;
    div = (int16_t)(div / 32767);
    if (div != 1) return 35;
    int16_t mod = 10007;
    mod = (int16_t)(mod % 1000);
    if (mod != 7) return 40;
    mod = -10007;
    mod = (int16_t)(mod % 1000);
    if (mod != -7) return 41;
    mod = 12345;
    mod = (int16_t)(mod % 7);
    if (mod != 4) return 42;
    mod = -12345;
    mod = (int16_t)(mod % 7);
    if (mod != -4) return 43;
    mod = 1000;
    mod = (int16_t)(mod % 1000);
    if (mod != 0) return 44;
    int16_t andVal = 0x7FFF;
    andVal = (int16_t)(andVal & 0x00FF);
    if (andVal != 0x00FF) return 50;
    andVal = -1;
    andVal = (int16_t)(andVal & 0x00FF);
    if (andVal != 0x00FF) return 51;
    andVal = 0x5555;
    andVal = (int16_t)(andVal & 0xAAAA);
    if (andVal != 0) return 52;
    andVal = 0x0F0F;
    andVal = (int16_t)(andVal & 0xF0F0);
    if (andVal != 0) return 53;
    int16_t orVal = 0x00FF;
    orVal = (int16_t)(orVal | 0x7F00);
    if (orVal != 0x7FFF) return 60;
    orVal = 0x1200;
    orVal = (int16_t)(orVal | 0x0034);
    if (orVal != 0x1234) return 61;
    orVal = 0x1234;
    orVal = (int16_t)(orVal | 0x0000);
    if (orVal != 0x1234) return 62;
    int16_t xorVal = 0x5555;
    xorVal = (int16_t)(xorVal ^ 0x5555);
    if (xorVal != 0) return 70;
    xorVal = 0x0F0F;
    xorVal = (int16_t)(xorVal ^ 0x7070);
    if (xorVal != 0x7F7F) return 71;
    xorVal = -1;
    xorVal = (int16_t)(xorVal ^ -1);
    if (xorVal != 0) return 72;
    xorVal = 0x5555;
    xorVal = (int16_t)(xorVal ^ 0x2AAA);
    if (xorVal != 0x7FFF) return 73;
    int16_t shl = 1;
    shl = (int16_t)(shl << 0);
    if (shl != 1) return 80;
    shl = 1;
    shl = (int16_t)(shl << 1);
    if (shl != 2) return 81;
    shl = 1;
    shl = (int16_t)(shl << 8);
    if (shl != 256) return 82;
    shl = 1;
    shl = (int16_t)(shl << 14);
    if (shl != 16384) return 83;
    shl = -1;
    shl = (int16_t)(shl << 4);
    if (shl != -16) return 84;
    int16_t shr = 256;
    shr = (int16_t)(shr >> 0);
    if (shr != 256) return 90;
    shr = 256;
    shr = (int16_t)(shr >> 1);
    if (shr != 128) return 91;
    shr = 256;
    shr = (int16_t)(shr >> 8);
    if (shr != 1) return 92;
    shr = -16;
    shr = (int16_t)(shr >> 2);
    if (shr != -4) return 93;
    shr = -1;
    shr = (int16_t)(shr >> 10);
    if (shr != -1) return 94;
    return 0;
}
