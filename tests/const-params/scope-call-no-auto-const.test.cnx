// test-execution
// Tests: Issue #365 - scope-qualified calls should prevent auto-const
// When a parameter is passed to a scope method that modifies it,
// the parameter should NOT get const in the generated header.

struct AppConfig {
    u32 value;
    bool enabled;
}

// Simulates a storage manager that modifies the config it receives
scope Storage {
    public void load(AppConfig config) {
        // This modifies the config parameter
        config.value <- 42;
        config.enabled <- true;
    }

    public void save(AppConfig config) {
        // This only reads config - could be const
        u32 temp <- config.value;
    }
}

// Function that passes its parameter to Storage.load()
// Since Storage.load() modifies its param, this param should NOT get const
void loadConfig(AppConfig config) {
    global.Storage.load(config);
}

// Function that passes its parameter to Storage.save()
// Since Storage.save() only reads, this param SHOULD get const
void saveConfig(AppConfig config) {
    global.Storage.save(config);
}

// Direct call to scope method that modifies - should NOT get const
void directLoad(AppConfig config) {
    Storage.load(config);
}

u32 main() {
    AppConfig cfg;
    cfg.value <- 0;
    cfg.enabled <- false;

    // Test loadConfig - should modify cfg via Storage.load
    loadConfig(cfg);
    if (cfg.value != 42) return 1;
    if (cfg.enabled != true) return 2;

    // Reset
    cfg.value <- 100;
    cfg.enabled <- false;

    // Test directLoad - same behavior
    directLoad(cfg);
    if (cfg.value != 42) return 3;
    if (cfg.enabled != true) return 4;

    // Test saveConfig - should not modify cfg
    cfg.value <- 999;
    saveConfig(cfg);
    if (cfg.value != 999) return 5;  // unchanged

    return 0;
}
