/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// test-execution
// Tests: Pass-by-value for all primitive types
// Coverage: u8, u16, u32, u64, i8, i16, i32, i64, bool
// Unmodified functions - should pass by value
uint8_t doubleU8(uint8_t val) {
    return val * 2;
}

uint16_t doubleU16(uint16_t val) {
    return val * 2;
}

uint32_t doubleU32(uint32_t val) {
    return val * 2;
}

uint64_t doubleU64(uint64_t val) {
    return val * 2;
}

int8_t negateI8(int8_t val) {
    return -val;
}

int16_t negateI16(int16_t val) {
    return -val;
}

int32_t negateI32(int32_t val) {
    return -val;
}

int64_t negateI64(int64_t val) {
    return -val;
}

bool flipBool(bool val) {
    return !val;
}

// Modified functions - should pass by pointer
void incrementU8(uint8_t* val) {
    (*val) += 1;
}

void incrementU32(uint32_t* val) {
    (*val) += 1;
}

void incrementI32(int32_t* val) {
    (*val) += 1;
}

void toggleBool(bool* val) {
    (*val) = !(*val);
}

int main(void) {
    uint8_t u8Val = 10;
    uint8_t u8Result = doubleU8(u8Val);
    if (u8Val != 10) return 1;
    if (u8Result != 20) return 2;
    uint16_t u16Val = 1000;
    uint16_t u16Result = doubleU16(u16Val);
    if (u16Val != 1000) return 3;
    if (u16Result != 2000) return 4;
    uint32_t u32Val = 100000;
    uint32_t u32Result = doubleU32(u32Val);
    if (u32Val != 100000) return 5;
    if (u32Result != 200000) return 6;
    uint64_t u64Val = 1000000000;
    uint64_t u64Result = doubleU64(u64Val);
    if (u64Val != 1000000000) return 7;
    if (u64Result != 2000000000) return 8;
    int8_t i8Val = 50;
    int8_t i8Result = negateI8(i8Val);
    if (i8Val != 50) return 9;
    if (i8Result != -50) return 10;
    int16_t i16Val = 1000;
    int16_t i16Result = negateI16(i16Val);
    if (i16Val != 1000) return 11;
    if (i16Result != -1000) return 12;
    int32_t i32Val = 100000;
    int32_t i32Result = negateI32(i32Val);
    if (i32Val != 100000) return 13;
    if (i32Result != -100000) return 14;
    int64_t i64Val = 1000000000;
    int64_t i64Result = negateI64(i64Val);
    if (i64Val != 1000000000) return 15;
    if (i64Result != -1000000000) return 16;
    bool boolVal = true;
    bool boolResult = flipBool(boolVal);
    if (boolVal != true) return 17;
    if (boolResult != false) return 18;
    uint8_t modU8 = 100;
    incrementU8(&modU8);
    if (modU8 != 101) return 19;
    uint32_t modU32 = 1000;
    incrementU32(&modU32);
    if (modU32 != 1001) return 20;
    int32_t modI32 = -50;
    incrementI32(&modI32);
    if (modI32 != -49) return 21;
    bool modBool = false;
    toggleBool(&modBool);
    if (modBool != true) return 22;
    return 0;
}
