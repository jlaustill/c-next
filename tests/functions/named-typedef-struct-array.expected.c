/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// tests/functions/named-typedef-struct-array.test.cnx
// test-execution
// Tests: Issue #347 - named typedef struct array member passing
// When passing msg.buf (u8[8]) from a NAMED typedef struct to a function
// expecting const u8 data[8], the transpiler should NOT add '&' prefix.
// Arrays naturally decay to pointers in C/C++.
//
// This tests the pattern: typedef struct CAN_message_t { ... } CAN_message_t;
// (as opposed to anonymous: typedef struct { ... } CAN_message_t;)
#include "named-typedef-struct-array.h"

#include <stdint.h>

// Function that takes an array parameter
uint32_t processNamedStructBuffer(const uint8_t data[8], uint8_t len) {
    uint32_t sum = 0;
    uint8_t i = 0;
    while (i < len) {
        sum = sum + data[i];
        i = i + 1;
    }
    return sum;
}

// Test with CAN_message_t (named typedef struct)
uint32_t testCANMessage(void) {
    CAN_message_t msg = {};
    msg.buf[0] = 10;
    msg.buf[1] = 20;
    msg.buf[2] = 30;
    msg.buf[3] = 40;
    msg.buf[4] = 0;
    msg.buf[5] = 0;
    msg.buf[6] = 0;
    msg.buf[7] = 0;
    msg.len = 4;
    uint32_t result = processNamedStructBuffer(msg.buf, msg.len);
    return result;
}

// Test with CANFrame_t (another named typedef struct)
uint32_t testCANFrame(void) {
    CANFrame_t frame = {};
    frame.data[0] = 1;
    frame.data[1] = 2;
    frame.data[2] = 3;
    frame.data[3] = 4;
    frame.data[4] = 5;
    frame.data[5] = 6;
    frame.data[6] = 7;
    frame.data[7] = 8;
    frame.dlc = 8;
    uint32_t result = processNamedStructBuffer(frame.data, frame.dlc);
    return result;
}

// Test passing array member inside a scope (like the original bug report)
/* Scope: Handler */

void Handler_process(const uint8_t data[8], uint8_t len) {
}

uint32_t Handler_handleMessage(const CAN_message_t* msg) {
    Handler_process(msg->buf, msg->len);
    uint32_t sum = 0;
    uint8_t i = 0;
    while (i < msg->len) {
        sum = sum + msg->buf[i];
        i = i + 1;
    }
    return sum;
}

uint32_t testScopeHandler(void) {
    CAN_message_t msg = {};
    msg.buf[0] = 5;
    msg.buf[1] = 10;
    msg.buf[2] = 15;
    msg.buf[3] = 20;
    msg.len = 4;
    uint32_t result = Handler_handleMessage(&msg);
    return result;
}

int main(void) {
    uint32_t result1 = testCANMessage();
    if (result1 != 100) return 1;
    uint32_t result2 = testCANFrame();
    if (result2 != 36) return 2;
    uint32_t result3 = testScopeHandler();
    if (result3 != 50) return 3;
    return 0;
}
