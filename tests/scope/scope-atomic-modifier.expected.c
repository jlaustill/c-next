/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// Test: ADR-016 + ADR-049 Atomic variables inside scopes
// Verifies that atomic modifier works correctly with integer types inside scope methods
// Tests: atomic variables accessed via this. accessor with compound assignment operators

#include <stdint.h>
#include <cmsis_gcc.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint8_t b) {
    if (a > UINT8_MAX - b) return UINT8_MAX;
    return a + b;
}

static inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint8_t b) {
    if (a < b) return 0;
    return a - b;
}

static inline uint16_t cnx_clamp_add_u16(uint16_t a, uint16_t b) {
    if (a > UINT16_MAX - b) return UINT16_MAX;
    return a + b;
}

static inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint16_t b) {
    if (a < b) return 0;
    return a - b;
}

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {
    if (a > UINT32_MAX - b) return UINT32_MAX;
    return a + b;
}

/* Scope: AtomicTest */
volatile uint8_t AtomicTest_counterU8 = 0;
volatile uint16_t AtomicTest_counterU16 = 0;
volatile uint32_t AtomicTest_counterU32 = 0;
volatile uint8_t AtomicTest_brightness = 100;
volatile uint16_t AtomicTest_position = 500;
volatile uint32_t AtomicTest_ticks = 0;

uint8_t AtomicTest_getCounterU8(void) {
    return AtomicTest_counterU8;
}

uint16_t AtomicTest_getCounterU16(void) {
    return AtomicTest_counterU16;
}

uint32_t AtomicTest_getCounterU32(void) {
    return AtomicTest_counterU32;
}

uint8_t AtomicTest_getBrightness(void) {
    return AtomicTest_brightness;
}

uint16_t AtomicTest_getPosition(void) {
    return AtomicTest_position;
}

uint32_t AtomicTest_getTicks(void) {
    return AtomicTest_ticks;
}

void AtomicTest_incrementU8(void) {
    do {
        uint8_t __old = __LDREXB(&AtomicTest_counterU8);
        uint8_t __new = cnx_clamp_add_u8(__old, 1);
        if (__STREXB(__new, &AtomicTest_counterU8) == 0) break;
    } while (1);
}

void AtomicTest_incrementU16(void) {
    do {
        uint16_t __old = __LDREXH(&AtomicTest_counterU16);
        uint16_t __new = cnx_clamp_add_u16(__old, 1);
        if (__STREXH(__new, &AtomicTest_counterU16) == 0) break;
    } while (1);
}

void AtomicTest_incrementU32(void) {
    do {
        uint32_t __old = __LDREXW(&AtomicTest_counterU32);
        uint32_t __new = cnx_clamp_add_u32(__old, 1);
        if (__STREXW(__new, &AtomicTest_counterU32) == 0) break;
    } while (1);
}

void AtomicTest_decrementBrightness(void) {
    do {
        uint8_t __old = __LDREXB(&AtomicTest_brightness);
        uint8_t __new = cnx_clamp_sub_u8(__old, 10);
        if (__STREXB(__new, &AtomicTest_brightness) == 0) break;
    } while (1);
}

void AtomicTest_decrementPosition(void) {
    do {
        uint16_t __old = __LDREXH(&AtomicTest_position);
        uint16_t __new = cnx_clamp_sub_u16(__old, 50);
        if (__STREXH(__new, &AtomicTest_position) == 0) break;
    } while (1);
}

void AtomicTest_maskTicks(void) {
    do {
        uint32_t __old = __LDREXW(&AtomicTest_ticks);
        uint32_t __new = __old & 0xFFFF;
        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;
    } while (1);
}

void AtomicTest_setTickFlag(void) {
    do {
        uint32_t __old = __LDREXW(&AtomicTest_ticks);
        uint32_t __new = __old | 0x80000000;
        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;
    } while (1);
}

void AtomicTest_incrementAll(void) {
    do {
        uint8_t __old = __LDREXB(&AtomicTest_counterU8);
        uint8_t __new = cnx_clamp_add_u8(__old, 1);
        if (__STREXB(__new, &AtomicTest_counterU8) == 0) break;
    } while (1);
    do {
        uint16_t __old = __LDREXH(&AtomicTest_counterU16);
        uint16_t __new = cnx_clamp_add_u16(__old, 1);
        if (__STREXH(__new, &AtomicTest_counterU16) == 0) break;
    } while (1);
    do {
        uint32_t __old = __LDREXW(&AtomicTest_counterU32);
        uint32_t __new = cnx_clamp_add_u32(__old, 1);
        if (__STREXW(__new, &AtomicTest_counterU32) == 0) break;
    } while (1);
    do {
        uint32_t __old = __LDREXW(&AtomicTest_ticks);
        uint32_t __new = cnx_clamp_add_u32(__old, 1);
        if (__STREXW(__new, &AtomicTest_ticks) == 0) break;
    } while (1);
}

void main(void) {
    AtomicTest_getCounterU8();
    AtomicTest_getCounterU16();
    AtomicTest_getCounterU32();
    AtomicTest_getBrightness();
    AtomicTest_getPosition();
    AtomicTest_getTicks();
    AtomicTest_incrementU8();
    AtomicTest_incrementU16();
    AtomicTest_incrementU32();
    AtomicTest_decrementBrightness();
    AtomicTest_decrementPosition();
    AtomicTest_maskTicks();
    AtomicTest_setTickFlag();
    AtomicTest_incrementAll();
}
