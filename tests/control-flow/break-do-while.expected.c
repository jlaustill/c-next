/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {
    if (a > UINT32_MAX - b) return UINT32_MAX;
    return a + b;
}

/* test-execution */
// Tests: break statement in do-while loop
// Validates: early loop termination with break in do-while loops
uint32_t main(void) {
    uint32_t count = 0;
    uint32_t i = 0;
    do {
        count = cnx_clamp_add_u32(count, 1);
        if (i == 5) {
            break;
        }
        i = cnx_clamp_add_u32(i, 1);
    } while (i < 100);
    if (count != 6) return 1;
    if (i != 5) return 2;
    uint32_t firstOnly = 0;
    do {
        firstOnly = cnx_clamp_add_u32(firstOnly, 1);
        break;
    } while (true);
    if (firstOnly != 1) return 3;
    uint32_t runOnce = 0;
    do {
        runOnce = cnx_clamp_add_u32(runOnce, 1);
        if (runOnce == 1) {
            break;
        }
    } while (false);
    if (runOnce != 1) return 4;
    uint32_t sum = 0;
    uint32_t j = 0;
    do {
        sum = cnx_clamp_add_u32(sum, j);
        j = cnx_clamp_add_u32(j, 1);
        if (j == 10) {
            break;
        }
    } while (j < 100);
    if (sum != 45) return 5;
    if (j != 10) return 6;
    uint32_t val = 0;
    uint32_t k = 0;
    do {
        k = cnx_clamp_add_u32(k, 1);
        if (k == 3) {
            val = 30;
            break;
        }
        if (k == 7) {
            val = 70;
            break;
        }
    } while (k < 20);
    if (val != 30) return 7;
    if (k != 3) return 8;
    return 0;
}
