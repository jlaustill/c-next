/**
 * Generated by C-Next Transpiler from: clamp-compound-mul.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <limits.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int16_t cnx_clamp_mul_i16(int16_t a, int32_t b) {
    int32_t result = (int32_t)a * b;
    if (result > INT16_MAX) return INT16_MAX;
    if (result < INT16_MIN) return INT16_MIN;
    return (int16_t)result;
}

static inline int32_t cnx_clamp_mul_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a * b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

static inline int64_t cnx_clamp_mul_i64(int64_t a, int64_t b) {
    if (a == 0 || b == 0) return 0;
    if (a > 0 && b > 0 && a > INT64_MAX / b) return INT64_MAX;
    if (a < 0 && b < 0 && a < INT64_MAX / b) return INT64_MAX;
    if (a > 0 && b < 0 && b < INT64_MIN / a) return INT64_MIN;
    if (a < 0 && b > 0 && a < INT64_MIN / b) return INT64_MIN;
    return a * b;
}

static inline int8_t cnx_clamp_mul_i8(int8_t a, int32_t b) {
    int32_t result = (int32_t)a * b;
    if (result > INT8_MAX) return INT8_MAX;
    if (result < INT8_MIN) return INT8_MIN;
    return (int8_t)result;
}

static inline uint16_t cnx_clamp_mul_u16(uint16_t a, uint32_t b) {
    if (b != 0 && a > UINT16_MAX / b) return UINT16_MAX;
    uint16_t result;
    if (__builtin_mul_overflow(a, (uint16_t)b, &result)) return UINT16_MAX;
    return result;
}

static inline uint32_t cnx_clamp_mul_u32(uint32_t a, uint64_t b) {
    if (b != 0 && a > UINT32_MAX / b) return UINT32_MAX;
    uint32_t result;
    if (__builtin_mul_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint64_t cnx_clamp_mul_u64(uint64_t a, uint64_t b) {
    if (b != 0 && a > UINT64_MAX / b) return UINT64_MAX;
    uint64_t result;
    if (__builtin_mul_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

static inline uint8_t cnx_clamp_mul_u8(uint8_t a, uint32_t b) {
    if (b != 0 && a > UINT8_MAX / b) return UINT8_MAX;
    uint8_t result;
    if (__builtin_mul_overflow(a, (uint8_t)b, &result)) return UINT8_MAX;
    return result;
}

// test-execution
// test-coverage: 21.1-compound-mul
// Tests: clamp modifier with compound multiplication (*<-)
// Validates multiplication overflow clamps to type max
// ADR-044: Per-variable overflow semantics
int main(void) {
    uint8_t val8 = 20U;
    val8 = cnx_clamp_mul_u8(val8, 20U);
    if (val8 != 255) return 1;
    val8 = 200U;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 255) return 2;
    val8 = 10U;
    val8 = cnx_clamp_mul_u8(val8, 100U);
    if (val8 != 255) return 3;
    val8 = 10U;
    val8 = cnx_clamp_mul_u8(val8, 10U);
    if (val8 != 100) return 4;
    val8 = 200U;
    val8 = cnx_clamp_mul_u8(val8, 1U);
    if (val8 != 200) return 5;
    val8 = 200U;
    val8 = cnx_clamp_mul_u8(val8, 0U);
    if (val8 != 0) return 6;
    val8 = 17U;
    val8 = cnx_clamp_mul_u8(val8, 15U);
    if (val8 != 255) return 7;
    val8 = 16U;
    val8 = cnx_clamp_mul_u8(val8, 16U);
    if (val8 != 255) return 8;
    uint16_t val16 = 300U;
    val16 = cnx_clamp_mul_u16(val16, 300U);
    if (val16 != 65535) return 9;
    val16 = 100U;
    val16 = cnx_clamp_mul_u16(val16, 100U);
    if (val16 != 10000) return 10;
    val16 = 1000U;
    val16 = cnx_clamp_mul_u16(val16, 1000U);
    if (val16 != 65535) return 11;
    val16 = 40000U;
    val16 = cnx_clamp_mul_u16(val16, 2U);
    if (val16 != 65535) return 12;
    uint32_t val32 = 100000U;
    val32 = cnx_clamp_mul_u32(val32, 100000U);
    if (val32 != 4294967295) return 13;
    val32 = 1000U;
    val32 = cnx_clamp_mul_u32(val32, 1000U);
    if (val32 != 1000000) return 14;
    val32 = 3000000000U;
    val32 = cnx_clamp_mul_u32(val32, 2U);
    if (val32 != 4294967295) return 15;
    uint64_t val64 = 1000000000ULL;
    val64 = cnx_clamp_mul_u64(val64, 1000ULL);
    if (val64 != 1000000000000) return 16;
    val64 = 9223372036854775807ULL;
    val64 = cnx_clamp_mul_u64(val64, 1ULL);
    if (val64 != 9223372036854775807) return 17;
    int8_t vali8 = 20;
    vali8 = cnx_clamp_mul_i8(vali8, 10);
    if (vali8 != 127) return 18;
    vali8 = 20;
    vali8 = cnx_clamp_mul_i8(vali8, -10);
    if (vali8 != -128) return 19;
    vali8 = -20;
    vali8 = cnx_clamp_mul_i8(vali8, -10);
    if (vali8 != 127) return 20;
    vali8 = 10;
    vali8 = cnx_clamp_mul_i8(vali8, 10);
    if (vali8 != 100) return 21;
    vali8 = -10;
    vali8 = cnx_clamp_mul_i8(vali8, 5);
    if (vali8 != -50) return 22;
    int16_t vali16 = 200;
    vali16 = cnx_clamp_mul_i16(vali16, 200);
    if (vali16 != 32767) return 23;
    vali16 = 200;
    vali16 = cnx_clamp_mul_i16(vali16, -200);
    if (vali16 != -32768) return 24;
    vali16 = 100;
    vali16 = cnx_clamp_mul_i16(vali16, 100);
    if (vali16 != 10000) return 25;
    int32_t vali32 = 50000;
    vali32 = cnx_clamp_mul_i32(vali32, 50000);
    if (vali32 != 2147483647) return 26;
    vali32 = 50000;
    vali32 = cnx_clamp_mul_i32(vali32, -50000);
    if (vali32 != (int32_t)INT32_MIN) return 27;
    vali32 = 1000;
    vali32 = cnx_clamp_mul_i32(vali32, 1000);
    if (vali32 != 1000000) return 28;
    int64_t vali64 = 1000000;
    vali64 = cnx_clamp_mul_i64(vali64, 1000000);
    if (vali64 != 1000000000000) return 29;
    vali64 = 100;
    vali64 = cnx_clamp_mul_i64(vali64, -1);
    if (vali64 != -100) return 30;
    val8 = 2U;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 4) return 31;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 8) return 32;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 16) return 33;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 32) return 34;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 64) return 35;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 128) return 36;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 255) return 37;
    val8 = cnx_clamp_mul_u8(val8, 2U);
    if (val8 != 255) return 38;
    return 0;
}
