/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-coverage: 5.5-i32-left-shift, 5.6-i32-right-shift-arithmetic */
/* test-execution */
// Test i32 shift operations: arithmetic right shift preserves sign
// Coverage: Section 5.5-5.6 for i32 type (ADR-044)
uint32_t main(void) {
    int32_t a = 1;
    int32_t left1 = a << 1;
    int32_t left16 = a << 16;
    int32_t left30 = a << 30;
    int32_t b = 1073741824;
    int32_t right1 = b >> 1;
    int32_t right16 = b >> 16;
    int32_t right30 = b >> 30;
    int32_t c = -1073741824;
    int32_t neg_right1 = c >> 1;
    int32_t neg_right16 = c >> 16;
    int32_t neg_right30 = c >> 30;
    int32_t minus_one = -1;
    int32_t shift_minus_one = minus_one >> 16;
    int32_t d = 256;
    int32_t shift_amount = 4;
    int32_t left_var = d << shift_amount;
    int32_t right_var = d >> shift_amount;
    int32_t e = -65536;
    int32_t neg_shift = e >> 8;
    if (left1 == 2 && left16 == 65536 && left30 == 1073741824) {
        if (right1 == 536870912 && right16 == 16384 && right30 == 1) {
            if (neg_right1 == -536870912 && neg_right16 == -16384 && neg_right30 == -1) {
                if (shift_minus_one == -1 && left_var == 4096 && right_var == 16) {
                    if (neg_shift == -256) {
                        return 0;
                    }
                }
            }
        }
    }
    return 1;
}
