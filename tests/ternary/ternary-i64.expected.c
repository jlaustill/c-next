/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-execution */
// ADR-022: Ternary operator test for i64
// Tests: ternary with i64 in conditions and branches, including negative values
int64_t getMax(int64_t* a, int64_t* b) {
    return ((*a) > (*b)) ? (*a) : (*b);
}

int64_t getMin(int64_t* a, int64_t* b) {
    return ((*a) < (*b)) ? (*a) : (*b);
}

int64_t getAbs(int64_t* x) {
    return ((*x) < 0) ? -(*x) : (*x);
}

uint32_t main(void) {
    int64_t a = 1000;
    int64_t b = 2000;
    int64_t c = -3000;
    int64_t d = -500;
    if (getMax(&a, &b) != 2000) {
        return 1;
    }
    if (getMax(&c, &d) != -500) {
        return 2;
    }
    if (getMin(&a, &b) != 1000) {
        return 3;
    }
    if (getMin(&c, &d) != -3000) {
        return 4;
    }
    if (getAbs(&c) != 3000) {
        return 5;
    }
    if (getAbs(&a) != 1000) {
        return 6;
    }
    int64_t result = (a > c) ? a : c;
    if (result != 1000) {
        return 7;
    }
    int64_t large_a = 1000000000000;
    int64_t large_b = 2000000000000;
    int64_t large_result = (large_a < large_b) ? large_a : large_b;
    if (large_result != 1000000000000) {
        return 8;
    }
    int64_t large_neg_a = -1000000000000;
    int64_t large_neg_b = -2000000000000;
    int64_t large_neg_result = (large_neg_a > large_neg_b) ? large_neg_a : large_neg_b;
    if (large_neg_result != -1000000000000) {
        return 9;
    }
    int64_t equal_test = (c == -3000) ? 100000 : -100000;
    if (equal_test != 100000) {
        return 10;
    }
    int64_t neg = -1000000;
    int64_t pos = 1000000;
    int64_t zero_cross = (neg < 0) ? pos : neg;
    if (zero_cross != 1000000) {
        return 11;
    }
    int64_t very_large_pos = 9000000000000000000;
    int64_t very_large_neg = -9000000000000000000;
    int64_t very_large_result = (very_large_pos > very_large_neg) ? very_large_pos : very_large_neg;
    if (very_large_result != 9000000000000000000) {
        return 12;
    }
    return 0;
}
