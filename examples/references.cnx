// references.cnx - Demonstrates simplified reference model (ADR-006)
// All parameters pass by reference, assignment updates values

#include <stdint.h>
#include <stdbool.h>

scope Console {
    void printInt(i32 value) {
        // Print implementation...
    }

    void printHex(u32 value) {
        // Print hex implementation...
    }
}

// Function that modifies its parameter
// No * or & needed - parameters always receive the address
void increment(i32 x) {
    x <- x + 1;  // Updates the original variable
}

// Swap function - clean and simple
void swap(i32 a, i32 b) {
    i32 temp <- a;
    a <- b;
    b <- temp;
}

// Calculate with multiple "output" parameters
// Input params are const, output params are not
void divmod(const i32 dividend, const i32 divisor, i32 quotient, i32 remainder) {
    quotient <- dividend / divisor;
    remainder <- dividend % divisor;
}

// Process an array (arrays naturally pass by reference)
void zeroArray(u8 buffer[], const u32 size) {
    u32 i <- 0;
    while (i < size) {
        buffer[i] <- 0;
        i <- i + 1;
    }
}

// Struct example (ADR-014)
struct Point {
    i32 x;
    i32 y;
}

// Move a point (struct passes by reference)
void movePoint(Point p, const i32 dx, const i32 dy) {
    p.x <- p.x + dx;
    p.y <- p.y + dy;
}

// Configuration constants (ADR-006: no magic numbers in function calls)
const i32 INITIAL_COUNTER <- 5;
const i32 INITIAL_X <- 10;
const i32 INITIAL_Y <- 20;
const i32 DIVIDEND <- 17;
const i32 DIVISOR <- 5;
const u32 BUFFER_SIZE <- 16;
const i32 MOVE_DX <- 5;
const i32 MOVE_DY <- 10;

// Main demonstration
void main() {
    // Simple increment
    i32 counter <- INITIAL_COUNTER;
    increment(counter);
    Console.printInt(counter);  // Prints 6

    // Swap
    i32 x <- INITIAL_X;
    i32 y <- INITIAL_Y;
    swap(x, y);
    Console.printInt(x);  // Prints 20
    Console.printInt(y);  // Prints 10

    // Multiple outputs
    i32 q;
    i32 r;
    divmod(DIVIDEND, DIVISOR, q, r);
    Console.printInt(q);  // Prints 3
    Console.printInt(r);  // Prints 2

    // Array
    u8 data[16];
    zeroArray(data, BUFFER_SIZE);

    // Point with struct initializer (ADR-014 - inferred type)
    Point origin <- { x: 0, y: 0 };
    Console.printInt(origin.x);  // Prints 0

    // Point with zero initialization (ADR-015)
    Point cursor;  // Zero-initialized: cursor.x = 0, cursor.y = 0
    movePoint(cursor, MOVE_DX, MOVE_DY);
    Console.printInt(cursor.x);  // Prints 5
    Console.printInt(cursor.y);  // Prints 10

    // Address-of operator (read-only)
    u32 addr <- &counter;
    Console.printHex(addr);  // Prints memory address
}
