/* test-execution */ // Tests: multi-dimensional u64 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: large data buffers, matrices for embedded systems
u64 matrix2d[4][8];

u64 cube3d[2][3][4];

u32 main() {
    // 2D array: Write operations
    matrix2d[0][0] <- 1000000000000;
    matrix2d[0][7] <- 2000000000000;
    matrix2d[1][3] <- 3000000000000;
    matrix2d[3][7] <- 4000000000000;

    // 2D array: Read and verify
    if (matrix2d[0][0] != 1000000000000) return 1;
    if (matrix2d[0][7] != 2000000000000) return 2;
    if (matrix2d[1][3] != 3000000000000) return 3;
    if (matrix2d[3][7] != 4000000000000) return 4;

    // 3D array: Write operations
    cube3d[0][0][0] <- 100;
    cube3d[0][0][3] <- 200;
    cube3d[0][2][3] <- 300;
    cube3d[1][0][0] <- 999999999999;
    cube3d[1][2][3] <- 888888888888;

    // 3D array: Read and verify
    if (cube3d[0][0][0] != 100) return 5;
    if (cube3d[0][0][3] != 200) return 6;
    if (cube3d[0][2][3] != 300) return 7;
    if (cube3d[1][0][0] != 999999999999) return 8;
    if (cube3d[1][2][3] != 888888888888) return 9;

    // Test .length property at each dimension
    // 2D array dimensions
    if (matrix2d.length != 4) return 10; // First dimension
    if (matrix2d[0].length != 8) return 11; // Second dimension
    if (matrix2d[0][0].length != 64) return 12; // Element bit width

    // 3D array dimensions
    if (cube3d.length != 2) return 13; // First dimension
    if (cube3d[0].length != 3) return 14; // Second dimension
    if (cube3d[0][0].length != 4) return 15; // Third dimension
    if (cube3d[0][0][0].length != 64) return 16; // Element bit width

    // Nested loop iteration - populate 2D array
    for (u32 i <- 0; i < 4; i +<- 1) {
        for (u32 j <- 0; j < 8; j +<- 1) {
            matrix2d[i][j] <- i * 100 + j;
        }
    }

    // Verify populated values
    if (matrix2d[0][0] != 0) return 17;
    if (matrix2d[0][7] != 7) return 18;
    if (matrix2d[1][3] != 103) return 19;
    if (matrix2d[3][7] != 307) return 20;

    // Nested loop iteration - populate and sum 3D array
    u64 sum <- 0;
    for (u32 i <- 0; i < 2; i +<- 1) {
        for (u32 j <- 0; j < 3; j +<- 1) {
            for (u32 k <- 0; k < 4; k +<- 1) {
                cube3d[i][j][k] <- i * 100 + j * 10 + k;
                sum +<- cube3d[i][j][k];
            }
        }
    }

    // Verify sum: (0..23) + (100..123) = 276 + 1476 = 1752
    // Actually: i*100 + j*10 + k for all combinations
    // i=0: j=0,k=0..3: 0,1,2,3 = 6
    //      j=1,k=0..3: 10,11,12,13 = 46
    //      j=2,k=0..3: 20,21,22,23 = 86
    // i=1: j=0,k=0..3: 100,101,102,103 = 406
    //      j=1,k=0..3: 110,111,112,113 = 446
    //      j=2,k=0..3: 120,121,122,123 = 486
    // Total: 6+46+86+406+446+486 = 1476
    if (sum != 1476) return 21;

    // Test modification after initialization
    matrix2d[2][4] <- 9000000000000000000;
    if (matrix2d[2][4] != 9000000000000000000) return 22;

    // Test boundary access
    matrix2d[matrix2d.length - 1][matrix2d[0].length - 1] <- 555;
    if (matrix2d[3][7] != 555) return 23;

    // Test 2D array with large timestamp values
    u64 timestamps[3][2];
    timestamps[0][0] <- 1609459200000; // Jan 1, 2021
    timestamps[0][1] <- 1612137600000; // Feb 1, 2021
    timestamps[1][0] <- 1614556800000; // Mar 1, 2021
    timestamps[1][1] <- 1617235200000; // Apr 1, 2021
    timestamps[2][0] <- 1619827200000; // May 1, 2021
    timestamps[2][1] <- 1622505600000; // Jun 1, 2021

    if (timestamps[0][0] != 1609459200000) return 24;
    if (timestamps[2][1] != 1622505600000) return 25;

    // Compute time differences
    u64 diff <- timestamps[0][1] - timestamps[0][0];
    if (diff != 2678400000) return 26; // ~31 days in milliseconds

    return 0;
}
