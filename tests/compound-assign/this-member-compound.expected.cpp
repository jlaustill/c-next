/**
 * Generated by C-Next Transpiler from: this-member-compound.test.cnx
 * A safer C for embedded systems
 */

#include "this-member-compound.test.hpp"

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline int32_t cnx_clamp_mul_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a * b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

static inline int32_t cnx_clamp_sub_i32(int32_t a, int64_t b) {
    int64_t result = (int64_t)a - b;
    if (result > INT32_MAX) return INT32_MAX;
    if (result < INT32_MIN) return INT32_MIN;
    return (int32_t)result;
}

// test-execution
// test-coverage: 2.3-this-member, 2.4-this-member, 2.5-this-member, 2.6-this-member, 2.7-this-member, 2.8-this-member, 2.9-this-member, 2.10-this-member, 2.11-this-member
// Tests: All compound assignment operators with this.member syntax
// Validates: Compound operators -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><- on scope-local members
// Note: +<- is already tested in scope/scope-compound-assign.test.cnx
/* Scope: Calculator */
static int32_t Calculator_value = 0;
static uint32_t Calculator_bits = 0U;

static int32_t Calculator_testSubtraction(void) {
    Calculator_value = 100;
    Calculator_value = cnx_clamp_sub_i32(Calculator_value, 30);
    if (Calculator_value != 70) return 1;
    Calculator_value = 50;
    Calculator_value = cnx_clamp_sub_i32(Calculator_value, 50);
    if (Calculator_value != 0) return 2;
    return 0;
}

static int32_t Calculator_testMultiplication(void) {
    Calculator_value = 7;
    Calculator_value = cnx_clamp_mul_i32(Calculator_value, 6);
    if (Calculator_value != 42) return 10;
    Calculator_value = 100;
    Calculator_value = cnx_clamp_mul_i32(Calculator_value, 1);
    if (Calculator_value != 100) return 11;
    Calculator_value = 25;
    Calculator_value = cnx_clamp_mul_i32(Calculator_value, 0);
    if (Calculator_value != 0) return 12;
    return 0;
}

static int32_t Calculator_testDivision(void) {
    Calculator_value = 100;
    Calculator_value /= 5;
    if (Calculator_value != 20) return 20;
    Calculator_value = 81;
    Calculator_value /= 9;
    if (Calculator_value != 9) return 21;
    Calculator_value = 50;
    Calculator_value /= 1;
    if (Calculator_value != 50) return 22;
    return 0;
}

static int32_t Calculator_testModulo(void) {
    Calculator_value = 17;
    Calculator_value %= 5;
    if (Calculator_value != 2) return 30;
    Calculator_value = 100;
    Calculator_value %= 7;
    if (Calculator_value != 2) return 31;
    Calculator_value = 25;
    Calculator_value %= 25;
    if (Calculator_value != 0) return 32;
    return 0;
}

static int32_t Calculator_testBitwiseAnd(void) {
    Calculator_bits = 0xFFU;
    Calculator_bits &= 0x0FU;
    if (Calculator_bits != 0x0F) return 40;
    Calculator_bits = 0xAAU;
    Calculator_bits &= 0x55U;
    if (Calculator_bits != 0) return 41;
    Calculator_bits = 0x12345678U;
    Calculator_bits &= 0xFFFFFFFFU;
    if (Calculator_bits != 0x12345678) return 42;
    return 0;
}

static int32_t Calculator_testBitwiseOr(void) {
    Calculator_bits = 0xF0U;
    Calculator_bits |= 0x0FU;
    if (Calculator_bits != 0xFF) return 50;
    Calculator_bits = 0x00U;
    Calculator_bits |= 0xABU;
    if (Calculator_bits != 0xAB) return 51;
    Calculator_bits = 0x12340000U;
    Calculator_bits |= 0x00005678U;
    if (Calculator_bits != 0x12345678) return 52;
    return 0;
}

static int32_t Calculator_testBitwiseXor(void) {
    Calculator_bits = 0xFFU;
    Calculator_bits ^= 0xFFU;
    if (Calculator_bits != 0) return 60;
    Calculator_bits = 0xAAU;
    Calculator_bits ^= 0x55U;
    if (Calculator_bits != 0xFF) return 61;
    Calculator_bits = 0x12345678U;
    Calculator_bits ^= 0x00000000U;
    if (Calculator_bits != 0x12345678) return 62;
    return 0;
}

static int32_t Calculator_testLeftShift(void) {
    Calculator_bits = 1U;
    Calculator_bits <<= 4U;
    if (Calculator_bits != 16) return 70;
    Calculator_bits = 0xFFU;
    Calculator_bits <<= 8U;
    if (Calculator_bits != 0xFF00) return 71;
    Calculator_bits = 1U;
    Calculator_bits <<= 0U;
    if (Calculator_bits != 1) return 72;
    return 0;
}

static int32_t Calculator_testRightShift(void) {
    Calculator_bits = 256U;
    Calculator_bits >>= 4U;
    if (Calculator_bits != 16) return 80;
    Calculator_bits = 0xFF00U;
    Calculator_bits >>= 8U;
    if (Calculator_bits != 0xFF) return 81;
    Calculator_bits = 128U;
    Calculator_bits >>= 0U;
    if (Calculator_bits != 128) return 82;
    return 0;
}

int32_t Calculator_runAllTests(void) {
    int32_t result = 0;
    result = Calculator_testSubtraction();
    if (result != 0) return result;
    result = Calculator_testMultiplication();
    if (result != 0) return result;
    result = Calculator_testDivision();
    if (result != 0) return result;
    result = Calculator_testModulo();
    if (result != 0) return result;
    result = Calculator_testBitwiseAnd();
    if (result != 0) return result;
    result = Calculator_testBitwiseOr();
    if (result != 0) return result;
    result = Calculator_testBitwiseXor();
    if (result != 0) return result;
    result = Calculator_testLeftShift();
    if (result != 0) return result;
    result = Calculator_testRightShift();
    if (result != 0) return result;
    return 0;
}

int main(void) {
    return Calculator_runAllTests();
}
