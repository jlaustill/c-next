/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// crc32.cnx - Memory-safe CRC32 using c-next's bounded strings
// Ported from ConfigStorage.cpp with safer serialization
#include "AppConfig.h"

#include <stdint.h>
#include <string.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

// Calculate CRC32 checksum over AppConfig struct (excluding checksum field)
// Uses explicit field serialization instead of raw memory access
uint32_t calculateChecksum(const AppConfig* config) {
    char buffer[513] = "";
    uint32_t offset = 0;
    uint8_t length = 0;
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).magic, length); }
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).version, length); }
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).j1939SourceAddress, length); }
    offset = cnx_clamp_add_u32(offset, length);
    for (uint32_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).tempInputs[i].assignedSpn, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).tempInputs[i].coeffA, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).tempInputs[i].coeffB, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).tempInputs[i].coeffC, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).tempInputs[i].resistorValue, length); }
        offset = cnx_clamp_add_u32(offset, length);
    }
    for (uint32_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).pressureInputs[i].assignedSpn, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).pressureInputs[i].maxPressure, length); }
        offset = cnx_clamp_add_u32(offset, length);
        length = 0 / 8;
        if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).pressureInputs[i].pressureType, length); }
        offset = cnx_clamp_add_u32(offset, length);
    }
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).egtEnabled, length); }
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).thermocoupleType, length); }
    offset = cnx_clamp_add_u32(offset, length);
    length = 0 / 8;
    if (offset + length <= sizeof(buffer)) { memcpy(&buffer[offset], &(*config).bme280Enabled, length); }
    offset = cnx_clamp_add_u32(offset, length);
    uint32_t crc = 0xFFFFFFFF;
    for (uint32_t i = 0; i < offset; i += 1) {
        crc = crc ^ buffer[i];
        for (int32_t j = 0; j < 8; j += 1) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc = crc >> 1;
            }
        }
    }
    return ~crc;
}
