// test-execution
// Regression test for issue #69: Array indexing transpiles as bitshift operation
//
// Bug: Array indexing on struct array members like config.tempInputs[index].assignedSpn
// was incorrectly transpiling as bitshift: ((config.tempInputs >> index) & 1).assignedSpn
//
// Expected: config->tempInputs[index].assignedSpn
//
// This test ensures the bug does not regress in future changes.
struct InputData {
    u16 assignedSpn;
    f32 coeffA;
}

struct Configuration {
    InputData tempInputs[8];
}

// Function that exposes the bug - passing struct by value with array member access
u16 getSpn(const Configuration conf, u32 idx) {
    return conf.tempInputs[idx].assignedSpn;
}

f32 getCoeff(const Configuration data, u32 pos) {
    return data.tempInputs[pos].coeffA;
}

// Test writing to struct parameter array members (non-const)
void setSpn(Configuration conf, u32 idx, u16 value) {
    conf.tempInputs[idx].assignedSpn <- value;
}

void setCoeff(Configuration data, u32 pos, f32 value) {
    data.tempInputs[pos].coeffA <- value;
}

// Test writing in a for-loop (the original OSSM bug pattern)
void initializeAll(Configuration conf, u16 spnValue, f32 coeffValue) {
    for (u32 i <- 0; i < 8; i +<- 1) {
        conf.tempInputs[i].assignedSpn <- spnValue;
        conf.tempInputs[i].coeffA <- coeffValue;
    }
}

u32 main() {
    Configuration cfg;

    // Initialize test data
    cfg.tempInputs[0].assignedSpn <- 100;
    cfg.tempInputs[0].coeffA <- 1.5;

    cfg.tempInputs[1].assignedSpn <- 200;
    cfg.tempInputs[1].coeffA <- 2.5;

    cfg.tempInputs[2].assignedSpn <- 300;
    cfg.tempInputs[2].coeffA <- 3.5;

    cfg.tempInputs[5].assignedSpn <- 999;
    cfg.tempInputs[5].coeffA <- 9.5;

    // Index variables to avoid cppcheck warnings with literal-to-pointer
    u32 idx0 <- 0;
    u32 idx1 <- 1;
    u32 idx2 <- 2;
    u32 idx5 <- 5;

   
// Test 1: Function parameter access (original issue #69 pattern)
    u16 spn0 <- getSpn(cfg, idx0);
    if (spn0 != 100) return 1;
    u16 spn1 <- getSpn(cfg, idx1);
    if (spn1 != 200) return 2;
    u16 spn2 <- getSpn(cfg, idx2);
    if (spn2 != 300) return 3;
    u16 spn5 <- getSpn(cfg, idx5);
    if (spn5 != 999) return 4;

   
// Test 2: Float member access
    f32 coeff0 <- getCoeff(cfg, idx0);
    if (coeff0 != 1.5) return 5;
    f32 coeff1 <- getCoeff(cfg, idx1);
    if (coeff1 != 2.5) return 6;
    f32 coeff2 <- getCoeff(cfg, idx2);
    if (coeff2 != 3.5) return 7;

   
// Test 3: Direct access patterns
    if (cfg.tempInputs[0].assignedSpn != 100) return 8;
    if (cfg.tempInputs[1].assignedSpn != 200) return 9;
    if (cfg.tempInputs[2].assignedSpn != 300) return 10;

   
// Test 4: Array access in expressions
    u16 sum <- cfg.tempInputs[0].assignedSpn + cfg.tempInputs[1].assignedSpn;
    if (sum != 300) return 11;

   
// Test 5: Array access as function argument
    u16 val <- getSpn(cfg, idx2);
    if (val != 300) return 12;

   
// Test 6: Nested expressions
    if ((cfg.tempInputs[0].assignedSpn + cfg.tempInputs[2].assignedSpn) != 400) return 13;


// Test 7: Writing to struct parameter array members (setSpn/setCoeff)
    setSpn(cfg, idx0, 500);
    if (cfg.tempInputs[0].assignedSpn != 500) return 14;

    setCoeff(cfg, idx1, 7.5);
    if (cfg.tempInputs[1].coeffA != 7.5) return 15;


// Test 8: Writing in a for-loop (the OSSM bug pattern)
    // Note: Use 4.5 instead of 3.14 because 4.5 can be exactly represented in both float and double
    initializeAll(cfg, 42, 4.5);
    // Verify all 8 elements were set correctly
    for (u32 j <- 0; j < 8; j +<- 1) {
        if (cfg.tempInputs[j].assignedSpn != 42) return 16;
        if (cfg.tempInputs[j].coeffA != 4.5) return 17;
    }

    return 0;
}
