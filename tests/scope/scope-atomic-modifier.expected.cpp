/**
 * Generated by C-Next Transpiler from: scope-atomic-modifier.test.cnx
 * A safer C for embedded systems
 */

#include "scope-atomic-modifier.test.hpp"

// Test: ADR-016 + ADR-049 Atomic variables inside scopes
// Verifies that atomic modifier works correctly with integer types inside scope methods
// Tests: atomic variables accessed via this. accessor with compound assignment operators

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint16_t cnx_clamp_add_u16(uint16_t a, uint32_t b) {
    if (b > (uint32_t)(UINT16_MAX - a)) return UINT16_MAX;
    uint16_t result;
    if (__builtin_add_overflow(a, (uint16_t)b, &result)) return UINT16_MAX;
    return result;
}

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint32_t b) {
    if (b > (uint32_t)(UINT8_MAX - a)) return UINT8_MAX;
    uint8_t result;
    if (__builtin_add_overflow(a, (uint8_t)b, &result)) return UINT8_MAX;
    return result;
}

static inline uint16_t cnx_clamp_sub_u16(uint16_t a, uint32_t b) {
    if (b > (uint32_t)a) return 0;
    uint16_t result;
    if (__builtin_sub_overflow(a, (uint16_t)b, &result)) return 0;
    return result;
}

static inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint32_t b) {
    if (b > (uint32_t)a) return 0;
    uint8_t result;
    if (__builtin_sub_overflow(a, (uint8_t)b, &result)) return 0;
    return result;
}

/* Scope: AtomicTest */
static uint8_t AtomicTest_counterU8 = 0U;
static uint16_t AtomicTest_counterU16 = 0U;
static uint32_t AtomicTest_counterU32 = 0U;
static uint8_t AtomicTest_brightness = 100U;
static uint16_t AtomicTest_position = 500U;
static uint32_t AtomicTest_ticks = 0U;

uint8_t AtomicTest_getCounterU8(void) {
    return AtomicTest_counterU8;
}

uint16_t AtomicTest_getCounterU16(void) {
    return AtomicTest_counterU16;
}

uint32_t AtomicTest_getCounterU32(void) {
    return AtomicTest_counterU32;
}

uint8_t AtomicTest_getBrightness(void) {
    return AtomicTest_brightness;
}

uint16_t AtomicTest_getPosition(void) {
    return AtomicTest_position;
}

uint32_t AtomicTest_getTicks(void) {
    return AtomicTest_ticks;
}

void AtomicTest_incrementU8(void) {
    AtomicTest_counterU8 = cnx_clamp_add_u8(AtomicTest_counterU8, 1U);
}

void AtomicTest_incrementU16(void) {
    AtomicTest_counterU16 = cnx_clamp_add_u16(AtomicTest_counterU16, 1U);
}

void AtomicTest_incrementU32(void) {
    AtomicTest_counterU32 = cnx_clamp_add_u32(AtomicTest_counterU32, 1U);
}

void AtomicTest_decrementBrightness(void) {
    AtomicTest_brightness = cnx_clamp_sub_u8(AtomicTest_brightness, 10U);
}

void AtomicTest_decrementPosition(void) {
    AtomicTest_position = cnx_clamp_sub_u16(AtomicTest_position, 50U);
}

void AtomicTest_maskTicks(void) {
    AtomicTest_ticks &= 0xFFFFU;
}

void AtomicTest_setTickFlag(void) {
    AtomicTest_ticks |= 0x80000000U;
}

void AtomicTest_incrementAll(void) {
    AtomicTest_counterU8 = cnx_clamp_add_u8(AtomicTest_counterU8, 1U);
    AtomicTest_counterU16 = cnx_clamp_add_u16(AtomicTest_counterU16, 1U);
    AtomicTest_counterU32 = cnx_clamp_add_u32(AtomicTest_counterU32, 1U);
    AtomicTest_ticks = cnx_clamp_add_u32(AtomicTest_ticks, 1U);
}

int main(void) {
    AtomicTest_getCounterU8();
    AtomicTest_getCounterU16();
    AtomicTest_getCounterU32();
    AtomicTest_getBrightness();
    AtomicTest_getPosition();
    AtomicTest_getTicks();
    AtomicTest_incrementU8();
    AtomicTest_incrementU16();
    AtomicTest_incrementU32();
    AtomicTest_decrementBrightness();
    AtomicTest_decrementPosition();
    AtomicTest_maskTicks();
    AtomicTest_setTickFlag();
    AtomicTest_incrementAll();
}
