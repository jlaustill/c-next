// test-coverage: 33.1-multiple-operators-same-precedence
// test-execution
// Tests: multiple operators with same precedence (left-to-right associativity)
// Coverage: Section 33.1 - Nested/Complex Expressions
// Note: Mixed operator tests (a + b - c) deferred due to bug #152
// Helper functions to get boolean values (prevents static analysis false positives)
bool getTrue(u32 x) {
    return x > 0;
}

bool getFalse(u32 x) {
    return x > 1000;
}

u32 main() {
    // === ADDITION CHAINS ===
   
// Test 1: Simple addition chain
    u32 a <- 10;
    u32 b <- 20;
    u32 c <- 30;
    u32 d <- 40;
    u32 result <- a + b + c + d;
    if (result != 100) return 1;

    // === SUBTRACTION CHAINS ===
   
// Test 2: Subtraction chain (verifies left-to-right)
    // 100 - 30 - 20 - 10 = 70 - 20 - 10 = 50 - 10 = 40
    result <- 100 - 30 - 20 - 10;
    if (result != 40) return 2;

   
// Test 3: Subtraction associativity is critical
    // (100 - 60) - 30 = 40 - 30 = 10 (left-to-right)
    // NOT 100 - (60 - 30) = 100 - 30 = 70 (wrong if right-to-left)
    result <- 100 - 60 - 30;
    if (result != 10) return 3;

    // === MULTIPLICATION CHAINS ===
   
// Test 4: Simple multiplication chain
    result <- 2 * 3 * 4 * 5;
    if (result != 120) return 4;

    // === DIVISION CHAINS ===
   
// Test 5: Division chain (verifies left-to-right)
    // 120 / 2 / 3 / 4 = 60 / 3 / 4 = 20 / 4 = 5
    result <- 120 / 2 / 3 / 4;
    if (result != 5) return 5;

   
// Test 6: Division associativity is critical
    // (100 / 10) / 2 = 10 / 2 = 5 (left-to-right)
    // NOT 100 / (10 / 2) = 100 / 5 = 20 (wrong if right-to-left)
    result <- 100 / 10 / 2;
    if (result != 5) return 6;

    // === MODULO CHAINS ===
   
// Test 7: Modulo chain
    // 100 % 30 % 7 = 10 % 7 = 3
    result <- 100 % 30 % 7;
    if (result != 3) return 7;

    // === BITWISE OPERATORS ===
   
// Test 8: Bitwise AND chain
    u32 x <- 0xFF;
    u32 y <- 0x0F;
    u32 z <- 0x07;
    result <- x & y & z;
    if (result != 0x07) return 8;

   
// Test 9: Bitwise OR chain
    result <- 0x01 | 0x02 | 0x04 | 0x08;
    if (result != 0x0F) return 9;

   
// Test 10: Bitwise XOR chain
    // 0xFF ^ 0x0F ^ 0x03 = 0xF0 ^ 0x03 = 0xF3
    result <- 0xFF ^ 0x0F ^ 0x03;
    if (result != 0xF3) return 10;

    // === SHIFT OPERATORS ===
   
// Test 11: Left shift chain
    // 1 << 2 << 3 = 4 << 3 = 32
    result <- 1 << 2 << 3;
    if (result != 32) return 11;

   
// Test 12: Right shift chain
    // 256 >> 2 >> 3 = 64 >> 3 = 8
    result <- 256 >> 2 >> 3;
    if (result != 8) return 12;

    // === COMPARISON OPERATORS ===
   
// Test 13: Chained comparisons (each produces bool, then combined)
    bool cmp1 <- 5 < 10;
    bool cmp2 <- 10 < 15;
    bool both <- cmp1 && cmp2;
    if (both != true) return 13;

   
// Test 14: Multiple equality checks
    bool eq1 <- 10 = 10;
    bool eq2 <- 20 = 20;
    bool eq3 <- 30 = 30;
    if (eq1 != true) return 14;
    if (eq2 != true) return 15;
    if (eq3 != true) return 16;

    // === LOGICAL OPERATORS ===
   
// Test 17: AND chain (use function calls to avoid static analysis warnings)
    bool t1 <- getTrue(1);
    bool t2 <- getTrue(2);
    bool t3 <- getTrue(3);
    bool t4 <- getTrue(4);
    bool andResult <- t1 && t2 && t3 && t4;
    if (andResult != true) return 17;

   
// Test 18: AND chain with false
    bool f1 <- getFalse(0);
    andResult <- t1 && t2 && f1 && t4;
    if (andResult != false) return 18;

   
// Test 19: OR chain
    bool f2 <- getFalse(0);
    bool f3 <- getFalse(0);
    bool f4 <- getFalse(0);
    bool orResult <- f1 || f2 || f3 || t1;
    if (orResult != true) return 19;

   
// Test 20: OR chain all false
    orResult <- f1 || f2 || f3 || f4;
    if (orResult != false) return 20;

    // === PARENTHESES OVERRIDE PRECEDENCE ===
   
// Test 21: Parentheses with multiplication
    // (10 + 20) * 3 = 30 * 3 = 90
    result <- (10 + 20) * 3;
    if (result != 90) return 21;

   
// Test 22: Nested parentheses (simplified to avoid bug #152)
    // ((100 - 50) * 2) = (50 * 2) = 100
    result <- ((100 - 50) * 2);
    if (result != 100) return 22;

    return 0;
}
