// test-execution
// Tests: Auto-const inference for struct parameters
// Coverage: Struct parameters get const when not modified

struct Point {
    i32 x;
    i32 y;
}

struct Config {
    u32 value;
    bool enabled;
}

// Read-only struct parameter - should get const
i32 getPointSum(Point p) {
    return p.x + p.y;
}

// Modified struct parameter - should NOT get const
void movePoint(Point p, i32 dx, i32 dy) {
    p.x +<- dx;
    p.y +<- dy;
}

// Read-only config - should get const
u32 getConfigValue(Config c) {
    return c.value;
}

// Mixed: read one field, modify another - should NOT get const
void toggleAndRead(Config c) {
    u32 temp <- c.value;  // Read
    c.enabled <- !c.enabled;  // Modify
}

// Pass through to read-only - should get const
i32 wrapGetSum(Point p) {
    return getPointSum(p);
}

// Pass through to modifier - should NOT get const
void wrapMovePoint(Point p) {
    movePoint(p, 1, 1);
}

u32 main() {
    // Test read-only struct access
    Point pt <- {x: 10, y: 20};
    i32 sum <- getPointSum(pt);
    if (sum != 30) return 1;
    if (pt.x != 10) return 2;  // Should be unchanged
    if (pt.y != 20) return 3;

    // Test modified struct
    movePoint(pt, 5, -3);
    if (pt.x != 15) return 4;
    if (pt.y != 17) return 5;

    // Test config read
    Config cfg <- {value: 42, enabled: true};
    u32 val <- getConfigValue(cfg);
    if (val != 42) return 6;

    // Test mixed modification
    toggleAndRead(cfg);
    if (cfg.enabled != false) return 7;

    // Test wrapped read-only
    Point pt2 <- {x: 100, y: 200};
    sum <- wrapGetSum(pt2);
    if (sum != 300) return 8;
    if (pt2.x != 100) return 9;

    // Test wrapped modifier
    wrapMovePoint(pt2);
    if (pt2.x != 101) return 10;
    if (pt2.y != 201) return 11;

    return 0;
}
