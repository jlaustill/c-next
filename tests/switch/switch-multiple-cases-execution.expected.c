/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

/* test-execution */
// ADR-025: Multiple cases execution test
// Tests: case A || B syntax with result validation
// Coverage: Section 7 (Control Flow) - multiple cases per block
uint32_t result = 0;

// Basic multiple case syntax
void testMultiCase(uint32_t* val) {
    switch ((*val)) {
        case 0:
        case 1:
        case 2: {
            result = 100;
            break;
        }
        case 10:
        case 20: {
            result = 200;
            break;
        }
        case 100: {
            result = 300;
            break;
        }
        default: {
            result = 999;
            break;
        }
    }
}

// Multiple cases with hex literals
void testMultiCaseHex(uint8_t* val) {
    switch ((*val)) {
        case 0x00:
        case 0x01: {
            result = 10;
            break;
        }
        case 0x0A:
        case 0x0B: {
            result = 20;
            break;
        }
        case 0xFF: {
            result = 30;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Multiple cases with binary literals
void testMultiCaseBinary(uint8_t* val) {
    switch ((*val)) {
        case 0x0:
        case 0x1: {
            result = 40;
            break;
        }
        case 0xA:
        case 0xB: {
            result = 50;
            break;
        }
        case 0xFF: {
            result = 60;
            break;
        }
        default: {
            result = 99;
            break;
        }
    }
}

// Multiple cases with signed values (positive case labels only)
void testMultiCaseSigned(int8_t* val) {
    switch ((*val)) {
        case 0:
        case 1:
        case 2: {
            result = 1;
            break;
        }
        case 50:
        case 51:
        case 52: {
            result = 2;
            break;
        }
        case 126:
        case 127: {
            result = 3;
            break;
        }
        default: {
            result = 9;
            break;
        }
    }
}

// Many cases combined (5 alternatives)
void testManyMultiCases(uint16_t* val) {
    switch ((*val)) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5: {
            result = 500;
            break;
        }
        case 100:
        case 200:
        case 300: {
            result = 600;
            break;
        }
        default: {
            result = 999;
            break;
        }
    }
}

uint32_t main(void) {
    uint32_t val0 = 0;
    uint32_t val1 = 1;
    uint32_t val2 = 2;
    uint32_t val10 = 10;
    uint32_t val20 = 20;
    uint32_t val100 = 100;
    uint32_t val50 = 50;
    testMultiCase(&val0);
    if (result != 100) return 1;
    testMultiCase(&val1);
    if (result != 100) return 2;
    testMultiCase(&val2);
    if (result != 100) return 3;
    testMultiCase(&val10);
    if (result != 200) return 4;
    testMultiCase(&val20);
    if (result != 200) return 5;
    testMultiCase(&val100);
    if (result != 300) return 6;
    testMultiCase(&val50);
    if (result != 999) return 7;
    uint8_t hex0 = 0x00;
    uint8_t hex1 = 0x01;
    uint8_t hexA = 0x0A;
    uint8_t hexFF = 0xFF;
    uint8_t hexOther = 0x50;
    testMultiCaseHex(&hex0);
    if (result != 10) return 8;
    testMultiCaseHex(&hex1);
    if (result != 10) return 9;
    testMultiCaseHex(&hexA);
    if (result != 20) return 10;
    testMultiCaseHex(&hexFF);
    if (result != 30) return 11;
    testMultiCaseHex(&hexOther);
    if (result != 99) return 12;
    uint8_t bin0 = 0b00000000;
    uint8_t bin1 = 0b00000001;
    uint8_t binA = 0b00001010;
    uint8_t binFF = 0b11111111;
    uint8_t binOther = 0b00100000;
    testMultiCaseBinary(&bin0);
    if (result != 40) return 13;
    testMultiCaseBinary(&bin1);
    if (result != 40) return 14;
    testMultiCaseBinary(&binA);
    if (result != 50) return 15;
    testMultiCaseBinary(&binFF);
    if (result != 60) return 16;
    testMultiCaseBinary(&binOther);
    if (result != 99) return 17;
    int8_t sZero = 0;
    int8_t sOne = 1;
    int8_t sTwo = 2;
    int8_t sFifty = 50;
    int8_t sFiftyOne = 51;
    int8_t sMax1 = 126;
    int8_t sMax = 127;
    int8_t sNeg = -50;
    testMultiCaseSigned(&sZero);
    if (result != 1) return 18;
    testMultiCaseSigned(&sOne);
    if (result != 1) return 19;
    testMultiCaseSigned(&sTwo);
    if (result != 1) return 20;
    testMultiCaseSigned(&sFifty);
    if (result != 2) return 21;
    testMultiCaseSigned(&sFiftyOne);
    if (result != 2) return 22;
    testMultiCaseSigned(&sMax1);
    if (result != 3) return 23;
    testMultiCaseSigned(&sMax);
    if (result != 3) return 24;
    testMultiCaseSigned(&sNeg);
    if (result != 9) return 25;
    uint16_t m1 = 1;
    uint16_t m3 = 3;
    uint16_t m5 = 5;
    uint16_t m100 = 100;
    uint16_t m200 = 200;
    uint16_t m300 = 300;
    uint16_t mOther = 999;
    testManyMultiCases(&m1);
    if (result != 500) return 26;
    testManyMultiCases(&m3);
    if (result != 500) return 27;
    testManyMultiCases(&m5);
    if (result != 500) return 28;
    testManyMultiCases(&m100);
    if (result != 600) return 29;
    testManyMultiCases(&m200);
    if (result != 600) return 30;
    testManyMultiCases(&m300);
    if (result != 600) return 31;
    testManyMultiCases(&mOther);
    if (result != 999) return 32;
    return 0;
}
