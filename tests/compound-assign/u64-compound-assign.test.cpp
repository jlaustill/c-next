/**
 * Generated by C-Next Transpiler from: u64-compound-assign.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint64_t cnx_clamp_add_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)(UINT64_MAX - a)) return UINT64_MAX;
    uint64_t result;
    if (__builtin_add_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

static inline uint64_t cnx_clamp_mul_u64(uint64_t a, uint64_t b) {
    if (b != 0 && a > UINT64_MAX / b) return UINT64_MAX;
    uint64_t result;
    if (__builtin_mul_overflow(a, (uint64_t)b, &result)) return UINT64_MAX;
    return result;
}

static inline uint64_t cnx_clamp_sub_u64(uint64_t a, uint64_t b) {
    if (b > (uint64_t)a) return 0;
    uint64_t result;
    if (__builtin_sub_overflow(a, (uint64_t)b, &result)) return 0;
    return result;
}

// test-execution
// Tests: u64 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
int main(void) {
    uint64_t val = 1000000000000ULL;
    val = cnx_clamp_add_u64(val, 500000000000ULL);
    if (val != 1500000000000) return 1;
    val = 9000000000000000000ULL;
    val = cnx_clamp_add_u64(val, 1000000000000000000ULL);
    if (val != 10000000000000000000) return 2;
    val = 5000000000000ULL;
    val = cnx_clamp_add_u64(val, 0ULL);
    if (val != 5000000000000) return 3;
    val = 0ULL;
    val = cnx_clamp_add_u64(val, 18446744073709551614ULL);
    if (val != 18446744073709551614) return 4;
    val = 1500000000000ULL;
    val = cnx_clamp_sub_u64(val, 500000000000ULL);
    if (val != 1000000000000) return 10;
    val = 10000000000000000000ULL;
    val = cnx_clamp_sub_u64(val, 9000000000000000000ULL);
    if (val != 1000000000000000000) return 11;
    val = 5000000000000ULL;
    val = cnx_clamp_sub_u64(val, 0ULL);
    if (val != 5000000000000) return 12;
    val = 18446744073709551615ULL;
    val = cnx_clamp_sub_u64(val, 18446744073709551614ULL);
    if (val != 1) return 13;
    val = 1000ULL;
    val = cnx_clamp_sub_u64(val, 1000ULL);
    if (val != 0) return 14;
    val = 1000000ULL;
    val = cnx_clamp_mul_u64(val, 1000000ULL);
    if (val != 1000000000000) return 20;
    val = 5000000000000ULL;
    val = cnx_clamp_mul_u64(val, 1ULL);
    if (val != 5000000000000) return 21;
    val = 100000000ULL;
    val = cnx_clamp_mul_u64(val, 10000ULL);
    if (val != 1000000000000) return 22;
    val = 123456789ULL;
    val = cnx_clamp_mul_u64(val, 2ULL);
    if (val != 246913578) return 23;
    val = 4294967296ULL;
    val = cnx_clamp_mul_u64(val, 4294967296ULL);
    if (val != 18446744073709551615) return 24;
    val = 1000000000000ULL;
    val /= 1000ULL;
    if (val != 1000000000) return 30;
    val = 5000000000000ULL;
    val /= 1ULL;
    if (val != 5000000000000) return 31;
    val = 1000000000000ULL;
    val /= 2ULL;
    if (val != 500000000000) return 32;
    val = 9000000000000000000ULL;
    val /= 1000000ULL;
    if (val != 9000000000000) return 33;
    val = 100ULL;
    val /= 100ULL;
    if (val != 1) return 34;
    val = 1000000000007ULL;
    val %= 1000000ULL;
    if (val != 7) return 40;
    val = 1609459200000ULL;
    val %= 1000ULL;
    if (val != 0) return 41;
    val = 12345ULL;
    val %= 7ULL;
    if (val != 4) return 42;
    val = 100ULL;
    val %= 100ULL;
    if (val != 0) return 43;
    val = 9999999999999999999ULL;
    val %= 10ULL;
    if (val != 9) return 44;
    val = 0xFFFFFFFFFFFFFFFFULL;
    val &= 0x00000000FFFFFFFFULL;
    if (val != 0x00000000FFFFFFFF) return 50;
    val = 0xAAAAAAAAAAAAAAAAULL;
    val &= 0x5555555555555555ULL;
    if (val != 0) return 51;
    val = 0x123456789ABCDEF0ULL;
    val &= 0xFFFFFFFFFFFFFFFFULL;
    if (val != 0x123456789ABCDEF0) return 52;
    val = 0xFFFF0000FFFF0000ULL;
    val &= 0x0000FFFF0000FFFFULL;
    if (val != 0) return 53;
    val = 0x00000000FFFFFFFFULL;
    val |= 0xFFFFFFFF00000000ULL;
    if (val != 0xFFFFFFFFFFFFFFFF) return 60;
    val = 0x1234000000000000ULL;
    val |= 0x0000000056789ABCULL;
    if (val != 0x1234000056789ABC) return 61;
    val = 0x123456789ABCDEF0ULL;
    val |= 0x0000000000000000ULL;
    if (val != 0x123456789ABCDEF0) return 62;
    val = 0xAAAAAAAAAAAAAAAAULL;
    val ^= 0x5555555555555555ULL;
    if (val != 0xFFFFFFFFFFFFFFFF) return 70;
    val = 0xFFFFFFFFFFFFFFFFULL;
    val ^= 0xFFFFFFFFFFFFFFFFULL;
    if (val != 0) return 71;
    val = 0x123456789ABCDEF0ULL;
    val ^= 0x123456789ABCDEF0ULL;
    if (val != 0) return 72;
    val = 0x0F0F0F0F0F0F0F0FULL;
    val ^= 0xF0F0F0F0F0F0F0F0ULL;
    if (val != 0xFFFFFFFFFFFFFFFF) return 73;
    val = 1ULL;
    val <<= 0ULL;
    if (val != 1) return 80;
    val = 1ULL;
    val <<= 1ULL;
    if (val != 2) return 81;
    val = 1ULL;
    val <<= 32ULL;
    if (val != 4294967296) return 82;
    val = 1ULL;
    val <<= 63ULL;
    if (val != 9223372036854775808) return 83;
    val = 0xFFULL;
    val <<= 8ULL;
    if (val != 65280) return 84;
    val = 256ULL;
    val >>= 0ULL;
    if (val != 256) return 90;
    val = 256ULL;
    val >>= 1ULL;
    if (val != 128) return 91;
    val = 4294967296ULL;
    val >>= 32ULL;
    if (val != 1) return 92;
    val = 9223372036854775808ULL;
    val >>= 63ULL;
    if (val != 1) return 93;
    val = 0xFF00ULL;
    val >>= 8ULL;
    if (val != 255) return 94;
    return 0;
}
