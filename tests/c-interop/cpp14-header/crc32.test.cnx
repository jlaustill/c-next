// crc32.cnx - Memory-safe CRC32 using c-next's bounded strings
// Ported from ConfigStorage.cpp with safer serialization

#include "AppConfig.h"

// Calculate CRC32 checksum over AppConfig struct (excluding checksum field)
// Uses explicit field serialization instead of raw memory access
u32 calculateChecksum(const AppConfig config) {
    // Bounded string for serialization (AppConfig is ~200 bytes)
    string<512> buffer <- "";
    u32 offset <- 0;
    u8 length <- 0;

    // Serialize header fields
    length <- config.magic.length / 8;
    buffer[offset, length] <- config.magic;
    offset +<- length;

    length <- config.version.length / 8;
    buffer[offset, length] <- config.version;
    offset +<- length;

    length <- config.j1939SourceAddress.length / 8;
    buffer[offset, length] <- config.j1939SourceAddress;
    offset +<- length;

    // Skip reserved padding (2 bytes) - don't serialize undefined values

    // Serialize temperature inputs (8 structs)
    for (u32 i <- 0; i < TEMP_INPUT_COUNT; i +<- 1) {
        length <- config.tempInputs[i].assignedSpn.length / 8;
        buffer[offset, length] <- config.tempInputs[i].assignedSpn;
        offset +<- length;

        // Float fields (4 bytes each)
        length <- config.tempInputs[i].coeffA.length / 8;
        buffer[offset, length] <- config.tempInputs[i].coeffA;
        offset +<- length;

        length <- config.tempInputs[i].coeffB.length / 8;
        buffer[offset, length] <- config.tempInputs[i].coeffB;
        offset +<- length;

        length <- config.tempInputs[i].coeffC.length / 8;
        buffer[offset, length] <- config.tempInputs[i].coeffC;
        offset +<- length;

        length <- config.tempInputs[i].resistorValue.length / 8;
        buffer[offset, length] <- config.tempInputs[i].resistorValue;
        offset +<- length;
    }

    // Serialize pressure inputs (7 structs)
    for (u32 i <- 0; i < PRESSURE_INPUT_COUNT; i +<- 1) {
        length <- config.pressureInputs[i].assignedSpn.length / 8;
        buffer[offset, length] <- config.pressureInputs[i].assignedSpn;
        offset +<- length;

        length <- config.pressureInputs[i].maxPressure.length / 8;
        buffer[offset, length] <- config.pressureInputs[i].maxPressure;
        offset +<- length;

        length <- config.pressureInputs[i].pressureType.length / 8;
        buffer[offset, length] <- config.pressureInputs[i].pressureType;
        offset +<- length;

        // Skip reserved byte (1 byte padding)
    }

    // Serialize thermocouple config
    length <- config.egtEnabled.length / 8;
    buffer[offset, length] <- config.egtEnabled;
    offset +<- length;

    length <- config.thermocoupleType.length / 8;
    buffer[offset, length] <- config.thermocoupleType;
    offset +<- length;

    // Skip tcReserved (2 bytes padding)

    // Serialize BME280 config
    length <- config.bme280Enabled.length / 8;
    buffer[offset, length] <- config.bme280Enabled;
    offset +<- length;

    // Skip bme280Reserved (3 bytes padding)

    // NOTE: We intentionally DON'T serialize config.checksum - that's the field we're calculating!

    // Calculate CRC32 over serialized bytes
    u32 crc <- 0xFFFFFFFF;

    for (u32 i <- 0; i < offset; i +<- 1) {
        crc <- crc ^ buffer[i];

        for (i32 j <- 0; j < 8; j +<- 1) {
            if (crc & 1) {
                crc <- (crc >> 1) ^ 0xEDB88320;
            } else {
                crc <- crc >> 1;
            }
        }
    }

    return ~crc;
}
