/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "named-typedef-struct-array.test.h"

// tests/functions/named-typedef-struct-array.test.cnx
// test-execution
// Tests: Issue #355 - Array member via pointer generates invalid static_cast in C++ mode
// This test reproduces the EXACT pattern from issue #355:
// A scope method calls another scope method, passing a const struct array member.
#include "named-typedef-struct-array.h"

#include <stdint.h>

/* Scope: Handler */

uint32_t Handler_processBuffer(const uint8_t data[8], uint8_t len) {
    uint32_t sum = 0U;
    uint8_t i = 0U;
    while (i < len) {
        sum = sum + data[i];
        i = i + 1U;
    }
    return sum;
}

uint32_t Handler_processData(const uint8_t data[16], uint8_t len) {
    uint32_t sum = 0U;
    uint8_t i = 0U;
    while (i < len) {
        sum = sum + data[i];
        i = i + 1U;
    }
    return sum;
}

uint32_t Handler_handleMessage(const CAN_message_t* msg) {
    return Handler_processBuffer(msg->buf, msg->len);
}

uint32_t Handler_processMultiArray(const MultiArray_t* multi) {
    uint32_t headerSum = Handler_processBuffer(multi->header, 4U);
    uint32_t bodySum = Handler_processData(multi->body, multi->sizes[1U]);
    return headerSum + bodySum;
}

uint32_t Handler_handleMutableMessage(const CAN_message_t* msg) {
    return Handler_processBuffer(msg->buf, msg->len);
}

uint32_t testNamedTypedefConstArrayMember(void) {
    CAN_message_t msg = {0};
    msg.id = 1234U;
    msg.buf[0] = 10U;
    msg.buf[1] = 20U;
    msg.buf[2] = 30U;
    msg.buf[3] = 40U;
    msg.buf[4] = 0U;
    msg.buf[5] = 0U;
    msg.buf[6] = 0U;
    msg.buf[7] = 0U;
    msg.len = 4U;
    uint32_t result = Handler_handleMessage(&msg);
    return result;
}

uint32_t testMultipleArrayMembers(void) {
    MultiArray_t multi = {0};
    multi.header[0] = 1U;
    multi.header[1] = 2U;
    multi.header[2] = 3U;
    multi.header[3] = 4U;
    multi.body[0] = 10U;
    multi.body[1] = 20U;
    multi.sizes[0] = 4U;
    multi.sizes[1] = 2U;
    multi.sizes[2] = 2U;
    uint32_t result = Handler_processMultiArray(&multi);
    return result;
}

uint32_t testNonConstArrayMember(void) {
    CAN_message_t msg = {0};
    msg.id = 999U;
    msg.buf[0] = 100U;
    msg.buf[1] = 50U;
    msg.len = 2U;
    uint32_t result = Handler_handleMutableMessage(&msg);
    return result;
}

int main(void) {
    uint32_t result1 = testNamedTypedefConstArrayMember();
    if (result1 != 100) return 1;
    uint32_t result2 = testMultipleArrayMembers();
    if (result2 != 40) return 2;
    uint32_t result3 = testNonConstArrayMember();
    if (result3 != 150) return 3;
    return 0;
}
