{
  "file_path": "tests/scope/scope-critical-section.expected.c",
  "main_branch_history": [],
  "task_views": {
    "001-100-scope-testing-coverage": {
      "task_id": "001-100-scope-testing-coverage",
      "branch_point": {
        "commit_hash": "6085a00ee4bff6129a6503c31d4280591d7eb497",
        "content": "",
        "timestamp": "2026-01-09T22:16:23.113589"
      },
      "worktree_state": {
        "content": "/**\n * Generated by C-Next Transpiler\n * A safer C for embedded systems\n */\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <cmsis_gcc.h>\n\n// ADR-044: Overflow helper functions\n#include <limits.h>\n\nstatic inline uint32_t cnx_clamp_add_u32(uint32_t a, uint32_t b) {\n    if (a > UINT32_MAX - b) return UINT32_MAX;\n    return a + b;\n}\n\nstatic inline uint32_t cnx_clamp_sub_u32(uint32_t a, uint32_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\nstatic inline uint8_t cnx_clamp_add_u8(uint8_t a, uint8_t b) {\n    if (a > UINT8_MAX - b) return UINT8_MAX;\n    return a + b;\n}\n\nstatic inline uint8_t cnx_clamp_sub_u8(uint8_t a, uint8_t b) {\n    if (a < b) return 0;\n    return a - b;\n}\n\n// Test: ADR-016 + ADR-050 Critical sections inside scope methods\n// Verifies that critical { } blocks work correctly inside scope methods\n// Tests: public method with critical, private method with critical, this. inside critical, global. inside critical\n\n// Global variables for testing global. accessor inside critical sections\nuint8_t globalSharedBuffer[16] = {0};\nuint32_t globalWriteIndex = 0;\nuint32_t globalReadIndex = 0;\nbool globalBufferLock = false;\n\n/* Scope: CriticalTest */\nuint8_t CriticalTest_buffer[32] = {0};\nuint32_t CriticalTest_writeIndex = 0;\nuint32_t CriticalTest_readIndex = 0;\nuint8_t CriticalTest_count = 0;\nbool CriticalTest_locked = false;\n\n// Private method: basic critical section with this. accessor\nvoid CriticalTest_internalEnqueue(uint8_t* data) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        CriticalTest_buffer[CriticalTest_writeIndex] = (*data);\n        CriticalTest_writeIndex = cnx_clamp_add_u32(CriticalTest_writeIndex, 1);\n        CriticalTest_count = cnx_clamp_add_u8(CriticalTest_count, 1);\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Private method: critical section with conditional and this.\nuint8_t CriticalTest_internalDequeue(void) {\n    uint8_t result = 0;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        if (CriticalTest_count > 0) {\n            result = CriticalTest_buffer[CriticalTest_readIndex];\n            CriticalTest_readIndex = cnx_clamp_add_u32(CriticalTest_readIndex, 1);\n            CriticalTest_count = cnx_clamp_sub_u8(CriticalTest_count, 1);\n        }\n        __set_PRIMASK(__primask);\n    }\n    return result;\n}\n\n// Private method: critical section with global. accessor\nvoid CriticalTest_internalUpdateGlobal(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        globalWriteIndex = cnx_clamp_add_u32(globalWriteIndex, 1);\n        globalBufferLock = true;\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Private method: critical section with combined this. and global.\nvoid CriticalTest_internalTransfer(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        uint8_t data = CriticalTest_buffer[CriticalTest_readIndex];\n        globalSharedBuffer[globalWriteIndex] = data;\n        CriticalTest_readIndex = cnx_clamp_add_u32(CriticalTest_readIndex, 1);\n        globalWriteIndex = cnx_clamp_add_u32(globalWriteIndex, 1);\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Private method: critical section with boolean flag operations\nbool CriticalTest_internalTryLock(void) {\n    bool acquired = false;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        if (!CriticalTest_locked) {\n            CriticalTest_locked = true;\n            acquired = true;\n        }\n        __set_PRIMASK(__primask);\n    }\n    return acquired;\n}\n\n// Private method: critical section unlock\nvoid CriticalTest_internalUnlock(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        CriticalTest_locked = false;\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: basic critical section with this. accessor\nvoid CriticalTest_enqueue(uint8_t* data) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        CriticalTest_buffer[CriticalTest_writeIndex] = (*data);\n        CriticalTest_writeIndex = cnx_clamp_add_u32(CriticalTest_writeIndex, 1);\n        CriticalTest_count = cnx_clamp_add_u8(CriticalTest_count, 1);\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: critical section with conditional and this.\nuint8_t CriticalTest_dequeue(void) {\n    uint8_t result = 0;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        if (CriticalTest_count > 0) {\n            result = CriticalTest_buffer[CriticalTest_readIndex];\n            CriticalTest_readIndex = cnx_clamp_add_u32(CriticalTest_readIndex, 1);\n            CriticalTest_count = cnx_clamp_sub_u8(CriticalTest_count, 1);\n        }\n        __set_PRIMASK(__primask);\n    }\n    return result;\n}\n\n// Public method: critical section with global. accessor\nvoid CriticalTest_updateGlobalIndex(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        globalWriteIndex = cnx_clamp_add_u32(globalWriteIndex, 1);\n        globalReadIndex = cnx_clamp_add_u32(globalReadIndex, 1);\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: critical section with combined this. and global.\nvoid CriticalTest_transferToGlobal(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        uint8_t data = CriticalTest_buffer[CriticalTest_readIndex];\n        globalSharedBuffer[globalWriteIndex] = data;\n        CriticalTest_readIndex = cnx_clamp_add_u32(CriticalTest_readIndex, 1);\n        CriticalTest_count = cnx_clamp_sub_u8(CriticalTest_count, 1);\n        globalWriteIndex = cnx_clamp_add_u32(globalWriteIndex, 1);\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: get count inside critical section\nuint8_t CriticalTest_getCount(void) {\n    uint8_t result = 0;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        result = CriticalTest_count;\n        __set_PRIMASK(__primask);\n    }\n    return result;\n}\n\n// Public method: boolean flag operation in critical section\nbool CriticalTest_tryLock(void) {\n    bool acquired = false;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        if (!CriticalTest_locked) {\n            CriticalTest_locked = true;\n            acquired = true;\n        }\n        __set_PRIMASK(__primask);\n    }\n    return acquired;\n}\n\n// Public method: unlock in critical section\nvoid CriticalTest_unlock(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        CriticalTest_locked = false;\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: check if locked (thread-safe read)\nbool CriticalTest_isLocked(void) {\n    bool result = false;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        result = CriticalTest_locked;\n        __set_PRIMASK(__primask);\n    }\n    return result;\n}\n\n// Public method: multiple operations in single critical section\nvoid CriticalTest_resetAll(void) {\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        CriticalTest_writeIndex = 0;\n        CriticalTest_readIndex = 0;\n        CriticalTest_count = 0;\n        CriticalTest_locked = false;\n        __set_PRIMASK(__primask);\n    }\n}\n\n// Public method: compare scope and global values in critical section\nbool CriticalTest_isInSync(void) {\n    bool inSync = false;\n    {\n        uint32_t __primask = __get_PRIMASK();\n        __disable_irq();\n        inSync = CriticalTest_writeIndex == globalWriteIndex;\n        __set_PRIMASK(__primask);\n    }\n    return inSync;\n}\n\n// Public wrapper that calls internal critical method\nvoid CriticalTest_safeEnqueue(uint8_t* data) {\n    CriticalTest_internalEnqueue(data);\n}\n\n// Public wrapper that calls internal critical method\nuint8_t CriticalTest_safeDequeue(void) {\n    return CriticalTest_internalDequeue();\n}\n\n// Public method: chain lock-operation-unlock pattern\nvoid CriticalTest_lockedEnqueue(uint8_t* data) {\n    CriticalTest_internalTryLock();\n    CriticalTest_internalEnqueue(data);\n    CriticalTest_internalUnlock();\n}\n\nvoid main(void) {\n    // Test public methods with critical sections - basic this. operations\n    CriticalTest_enqueue(42);\n    CriticalTest_enqueue(84);\n    CriticalTest_dequeue();\n\n    // Test public methods with critical sections - global. operations\n    CriticalTest_updateGlobalIndex();\n    CriticalTest_transferToGlobal();\n\n    // Test thread-safe reads\n    CriticalTest_getCount();\n    CriticalTest_isLocked();\n\n    // Test lock/unlock pattern\n    CriticalTest_tryLock();\n    CriticalTest_unlock();\n\n    // Test reset\n    CriticalTest_resetAll();\n\n    // Test sync check\n    CriticalTest_isInSync();\n\n    // Test wrappers calling internal critical methods\n    CriticalTest_safeEnqueue(10);\n    CriticalTest_safeDequeue();\n    CriticalTest_lockedEnqueue(20);\n}\n",
        "last_modified": "2026-01-10T07:02:20.266640"
      },
      "task_intent": {
        "title": "100% Scope Testing Coverage",
        "description": "Expand the C-Next test suite to achieve comprehensive coverage of scope-related functionality including this./global. accessors with all data types, modifier permutations, and error cases.",
        "from_plan": true
      },
      "commits_behind_main": 1,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-09T22:16:23.133618",
  "last_updated": "2026-01-09T22:16:23.135067"
}