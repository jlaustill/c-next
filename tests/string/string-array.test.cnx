// test-execution
// ADR-045: Test array of strings
// Validates: declaration, element access, array.length, element.length, loops
// C-style allowed for string arrays (grammar limitation)
string<32> globalNames[5];

u32 getArrayLength(string<32>[5] arr) {
    return arr.length;
}

// Issue #136 fixed: arr[index].length now correctly returns strlen
u32 getElementLength(string<32>[5] arr, u32 index) {
    return arr[index].length;
}

i32 main() {
   
// Test 1: Initialize global array elements
    globalNames[0] <- "Alice";
    globalNames[1] <- "Bob";
    globalNames[2] <- "Charlie";
    globalNames[3] <- "Diana";
    globalNames[4] <- "Eve";

   
// Test 2: Array .length returns element count
    if (globalNames.length != 5) return 1;

   
// Test 3: Element .length returns string length (strlen)
    if (globalNames[0].length != 5) return 2; // "Alice"
    if (globalNames[1].length != 3) return 3; // "Bob"
    if (globalNames[2].length != 7) return 4; // "Charlie"
    if (globalNames[3].length != 5) return 5; // "Diana"
    if (globalNames[4].length != 3) return 6; // "Eve"

   
// Test 4: Element .capacity
    if (globalNames[0].capacity != 32) return 7;

   
// Test 5: Element .size
    if (globalNames[0].size != 33) return 8;

   
// Test 6: String comparison on array elements with literals
    if (globalNames[0] != "Alice") return 9;
    if (globalNames[2] != "Charlie") return 10;

   
// Test 7: Array element-to-element comparison (issue #137 fixed)
    string<32> dupes[3];
    dupes[0] <- "Alice";
    dupes[1] <- "Alice";
    dupes[2] <- "Bob";
    if (dupes[0] != dupes[1]) return 11; // Same content should be equal
    if (dupes[0] = dupes[2]) return 12; // Different content should not be equal

   
// Test 8: Local array of strings
    string<64> colors[3];
    colors[0] <- "Red";
    colors[1] <- "Green";
    colors[2] <- "Blue";

    if (colors.length != 3) return 13;
    if (colors[0].length != 3) return 14;
    if (colors[1].length != 5) return 15;
    if (colors[2].length != 4) return 16;

   
// Test 9: Pass array to function - get array length
    u32 arrLen <- getArrayLength(globalNames);
    if (arrLen != 5) return 17;

   
// Test 10: Pass array to function - get element length (issue #136 fixed)
    u32 elemLen0 <- getElementLength(globalNames, 0);
    if (elemLen0 != 5) return 18; // "Alice"
    u32 elemLen1 <- getElementLength(globalNames, 1);
    if (elemLen1 != 3) return 19; // "Bob"
    u32 elemLen2 <- getElementLength(globalNames, 2);
    if (elemLen2 != 7) return 20; // "Charlie"
    u32 elemLen3 <- getElementLength(globalNames, 3);
    if (elemLen3 != 5) return 21; // "Diana"
    u32 elemLen4 <- getElementLength(globalNames, 4);
    if (elemLen4 != 3) return 22; // "Eve"

   
// Test 11: Loop through array with index
    u32 totalLength <- 0;
    u32 i <- 0;
    while (i < globalNames.length) {
        totalLength <- totalLength + globalNames[i].length;
        i <- i + 1;
    }

    // 5 + 3 + 7 + 5 + 3 = 23
    if (totalLength != 23) return 23;

   
// Test 12: Reassign array element
    globalNames[1] <- "Benjamin";
    if (globalNames[1].length != 8) return 24;
    if (globalNames[1] != "Benjamin") return 25;

   
// Test 13: Empty string in array
    string<32> sparse[3];

    // sparse[0] is empty by default
    sparse[1] <- "Middle";

    // sparse[2] is empty by default
    if (sparse[0].length != 0) return 26;
    if (sparse[1].length != 6) return 27;
    if (sparse[2].length != 0) return 28;

    return 0;
}
