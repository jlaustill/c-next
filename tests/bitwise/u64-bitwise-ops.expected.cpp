/**
 * Generated by C-Next Transpiler from: u64-bitwise-ops.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-coverage: 5.1-u64-and, 5.2-u64-or, 5.3-u64-xor, 5.4-u64-not
// test-execution
// Test u64 bitwise operations: AND, OR, XOR, NOT
// Coverage: Section 5.1-5.4 for u64 type
int main(void) {
    uint64_t a = 0xFFFFFFFF00000000ULL;
    uint64_t b = 0xAAAAAAAAAAAAAAAAULL;
    uint64_t and_result = a & b;
    uint64_t or_result = a | b;
    uint64_t xor_result = a ^ b;
    uint64_t c = 0xAAAAAAAAAAAAAAAAULL;
    uint64_t not_result = static_cast<uint64_t>(~c);
    uint64_t small_a = 0xFFA0ULL;
    uint64_t small_b = 0xAAULL;
    uint64_t small_and = small_a & small_b;
    uint64_t small_or = small_a | small_b;
    uint64_t all_bits = 0xFFFFFFFFFFFFFFFFULL;
    uint64_t not_all = static_cast<uint64_t>(~all_bits);
    uint64_t lower32 = 0x12345678ULL;
    uint64_t mask32 = 0x00000000FFFFFFFFULL;
    uint64_t masked = lower32 & mask32;
    if (small_and == 160 && small_or == 65450 && not_all == 0 && masked == 0x12345678) {
        return 0;
    }
    return 1;
}
