/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <string.h>

/* test-execution */
// Tests: Runtime bounds checking for slice assignment
// Validates that out-of-bounds copies are prevented
// Buffer should remain unchanged when bounds are violated
int main(void) {
    uint8_t buffer[32] = {0};
    uint32_t pattern = 0x11111111;
    if (0 + 4 <= sizeof(buffer)) { memcpy(&buffer[0], &pattern, 4); }
    if (4 + 4 <= sizeof(buffer)) { memcpy(&buffer[4], &pattern, 4); }
    if (buffer[0] != 0x11) return 1;
    if (buffer[4] != 0x11) return 2;
    uint64_t largeValue = 0xDEADBEEFDEADBEEF;
    if (28 + 8 <= sizeof(buffer)) { memcpy(&buffer[28], &largeValue, 8); }
    if (buffer[28] != 0) return 3;
    if (buffer[29] != 0) return 4;
    if (buffer[0] != 0x11) return 5;
    if (buffer[4] != 0x11) return 6;
    uint32_t boundaryValue = 0x22222222;
    if (28 + 4 <= sizeof(buffer)) { memcpy(&buffer[28], &boundaryValue, 4); }
    if (buffer[28] != 0x22) return 7;
    if (buffer[29] != 0x22) return 8;
    if (buffer[30] != 0x22) return 9;
    if (buffer[31] != 0x22) return 10;
    uint32_t overValue = 0x33333333;
    if (29 + 4 <= sizeof(buffer)) { memcpy(&buffer[29], &overValue, 4); }
    if (buffer[29] != 0x22) return 11;
    if (buffer[0] != 0x11) return 12;
    return 0;
}
