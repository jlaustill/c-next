/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

// ADR-013: Short-circuit evaluation prevents unsafe operations
// Critical for embedded systems where bounds checking and validation matter
uint32_t accessCount = 0U;

uint32_t dangerousValue = 0U;

bool isIndexSafe(uint32_t index) {
    return index < 5;
}

uint32_t performDangerousOperation(uint32_t index) {
    accessCount = cnx_clamp_add_u32(accessCount, 1U);
    dangerousValue = index * 2U;
    return dangerousValue;
}

void testSafeGuardPattern(void) {
    accessCount = 0U;
    bool result = isIndexSafe(10U) && (performDangerousOperation(10U) > 0);
}

void testSafeGuardPatternValid(void) {
    accessCount = 0U;
    bool result = isIndexSafe(2U) && (performDangerousOperation(2U) >= 0);
}

void testOrSafetyPattern(void) {
    accessCount = 0U;
    uint32_t invalidIndex = 100U;
    bool shouldUseDefault = (invalidIndex >= 5) || (performDangerousOperation(invalidIndex) == 0);
}

typedef struct TStatusRegister {
    uint32_t enabled;
    uint32_t value;
} TStatusRegister;

TStatusRegister status = {0};

void testNullLikeCheck(void) {
    status.enabled = 0U;
    accessCount = 0U;
    bool shouldRead = (status.enabled != 0) && (status.value > 0);
}
