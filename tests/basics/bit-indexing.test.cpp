/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include <stdint.h>

// test-execution
// Tests: Bit indexing syntax (C-Next specific)
// Demonstrates: value[start, width] for bit extraction
int main(void) {
    uint32_t value = 0xDEADBEEFU;
    uint8_t lowByte = static_cast<uint8_t>(((value >> 0U) & 0xFFU));
    if (lowByte != 0xEF) return 1;
    uint8_t byte1 = static_cast<uint8_t>(((value >> 8U) & 0xFFU));
    if (byte1 != 0xBE) return 2;
    uint8_t byte2 = static_cast<uint8_t>(((value >> 16U) & 0xFFU));
    if (byte2 != 0xAD) return 3;
    uint8_t highByte = static_cast<uint8_t>(((value >> 24U) & 0xFFU));
    if (highByte != 0xDE) return 4;
    uint8_t lowNibble = static_cast<uint8_t>(((value >> 0U) & ((1U << 4U) - 1)));
    if (lowNibble != 0x0F) return 5;
    uint8_t highNibble = static_cast<uint8_t>(((value >> 4U) & ((1U << 4U) - 1)));
    if (highNibble != 0x0E) return 6;
    uint16_t lowWord = static_cast<uint16_t>(((value >> 0U) & 0xFFFFU));
    if (lowWord != 0xBEEF) return 7;
    uint16_t highWord = static_cast<uint16_t>(((value >> 16U) & 0xFFFFU));
    if (highWord != 0xDEAD) return 8;
    uint8_t testVal = 0b10101010U;
    uint8_t bit0 = static_cast<uint8_t>(((testVal >> 0U) & ((1U << 1U) - 1)));
    if (bit0 != 0) return 9;
    uint8_t bit1 = static_cast<uint8_t>(((testVal >> 1U) & ((1U << 1U) - 1)));
    if (bit1 != 1) return 10;
    uint8_t bit7 = static_cast<uint8_t>(((testVal >> 7U) & ((1U << 1U) - 1)));
    if (bit7 != 1) return 11;
    return 0;
}
