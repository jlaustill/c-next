// test-execution
// Tests: u64 array initialization, access, and modification
// Validates array operations with u64 element type
// Includes typical embedded use cases (timestamps, counters, buffers)
// Fixed size with explicit values (typical timestamps)
u64[4] timestamps <- [
    1000000000000,
    2000000000000,
    3000000000000,
    4000000000000
];

// Size inference
u64 counters[] <- [100, 200, 300, 400, 500];

// Fill syntax - zero initialized buffer
u64[100] buffer <- [0*];

// Fill syntax - ones
u64[50] ones <- [1*];

// Const lookup table (factorials)
const u64 factorials[] <- [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880];

u32 main() {
   
// Test explicit initialization access
    if (timestamps[0] != 1000000000000) return 1;
    if (timestamps[1] != 2000000000000) return 2;
    if (timestamps[2] != 3000000000000) return 3;
    if (timestamps[3] != 4000000000000) return 4;

   
// Test size inference
    if (counters[0] != 100) return 5;
    if (counters[2] != 300) return 6;
    if (counters[4] != 500) return 7;

   
// Test fill syntax - zeros
    if (buffer[0] != 0) return 8;
    if (buffer[50] != 0) return 9;
    if (buffer[99] != 0) return 10;

   
// Test fill syntax - ones
    if (ones[0] != 1) return 11;
    if (ones[25] != 1) return 12;
    if (ones[49] != 1) return 13;

   
// Test modification
    u64[5] mutableArr <- [10, 20, 30, 40, 50];
    mutableArr[2] <- 999;
    if (mutableArr[2] != 999) return 14;
    if (mutableArr[0] != 10) return 15; // Verify other elements unchanged
    if (mutableArr[4] != 50) return 16;

   
// Test iteration and accumulation
    u64 sum <- 0;
    for (u32 i <- 0; i < 5; i +<- 1) {
        sum +<- counters[i];
    }
    if (sum != 1500) return 17; // 100+200+300+400+500

   
// Test const table access
    if (factorials[0] != 1) return 18;
    if (factorials[5] != 120) return 19;
    if (factorials[9] != 362880) return 20;

   
// Test array with large values
    u64[3] large_vals <- [
        9000000000000000000,
        8000000000000000000,
        7000000000000000000
    ];
    if (large_vals[0] != 9000000000000000000) return 21;
    if (large_vals[2] != 7000000000000000000) return 22;

   
// Test sequential modification in loop
    u64[10] sequence;
    for (u32 i <- 0; i < 10; i +<- 1) {
        sequence[i] <- i * 1000000;
    }
    if (sequence[0] != 0) return 23;
    if (sequence[5] != 5000000) return 24;
    if (sequence[9] != 9000000) return 25;

   
// Test length property with u64 arrays
    if (timestamps.element_count != 4) return 26;
    if (counters.element_count != 5) return 27;
    if (buffer.element_count != 100) return 28;

   
// Test element length property
    if (timestamps[0].bit_length != 64) return 29;
    if (counters[0].bit_length != 64) return 30;

   
// Test array assignment from computation
    u64[3] computed;
    computed[0] <- 1000 * 1000; // 1 million
    computed[1] <- 1000 * 1000000; // 1 billion
    computed[2] <- computed[0] + computed[1];
    if (computed[2] != 1001000000) return 31;

    return 0;
}
