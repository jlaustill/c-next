{
  "file_path": "tests/scope/scope-critical-section.cnx",
  "main_branch_history": [],
  "task_views": {
    "001-100-scope-testing-coverage": {
      "task_id": "001-100-scope-testing-coverage",
      "branch_point": {
        "commit_hash": "6085a00ee4bff6129a6503c31d4280591d7eb497",
        "content": "",
        "timestamp": "2026-01-09T22:16:23.113589"
      },
      "worktree_state": {
        "content": "// Test: ADR-016 + ADR-050 Critical sections inside scope methods\n// Verifies that critical { } blocks work correctly inside scope methods\n// Tests: public method with critical, private method with critical, this. inside critical, global. inside critical\n\n// Global variables for testing global. accessor inside critical sections\nu8 globalSharedBuffer[16];\nu32 globalWriteIndex <- 0;\nu32 globalReadIndex <- 0;\nbool globalBufferLock <- false;\n\nscope CriticalTest {\n    // Scope-level variables accessed via this. inside critical sections\n    u8 buffer[32];\n    u32 writeIndex <- 0;\n    u32 readIndex <- 0;\n    u8 count <- 0;\n    bool locked <- false;\n\n    // ========================================\n    // PRIVATE METHODS with critical sections\n    // ========================================\n\n    // Private method: basic critical section with this. accessor\n    void internalEnqueue(u8 data) {\n        critical {\n            this.buffer[this.writeIndex] <- data;\n            this.writeIndex +<- 1;\n            this.count +<- 1;\n        }\n    }\n\n    // Private method: critical section with conditional and this.\n    u8 internalDequeue() {\n        u8 result <- 0;\n        critical {\n            if (this.count > 0) {\n                result <- this.buffer[this.readIndex];\n                this.readIndex +<- 1;\n                this.count -<- 1;\n            }\n        }\n        return result;\n    }\n\n    // Private method: critical section with global. accessor\n    void internalUpdateGlobal() {\n        critical {\n            global.globalWriteIndex +<- 1;\n            global.globalBufferLock <- true;\n        }\n    }\n\n    // Private method: critical section with combined this. and global.\n    void internalTransfer() {\n        critical {\n            u8 data <- this.buffer[this.readIndex];\n            global.globalSharedBuffer[global.globalWriteIndex] <- data;\n            this.readIndex +<- 1;\n            global.globalWriteIndex +<- 1;\n        }\n    }\n\n    // Private method: critical section with boolean flag operations\n    bool internalTryLock() {\n        bool acquired <- false;\n        critical {\n            if (!this.locked) {\n                this.locked <- true;\n                acquired <- true;\n            }\n        }\n        return acquired;\n    }\n\n    // Private method: critical section unlock\n    void internalUnlock() {\n        critical {\n            this.locked <- false;\n        }\n    }\n\n    // ========================================\n    // PUBLIC METHODS with critical sections\n    // ========================================\n\n    // Public method: basic critical section with this. accessor\n    public void enqueue(u8 data) {\n        critical {\n            this.buffer[this.writeIndex] <- data;\n            this.writeIndex +<- 1;\n            this.count +<- 1;\n        }\n    }\n\n    // Public method: critical section with conditional and this.\n    public u8 dequeue() {\n        u8 result <- 0;\n        critical {\n            if (this.count > 0) {\n                result <- this.buffer[this.readIndex];\n                this.readIndex +<- 1;\n                this.count -<- 1;\n            }\n        }\n        return result;\n    }\n\n    // Public method: critical section with global. accessor\n    public void updateGlobalIndex() {\n        critical {\n            global.globalWriteIndex +<- 1;\n            global.globalReadIndex +<- 1;\n        }\n    }\n\n    // Public method: critical section with combined this. and global.\n    public void transferToGlobal() {\n        critical {\n            u8 data <- this.buffer[this.readIndex];\n            global.globalSharedBuffer[global.globalWriteIndex] <- data;\n            this.readIndex +<- 1;\n            this.count -<- 1;\n            global.globalWriteIndex +<- 1;\n        }\n    }\n\n    // Public method: get count inside critical section\n    public u8 getCount() {\n        u8 result <- 0;\n        critical {\n            result <- this.count;\n        }\n        return result;\n    }\n\n    // Public method: boolean flag operation in critical section\n    public bool tryLock() {\n        bool acquired <- false;\n        critical {\n            if (!this.locked) {\n                this.locked <- true;\n                acquired <- true;\n            }\n        }\n        return acquired;\n    }\n\n    // Public method: unlock in critical section\n    public void unlock() {\n        critical {\n            this.locked <- false;\n        }\n    }\n\n    // Public method: check if locked (thread-safe read)\n    public bool isLocked() {\n        bool result <- false;\n        critical {\n            result <- this.locked;\n        }\n        return result;\n    }\n\n    // Public method: multiple operations in single critical section\n    public void resetAll() {\n        critical {\n            this.writeIndex <- 0;\n            this.readIndex <- 0;\n            this.count <- 0;\n            this.locked <- false;\n        }\n    }\n\n    // Public method: compare scope and global values in critical section\n    public bool isInSync() {\n        bool inSync <- false;\n        critical {\n            inSync <- this.writeIndex == global.globalWriteIndex;\n        }\n        return inSync;\n    }\n\n    // ========================================\n    // PUBLIC METHODS calling private methods with critical\n    // ========================================\n\n    // Public wrapper that calls internal critical method\n    public void safeEnqueue(u8 data) {\n        this.internalEnqueue(data);\n    }\n\n    // Public wrapper that calls internal critical method\n    public u8 safeDequeue() {\n        return this.internalDequeue();\n    }\n\n    // Public method: chain lock-operation-unlock pattern\n    public void lockedEnqueue(u8 data) {\n        this.internalTryLock();\n        this.internalEnqueue(data);\n        this.internalUnlock();\n    }\n}\n\nvoid main() {\n    // Test public methods with critical sections - basic this. operations\n    CriticalTest.enqueue(42);\n    CriticalTest.enqueue(84);\n    CriticalTest.dequeue();\n\n    // Test public methods with critical sections - global. operations\n    CriticalTest.updateGlobalIndex();\n    CriticalTest.transferToGlobal();\n\n    // Test thread-safe reads\n    CriticalTest.getCount();\n    CriticalTest.isLocked();\n\n    // Test lock/unlock pattern\n    CriticalTest.tryLock();\n    CriticalTest.unlock();\n\n    // Test reset\n    CriticalTest.resetAll();\n\n    // Test sync check\n    CriticalTest.isInSync();\n\n    // Test wrappers calling internal critical methods\n    CriticalTest.safeEnqueue(10);\n    CriticalTest.safeDequeue();\n    CriticalTest.lockedEnqueue(20);\n}\n",
        "last_modified": "2026-01-10T07:02:20.266377"
      },
      "task_intent": {
        "title": "100% Scope Testing Coverage",
        "description": "Expand the C-Next test suite to achieve comprehensive coverage of scope-related functionality including this./global. accessors with all data types, modifier permutations, and error cases.",
        "from_plan": true
      },
      "commits_behind_main": 1,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-09T22:16:23.131781",
  "last_updated": "2026-01-09T22:16:23.133419"
}