// test-execution
// Test: ADR-016 Modifiers in public and private method contexts
// Verifies that this. and global. accessors work correctly in all method contexts
// Tests: public methods, private methods, local variables with modifiers, combined access patterns

// Global variables for testing global. accessor in all method contexts
const u8 GLOBAL_MAX <- 100;
const u16 GLOBAL_THRESHOLD <- 1000;
u8 globalCounter <- 50;
bool globalEnabled <- true;
i16 globalOffset <- -25;
f32 globalScale <- 2.5;

scope MethodContexts {
    // Scope-level variables - private (default)
    u8 privateValue <- 10;
    clamp u8 privateClampValue <- 200;
    wrap u8 privateWrapValue <- 250;
    bool privateFlag <- false;
    i16 privateOffset <- -50;

    // Scope-level variables - public
    public u8 publicValue <- 20;
    public clamp u16 publicClampValue <- 60000;
    public wrap u16 publicWrapValue <- 65530;
    public bool publicFlag <- true;
    public i32 publicOffset <- -1000;

    // ========================================
    // PRIVATE METHODS - this. accessor tests
    // ========================================

    // Private method: basic this. access to private members
    u8 getPrivateValue() {
        return this.privateValue;
    }

    // Private method: basic this. access to public members
    u8 getPublicValueInternal() {
        return this.publicValue;
    }

    // Private method: this. with clamp modifier
    u8 getPrivateClampValue() {
        return this.privateClampValue;
    }

    // Private method: this. with wrap modifier
    u8 getPrivateWrapValue() {
        return this.privateWrapValue;
    }

    // Private method: this. modify private clamp variable
    void incrementPrivateClamp() {
        this.privateClampValue +<- 100;  // Clamps at 255
    }

    // Private method: this. modify private wrap variable
    void incrementPrivateWrap() {
        this.privateWrapValue +<- 10;  // Wraps around
    }

    // Private method: boolean this. access
    bool getPrivateFlag() {
        return this.privateFlag;
    }

    // Private method: signed integer this. access
    i16 getPrivateOffset() {
        return this.privateOffset;
    }

    // ========================================
    // PRIVATE METHODS - global. accessor tests
    // ========================================

    // Private method: global. access to const global
    u8 getGlobalMaxInternal() {
        return global.GLOBAL_MAX;
    }

    // Private method: global. access to mutable global
    u8 getGlobalCounterInternal() {
        return global.globalCounter;
    }

    // Private method: global. access to bool global
    bool getGlobalEnabledInternal() {
        return global.globalEnabled;
    }

    // Private method: global. access to signed global
    i16 getGlobalOffsetInternal() {
        return global.globalOffset;
    }

    // Private method: global. access to float global
    f32 getGlobalScaleInternal() {
        return global.globalScale;
    }

    // ========================================
    // PRIVATE METHODS - combined this. and global.
    // ========================================

    // Private method: combine scope and global values
    u8 computePrivateSum() {
        return this.privateValue + global.globalCounter;
    }

    // Private method: compare scope and global values
    bool privateValueBelowMax() {
        return this.privateValue < global.GLOBAL_MAX;
    }

    // Private method: offset calculation using this. and global.
    i16 computePrivateWithOffset() {
        return this.privateOffset + global.globalOffset;
    }

    // ========================================
    // PUBLIC METHODS - this. accessor tests
    // ========================================

    // Public method: basic this. access to private members
    public u8 getPrivateValueExternal() {
        return this.privateValue;
    }

    // Public method: basic this. access to public members
    public u8 getPublicValue() {
        return this.publicValue;
    }

    // Public method: this. with clamp modifier on public variable
    public u16 getPublicClampValue() {
        return this.publicClampValue;
    }

    // Public method: this. with wrap modifier on public variable
    public u16 getPublicWrapValue() {
        return this.publicWrapValue;
    }

    // Public method: this. modify public clamp variable
    public void incrementPublicClamp() {
        this.publicClampValue +<- 10000;  // Clamps at 65535
    }

    // Public method: this. modify public wrap variable
    public void incrementPublicWrap() {
        this.publicWrapValue +<- 10;  // Wraps around
    }

    // Public method: boolean this. access
    public bool getPublicFlag() {
        return this.publicFlag;
    }

    // Public method: signed integer this. access
    public i32 getPublicOffset() {
        return this.publicOffset;
    }

    // Public method: set private value via this.
    public void setPrivateValue(u8 val) {
        this.privateValue <- val;
    }

    // Public method: set public value via this.
    public void setPublicValue(u8 val) {
        this.publicValue <- val;
    }

    // Public method: set private flag via this.
    public void setPrivateFlag(bool val) {
        this.privateFlag <- val;
    }

    // Public method: set public flag via this.
    public void setPublicFlag(bool val) {
        this.publicFlag <- val;
    }

    // ========================================
    // PUBLIC METHODS - global. accessor tests
    // ========================================

    // Public method: global. access to const global
    public u8 getGlobalMax() {
        return global.GLOBAL_MAX;
    }

    // Public method: global. access to threshold
    public u16 getGlobalThreshold() {
        return global.GLOBAL_THRESHOLD;
    }

    // Public method: global. access to mutable global
    public u8 getGlobalCounter() {
        return global.globalCounter;
    }

    // Public method: global. access to bool global
    public bool getGlobalEnabled() {
        return global.globalEnabled;
    }

    // Public method: global. access to signed global
    public i16 getGlobalOffset() {
        return global.globalOffset;
    }

    // Public method: global. access to float global
    public f32 getGlobalScale() {
        return global.globalScale;
    }

    // ========================================
    // PUBLIC METHODS - combined this. and global.
    // ========================================

    // Public method: combine scope and global values (unsigned)
    public u8 computePublicSum() {
        return this.publicValue + global.globalCounter;
    }

    // Public method: compare scope and global values
    public bool publicValueBelowMax() {
        return this.publicValue < global.GLOBAL_MAX;
    }

    // Public method: offset calculation using this. and global.
    public i32 computePublicWithOffset() {
        return this.publicOffset + global.globalOffset;
    }

    // Public method: call private method (tests method chaining)
    public u8 getPrivateSumViaInternal() {
        return this.computePrivateSum();
    }

    // Public method: call private method that uses global.
    public u8 getGlobalCounterViaInternal() {
        return this.getGlobalCounterInternal();
    }

    // Public method: call private method that uses this.
    public u8 getPrivateClampViaInternal() {
        return this.getPrivateClampValue();
    }

    // ========================================
    // PUBLIC METHODS - comprehensive tests
    // ========================================

    // Public method: access all private modifiers via this.
    public void modifyAllPrivate() {
        this.privateValue <- this.privateValue + 1;
        this.privateClampValue +<- 10;
        this.privateWrapValue +<- 5;
        this.privateFlag <- !this.privateFlag;
        this.privateOffset <- this.privateOffset - 10;
    }

    // Public method: access all public modifiers via this.
    public void modifyAllPublic() {
        this.publicValue <- this.publicValue + 1;
        this.publicClampValue +<- 100;
        this.publicWrapValue +<- 5;
        this.publicFlag <- !this.publicFlag;
        this.publicOffset <- this.publicOffset - 100;
    }

    // Public method: mixed access - scope members and global values
    public bool checkThresholds() {
        return this.publicClampValue < global.GLOBAL_THRESHOLD && this.privateValue < global.GLOBAL_MAX;
    }

    // Public method: all bool flags
    public bool getAllFlags() {
        return this.privateFlag && this.publicFlag && global.globalEnabled;
    }
}

u32 main() {
    // ==========================================
    // SECTION 1: Public methods accessing private members via this.
    // ==========================================

   
// Test 1: getPrivateValueExternal() returns initial private value (10)
    if (MethodContexts.getPrivateValueExternal() != 10) return 1;

   
// Test 2: getPrivateSumViaInternal() - private method called by public
    // privateValue(10) + globalCounter(50) = 60
    if (MethodContexts.getPrivateSumViaInternal() != 60) return 2;

   
// Test 3: getGlobalCounterViaInternal() - private method accessing global
    if (MethodContexts.getGlobalCounterViaInternal() != 50) return 3;

   
// Test 4: getPrivateClampViaInternal() - private method with clamp modifier
    if (MethodContexts.getPrivateClampViaInternal() != 200) return 4;

    // ==========================================
    // SECTION 2: Public methods accessing public members via this.
    // ==========================================

   
// Test 5: getPublicValue() returns initial public value (20)
    if (MethodContexts.getPublicValue() != 20) return 5;

   
// Test 6: getPublicClampValue() - public clamp variable (60000)
    if (MethodContexts.getPublicClampValue() != 60000) return 6;

   
// Test 7: getPublicWrapValue() - public wrap variable (65530)
    if (MethodContexts.getPublicWrapValue() != 65530) return 7;

   
// Test 8: getPublicFlag() - public boolean (true)
    if (MethodContexts.getPublicFlag() != true) return 8;

   
// Test 9: getPublicOffset() - public signed integer (-1000)
    if (MethodContexts.getPublicOffset() != -1000) return 9;

    // ==========================================
    // SECTION 3: Public methods accessing global. values
    // ==========================================

   
// Test 10: getGlobalMax() - const global (100)
    if (MethodContexts.getGlobalMax() != 100) return 10;

   
// Test 11: getGlobalThreshold() - const global (1000)
    if (MethodContexts.getGlobalThreshold() != 1000) return 11;

   
// Test 12: getGlobalCounter() - mutable global (50)
    if (MethodContexts.getGlobalCounter() != 50) return 12;

   
// Test 13: getGlobalEnabled() - bool global (true)
    if (MethodContexts.getGlobalEnabled() != true) return 13;

   
// Test 14: getGlobalOffset() - signed global (-25)
    if (MethodContexts.getGlobalOffset() != -25) return 14;

   
// Test 15: getGlobalScale() - float global (2.5)
    // Use variable comparison to avoid float literal issues
    f32 expectedScale <- 2.5;
    if (MethodContexts.getGlobalScale() != expectedScale) return 15;

    // ==========================================
    // SECTION 4: Combined this. and global. access
    // ==========================================

   
// Test 16: computePublicSum() - publicValue(20) + globalCounter(50) = 70
    if (MethodContexts.computePublicSum() != 70) return 16;

   
// Test 17: publicValueBelowMax() - publicValue(20) < GLOBAL_MAX(100) = true
    if (MethodContexts.publicValueBelowMax() != true) return 17;

   
// Test 18: computePublicWithOffset() - publicOffset(-1000) + globalOffset(-25) = -1025
    if (MethodContexts.computePublicWithOffset() != -1025) return 18;

    // ==========================================
    // SECTION 5: Setter methods modify state
    // ==========================================

   
// Test 19-20: setPrivateValue and verify
    // Issue #233: setPrivateValue resets privateValue to 10, then sets to 42
    MethodContexts.setPrivateValue(42);
    if (MethodContexts.getPrivateValueExternal() != 42) return 19;


// Test 20: Verify computePrivateSum - privateValue(42) + globalCounter(50) = 92
    // Note: computePrivateSum only reads, so privateValue stays 42
    if (MethodContexts.getPrivateSumViaInternal() != 92) return 20;


// Test 21-22: setPublicValue and verify
    // Issue #233: setPublicValue resets publicValue to 20, then sets to 84
    MethodContexts.setPublicValue(84);
    if (MethodContexts.getPublicValue() != 84) return 21;


// Test 22: Verify computePublicSum - publicValue(84) + globalCounter(50) = 134
    // Note: computePublicSum only reads, so publicValue stays 84
    if (MethodContexts.computePublicSum() != 134) return 22;

   
// Test 23: setPrivateFlag and verify
    MethodContexts.setPrivateFlag(true);
    // Note: getAllFlags needs privateFlag=true, publicFlag=true, globalEnabled=true
    // Currently publicFlag=true (default), so this should work after setting privateFlag

   
// Test 24: setPublicFlag and verify
    MethodContexts.setPublicFlag(false);
    if (MethodContexts.getPublicFlag() != false) return 24;

    // ==========================================
    // SECTION 6: Modifier behavior (clamp/wrap)
    // ==========================================

   
// Test 25: incrementPublicClamp - adds 10000 to 60000, clamps at 65535
    MethodContexts.incrementPublicClamp();
    // 60000 + 10000 = 70000, clamped to 65535
    if (MethodContexts.getPublicClampValue() != 65535) return 25;

   
// Test 26: incrementPublicWrap - adds 10 to 65530, wraps around
    MethodContexts.incrementPublicWrap();
    // 65530 + 10 = 65540, wraps to 65540 - 65536 = 4
    if (MethodContexts.getPublicWrapValue() != 4) return 26;

    // ==========================================
    // SECTION 7: modifyAllPrivate comprehensive test
    // ==========================================

    // With persistent scope variables:
    // State: privateValue=42, privateClampValue=200, privateWrapValue=250
    //        privateFlag=true (from test 23), privateOffset=-50


// Test 27: Call modifyAllPrivate - modifies persisted values
    MethodContexts.modifyAllPrivate();
    // privateValue: 42 + 1 = 43
    if (MethodContexts.getPrivateValueExternal() != 43) return 27;


// Test 28: privateClampValue: 200 + 10 = 210
    if (MethodContexts.getPrivateClampViaInternal() != 210) return 28;


// Test 29: privateWrapValue: 250 + 5 = 255 (no wrap yet)
    // Note: Can't directly access private wrap value, but we tested the method exists

    // ==========================================
    // SECTION 8: modifyAllPublic comprehensive test
    // ==========================================

    // With persistent scope variables:
    // State: publicValue=84, publicClampValue=65535 (clamped), publicWrapValue=4 (wrapped)
    //        publicFlag=false (from test 24), publicOffset=-1000


// Test 30: Call modifyAllPublic - modifies persisted values
    MethodContexts.modifyAllPublic();
    // publicValue: 84 + 1 = 85
    if (MethodContexts.getPublicValue() != 85) return 30;


// Test 31: publicClampValue: 65535 + 100 = clamped to 65535
    if (MethodContexts.getPublicClampValue() != 65535) return 31;


// Test 32: publicWrapValue: 4 + 5 = 9
    if (MethodContexts.getPublicWrapValue() != 9) return 32;


// Test 33: publicFlag: !false = true
    if (MethodContexts.getPublicFlag() != true) return 33;


// Test 34: publicOffset: -1000 - 100 = -1100
    if (MethodContexts.getPublicOffset() != -1100) return 34;

    // ==========================================
    // SECTION 9: Threshold and flag checks
    // ==========================================


// Test 35: checkThresholds() - only reads
    // publicClampValue=65535 < GLOBAL_THRESHOLD=1000 is FALSE
    // So the && with privateValue < GLOBAL_MAX doesn't matter - result is false
    if (MethodContexts.checkThresholds() != false) return 35;


// Test 36: getAllFlags() - only reads
    // privateFlag was toggled to false by modifyAllPrivate (!true = false)
    // publicFlag was toggled to true by modifyAllPublic (!false = true)
    // globalEnabled is true
    // So getAllFlags = false && true && true = false
    if (MethodContexts.getAllFlags() != false) return 36;

    // ==========================================
    // SECTION 10: Direct public variable access
    // ==========================================

    // After modifyAllPublic: publicValue=85, publicClampValue=65535, publicWrapValue=9
    //                        publicFlag=true, publicOffset=-1100

// Test 37: Direct read of publicValue
    if (MethodContexts.publicValue != 85) return 37;


// Test 38: Direct read of publicClampValue
    if (MethodContexts.publicClampValue != 65535) return 38;


// Test 39: Direct read of publicWrapValue
    if (MethodContexts.publicWrapValue != 9) return 39;


// Test 40: Direct read of publicFlag
    if (MethodContexts.publicFlag != true) return 40;


// Test 41: Direct read of publicOffset
    if (MethodContexts.publicOffset != -1100) return 41;

    // ==========================================
    // SECTION 11: Direct public variable modification
    // ==========================================

   
// Test 42: Direct write to publicValue and verify via getter
    MethodContexts.publicValue <- 99;
    if (MethodContexts.getPublicValue() != 99) return 42;

   
// Test 43: Direct write to publicFlag and verify via getter
    MethodContexts.publicFlag <- false;
    if (MethodContexts.getPublicFlag() != false) return 43;

    // All 43 validations passed
    return 0;
}
