/**
 * Header Generator
 * Generates C header (.h) files from C-Next source
 */

import ISymbol from "../types/ISymbol";
import ESymbolKind from "../types/ESymbolKind";
import ESourceLanguage from "../types/ESourceLanguage";
import SymbolTable from "../symbols/SymbolTable";
import IHeaderOptions from "./types/IHeaderOptions";
import IHeaderTypeInput from "./headerGenerators/IHeaderTypeInput";
import typeUtils from "./headerGenerators/mapType";
import generateEnumHeader from "./headerGenerators/generateEnumHeader";
import generateStructHeader from "./headerGenerators/generateStructHeader";
import generateBitmapHeader from "./headerGenerators/generateBitmapHeader";

const { TYPE_MAP, mapType } = typeUtils;

/** Issue #269: Pass-by-value parameter info from CodeGenerator */
type TPassByValueParams = ReadonlyMap<string, ReadonlySet<string>>;

/**
 * Generates C header files from symbol information
 */
class HeaderGenerator {
  /**
   * Generate a header file from symbols
   *
   * @param symbols - Array of symbols to include in header
   * @param filename - Output filename (used for include guard)
   * @param options - Header generation options
   * @param typeInput - Optional type information for full definitions (enums, structs, bitmaps)
   * @param passByValueParams - Issue #269: Map of function names to pass-by-value parameter names
   */
  generate(
    symbols: ISymbol[],
    filename: string,
    options: IHeaderOptions = {},
    typeInput?: IHeaderTypeInput,
    passByValueParams?: TPassByValueParams,
  ): string {
    const lines: string[] = [];
    const guard = this.makeGuard(filename, options.guardPrefix);

    // Header guard
    lines.push(`#ifndef ${guard}`);
    lines.push(`#define ${guard}`);
    lines.push("");

    // Header comment
    lines.push("/**");
    lines.push(" * Generated by C-Next Transpiler");
    lines.push(" * Header file for cross-language interoperability");
    lines.push(" */");
    lines.push("");

    // System includes
    if (options.includeSystemHeaders !== false) {
      lines.push("#include <stdint.h>");
      lines.push("#include <stdbool.h>");
      lines.push("");
    }

    // C++ compatibility
    lines.push("#ifdef __cplusplus");
    lines.push('extern "C" {');
    lines.push("#endif");
    lines.push("");

    // Filter symbols
    const exportedSymbols = options.exportedOnly
      ? symbols.filter((s) => s.isExported)
      : symbols;

    // Group symbols by kind
    const structs = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Struct,
    );
    const classes = exportedSymbols.filter((s) => s.kind === ESymbolKind.Class);
    const functions = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Function,
    );
    const variables = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Variable,
    );
    const enums = exportedSymbols.filter((s) => s.kind === ESymbolKind.Enum);
    const types = exportedSymbols.filter((s) => s.kind === ESymbolKind.Type);
    const bitmaps = exportedSymbols.filter(
      (s) => s.kind === ESymbolKind.Bitmap,
    );

    // Issue #121: Collect external type dependencies from function signatures
    const localStructNames = new Set(structs.map((s) => s.name));
    const localEnumNames = new Set(enums.map((s) => s.name));
    const localTypeNames = new Set(types.map((s) => s.name));
    const localBitmapNames = new Set(bitmaps.map((s) => s.name));
    const externalTypes = this.collectExternalTypes(
      functions,
      variables,
      localStructNames,
      localEnumNames,
      localTypeNames,
      localBitmapNames,
    );

    // Emit forward declarations for external types
    // Issue #296: Use typedef forward declaration for compatibility with named structs
    if (externalTypes.size > 0) {
      lines.push(
        "/* External type dependencies - include appropriate headers */",
      );
      for (const typeName of externalTypes) {
        lines.push(`typedef struct ${typeName} ${typeName};`);
      }
      lines.push("");
    }

    // Struct definitions or forward declarations
    if (structs.length > 0 || classes.length > 0) {
      if (typeInput) {
        lines.push("/* Struct definitions */");
        for (const sym of structs) {
          lines.push(generateStructHeader(sym.name, typeInput));
        }
        for (const sym of classes) {
          lines.push(generateStructHeader(sym.name, typeInput));
        }
      } else {
        lines.push("/* Forward declarations */");
        for (const sym of structs) {
          lines.push(`typedef struct ${sym.name} ${sym.name};`);
        }
        for (const sym of classes) {
          lines.push(`typedef struct ${sym.name} ${sym.name};`);
        }
      }
      lines.push("");
    }

    // Enum definitions or comments
    if (enums.length > 0) {
      lines.push("/* Enumerations */");
      for (const sym of enums) {
        if (typeInput) {
          lines.push(generateEnumHeader(sym.name, typeInput));
        } else {
          lines.push(`/* Enum: ${sym.name} (see implementation for values) */`);
        }
      }
      lines.push("");
    }

    // Bitmap definitions (only when typeInput is available)
    if (bitmaps.length > 0) {
      lines.push("/* Bitmaps */");
      for (const sym of bitmaps) {
        if (typeInput) {
          lines.push(generateBitmapHeader(sym.name, typeInput));
        } else {
          lines.push(
            `/* Bitmap: ${sym.name} (see implementation for layout) */`,
          );
        }
      }
      lines.push("");
    }

    // Type aliases
    if (types.length > 0) {
      lines.push("/* Type aliases */");
      for (const sym of types) {
        if (sym.type) {
          const cType = mapType(sym.type);
          lines.push(`typedef ${cType} ${sym.name};`);
        }
      }
      lines.push("");
    }

    // Extern variable declarations
    if (variables.length > 0) {
      lines.push("/* External variables */");
      for (const sym of variables) {
        const cType = sym.type ? mapType(sym.type) : "int";
        // Issue #288: Include const qualifier for const variables
        const constPrefix = sym.isConst ? "const " : "";
        lines.push(`extern ${constPrefix}${cType} ${sym.name};`);
      }
      lines.push("");
    }

    // Function prototypes
    if (functions.length > 0) {
      lines.push("/* Function prototypes */");
      for (const sym of functions) {
        const proto = this.generateFunctionPrototype(sym, passByValueParams);
        if (proto) {
          lines.push(proto);
        }
      }
      lines.push("");
    }

    // C++ compatibility end
    lines.push("#ifdef __cplusplus");
    lines.push("}");
    lines.push("#endif");
    lines.push("");

    // End header guard
    lines.push(`#endif /* ${guard} */`);
    lines.push("");

    return lines.join("\n");
  }

  /**
   * Generate header from a symbol table, filtering by source file
   */
  generateFromSymbolTable(
    symbolTable: SymbolTable,
    sourceFile: string,
    options: IHeaderOptions = {},
  ): string {
    const symbols = symbolTable.getSymbolsByFile(sourceFile);
    const basename = sourceFile.replace(/\.[^.]+$/, "");
    const headerName = `${basename}.h`;

    return this.generate(symbols, headerName, options);
  }

  /**
   * Generate header for all C-Next symbols in the symbol table
   */
  generateCNextHeader(
    symbolTable: SymbolTable,
    filename: string,
    options: IHeaderOptions = {},
  ): string {
    const symbols = symbolTable.getSymbolsByLanguage(ESourceLanguage.CNext);
    return this.generate(symbols, filename, options);
  }

  /**
   * Create an include guard macro from filename
   */
  private makeGuard(filename: string, prefix?: string): string {
    // Remove path and extension
    const base = filename.replace(/^.*[\\/]/, "").replace(/\.[^.]+$/, "");

    // Convert to uppercase and replace non-alphanumeric with underscore
    const sanitized = base.toUpperCase().replace(/[^A-Z0-9]/g, "_");

    if (prefix) {
      return `${prefix.toUpperCase()}_${sanitized}_H`;
    }

    return `${sanitized}_H`;
  }

  /**
   * Generate a function prototype from symbol info
   * Handles all parameter edge cases per ADR-006, ADR-029, and ADR-040
   * Issue #269: Also handles pass-by-value for small unmodified primitives
   */
  private generateFunctionPrototype(
    sym: ISymbol,
    passByValueParams?: TPassByValueParams,
  ): string | null {
    // Map return type from C-Next to C
    // Special case: main() always returns int for C/C++ compatibility
    const mappedType = sym.type ? mapType(sym.type) : "void";
    const returnType = sym.name === "main" ? "int" : mappedType;

    // Issue #269: Get pass-by-value parameter names for this function
    const passByValueSet = passByValueParams?.get(sym.name);

    // Build parameter list with proper C semantics
    let params = "void"; // Default for no parameters

    if (sym.parameters && sym.parameters.length > 0) {
      const translatedParams = sym.parameters.map((p) => {
        const baseType = mapType(p.type);
        // Issue #268: Include auto-const for unmodified pointer parameters
        const constMod = p.isConst ? "const " : "";
        const autoConst = p.isAutoConst ? "const " : "";

        // Handle array parameters (pass naturally as pointers per C semantics)
        if (p.isArray && p.arrayDimensions) {
          const dims = p.arrayDimensions.map((d) => `[${d}]`).join("");
          // Special case: string[] becomes char* name[]
          if (p.type === "string") {
            return `${autoConst}${constMod}char* ${p.name}${dims}`;
          }
          return `${autoConst}${constMod}${baseType} ${p.name}${dims}`;
        }

        // ADR-040: ISR is already a function pointer typedef, no pointer needed
        if (p.type === "ISR") {
          return `${constMod}${baseType} ${p.name}`;
        }

        // Float types (f32, f64) use standard C pass-by-value semantics
        if (p.type === "f32" || p.type === "f64") {
          return `${constMod}${baseType} ${p.name}`;
        }

        // Issue #269: Check if parameter should be passed by value
        if (passByValueSet?.has(p.name)) {
          return `${constMod}${baseType} ${p.name}`;
        }

        // ADR-006: Pass by reference - non-array, non-float params become pointers
        // Issue #268: Add auto-const for unmodified parameters
        // This applies to primitives (u32, i16, etc.) and struct types
        return `${autoConst}${constMod}${baseType}* ${p.name}`;
      });
      params = translatedParams.join(", ");
    }

    return `${returnType} ${sym.name}(${params});`;
  }

  /**
   * Issue #121: Collect external type dependencies from function signatures and variables
   * Returns types that are:
   * - Not primitive types (not in TYPE_MAP)
   * - Not locally defined structs, enums, bitmaps, or type aliases
   */
  private collectExternalTypes(
    functions: ISymbol[],
    variables: ISymbol[],
    localStructs: Set<string>,
    localEnums: Set<string>,
    localTypes: Set<string>,
    localBitmaps: Set<string>,
  ): Set<string> {
    const externalTypes = new Set<string>();

    const isExternalType = (typeName: string): boolean => {
      // Skip if it's a primitive type
      if (TYPE_MAP[typeName]) {
        return false;
      }

      // Skip if locally defined
      if (localStructs.has(typeName)) {
        return false;
      }
      if (localEnums.has(typeName)) {
        return false;
      }
      if (localTypes.has(typeName)) {
        return false;
      }
      if (localBitmaps.has(typeName)) {
        return false;
      }

      // Skip pointer markers and array brackets
      if (typeName === "" || typeName === "*") {
        return false;
      }

      return true;
    };

    const extractBaseType = (type: string): string => {
      // Remove pointer suffix
      let baseType = type.replace(/\*+$/, "").trim();

      // Remove array brackets
      baseType = baseType.replace(/\[\d*\]$/, "").trim();

      // Handle const prefix
      baseType = baseType.replace(/^const\s+/, "").trim();

      return baseType;
    };

    // Check function return types and parameters
    for (const fn of functions) {
      // Check return type
      if (fn.type) {
        const baseType = extractBaseType(fn.type);
        if (isExternalType(baseType)) {
          externalTypes.add(baseType);
        }
      }

      // Check parameter types
      if (fn.parameters) {
        for (const param of fn.parameters) {
          if (param.type) {
            const baseType = extractBaseType(param.type);
            if (isExternalType(baseType)) {
              externalTypes.add(baseType);
            }
          }
        }
      }
    }

    // Check variable types
    for (const v of variables) {
      if (v.type) {
        const baseType = extractBaseType(v.type);
        if (isExternalType(baseType)) {
          externalTypes.add(baseType);
        }
      }
    }

    return externalTypes;
  }
}

export default HeaderGenerator;
