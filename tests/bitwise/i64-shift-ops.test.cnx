/* test-execution */
// Test i64 shift operations: arithmetic right shift preserves sign
// Coverage: Section 5.5-5.6 for i64 type

u32 main() {
    // Left shift - logical
    i64 a <- 1;
    i64 left1 <- a << 1;   // 2
    i64 left32 <- a << 32; // 4294967296
    i64 left62 <- a << 62; // 4611686018427387904

    // Right shift on positive
    i64 b <- 4611686018427387904;  // 0x4000000000000000
    i64 right1 <- b >> 1;   // 0x2000000000000000
    i64 right32 <- b >> 32; // 0x0000000040000000 = 1073741824
    i64 right62 <- b >> 62; // 0x0000000000000001 = 1

    // Right shift on negative - sign extension
    i64 c <- -4611686018427387904;  // 0xC000000000000000 (two's complement)
    i64 neg_right1 <- c >> 1;   // 0xE000000000000000
    i64 neg_right32 <- c >> 32; // 0xFFFFFFFFC0000000 = -1073741824
    i64 neg_right62 <- c >> 62; // 0xFFFFFFFFFFFFFFFF = -1

    // Edge case: shift -1 (all bits set)
    i64 minus_one <- -1;
    i64 shift_minus_one <- minus_one >> 32;  // Still -1

    // Shift by variable
    i64 d <- 256;
    i64 shift_amount <- 4;
    i64 left_var <- d << shift_amount;   // 4096
    i64 right_var <- d >> shift_amount;  // 16

    // Complex: negative shift
    i64 e <- -4294967296;
    i64 neg_shift <- e >> 16;  // -65536 (sign preserved)

    // Verify results
    if (left1 = 2 && left32 = 4294967296 && right62 = 1) {
        if (right32 = 1073741824 && neg_right32 = -1073741824 && neg_right62 = -1) {
            if (shift_minus_one = -1 && left_var = 4096 && right_var = 16) {
                if (neg_shift = -65536) {
                    return 0;
                }
            }
        }
    }
    return 1;
}
