/**
 * Generated by C-Next Transpiler from: u32-compound-assign.test.cnx
 * A safer C for embedded systems
 */

#include <stdint.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)(UINT32_MAX - a)) return UINT32_MAX;
    uint32_t result;
    if (__builtin_add_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint32_t cnx_clamp_mul_u32(uint32_t a, uint64_t b) {
    if (b != 0 && a > UINT32_MAX / b) return UINT32_MAX;
    uint32_t result;
    if (__builtin_mul_overflow(a, (uint32_t)b, &result)) return UINT32_MAX;
    return result;
}

static inline uint32_t cnx_clamp_sub_u32(uint32_t a, uint64_t b) {
    if (b > (uint64_t)a) return 0;
    uint32_t result;
    if (__builtin_sub_overflow(a, (uint32_t)b, &result)) return 0;
    return result;
}

// test-execution
// Tests: u32 compound assignment operators
// Validates: All 10 compound operators (+<-, -<-, *<-, /<-, %<-, &<-, |<-, ^<-, <<<-, >><-)
// Coverage: Issue #22 - Complete compound assignment operator coverage
// Range: 0 to 4294967295
int main(void) {
    uint32_t val = 2000000000U;
    val = cnx_clamp_add_u32(val, 1000000000U);
    if (val != 3000000000) return 1;
    val = 4000000000U;
    val = cnx_clamp_add_u32(val, 0U);
    if (val != 4000000000) return 2;
    val = 0U;
    val = cnx_clamp_add_u32(val, 4294967294U);
    if (val != 4294967294) return 3;
    val = 4294967294U;
    val = cnx_clamp_add_u32(val, 1U);
    if (val != 4294967295) return 4;
    uint32_t sub = 3000000000U;
    sub = cnx_clamp_sub_u32(sub, 1000000000U);
    if (sub != 2000000000) return 10;
    sub = 2000000000U;
    sub = cnx_clamp_sub_u32(sub, 0U);
    if (sub != 2000000000) return 11;
    sub = 4294967295U;
    sub = cnx_clamp_sub_u32(sub, 4294967294U);
    if (sub != 1) return 12;
    sub = 2000000000U;
    sub = cnx_clamp_sub_u32(sub, 2000000000U);
    if (sub != 0) return 13;
    sub = 1U;
    sub = cnx_clamp_sub_u32(sub, 1U);
    if (sub != 0) return 14;
    uint32_t mul = 50000U;
    mul = cnx_clamp_mul_u32(mul, 50000U);
    if (mul != 2500000000) return 20;
    mul = 1000000U;
    mul = cnx_clamp_mul_u32(mul, 1U);
    if (mul != 1000000) return 21;
    mul = 65536U;
    mul = cnx_clamp_mul_u32(mul, 65535U);
    if (mul != 4294901760) return 22;
    mul = 65536U;
    mul = cnx_clamp_mul_u32(mul, 65536U);
    if (mul != 4294967295) return 23;
    mul = 1000000U;
    mul = cnx_clamp_mul_u32(mul, 0U);
    if (mul != 0) return 24;
    uint32_t div = 3000000000U;
    div /= 1000U;
    if (div != 3000000) return 30;
    div = 1000000000U;
    div /= 1U;
    if (div != 1000000000) return 31;
    div = 4294967295U;
    div /= 4294967295U;
    if (div != 1) return 32;
    div = 1000000000U;
    div /= 3U;
    if (div != 333333333) return 33;
    div = 0U;
    div /= 1000U;
    if (div != 0) return 34;
    uint32_t mod = 1000000007U;
    mod %= 1000000U;
    if (mod != 7) return 40;
    mod = 4000000000U;
    mod %= 1000000000U;
    if (mod != 0) return 41;
    mod = 12345U;
    mod %= 7U;
    if (mod != 4) return 42;
    mod = 4294967295U;
    mod %= 65536U;
    if (mod != 65535) return 43;
    mod = 1U;
    mod %= 2U;
    if (mod != 1) return 44;
    uint32_t andVal = 0xFFFFFFFFU;
    andVal &= 0x0000FFFFU;
    if (andVal != 0x0000FFFF) return 50;
    andVal = 0xAAAAAAAAU;
    andVal &= 0x55555555U;
    if (andVal != 0) return 51;
    andVal = 0x55555555U;
    andVal &= 0xFFFFFFFFU;
    if (andVal != 0x55555555) return 52;
    andVal = 0xFFFF0000U;
    andVal &= 0x0000FFFFU;
    if (andVal != 0) return 53;
    uint32_t orVal = 0x0000FFFFU;
    orVal |= 0xFFFF0000U;
    if (orVal != 0xFFFFFFFF) return 60;
    orVal = 0x55555555U;
    orVal |= 0x00000000U;
    if (orVal != 0x55555555) return 61;
    orVal = 0xAAAAAAAAU;
    orVal |= 0x55555555U;
    if (orVal != 0xFFFFFFFF) return 62;
    uint32_t xorVal = 0xAAAAAAAAU;
    xorVal ^= 0x55555555U;
    if (xorVal != 0xFFFFFFFF) return 70;
    xorVal = 0xFFFFFFFFU;
    xorVal ^= 0xFFFFFFFFU;
    if (xorVal != 0) return 71;
    xorVal = 0x55555555U;
    xorVal ^= 0x55555555U;
    if (xorVal != 0) return 72;
    xorVal = 0x0000FFFFU;
    xorVal ^= 0xFFFF0000U;
    if (xorVal != 0xFFFFFFFF) return 73;
    uint32_t shl = 1U;
    shl <<= 0U;
    if (shl != 1) return 80;
    shl = 1U;
    shl <<= 1U;
    if (shl != 2) return 81;
    shl = 1U;
    shl <<= 16U;
    if (shl != 65536) return 82;
    shl = 1U;
    shl <<= 31U;
    if (shl != 2147483648) return 83;
    shl = 0x0000FFFFU;
    shl <<= 16U;
    if (shl != 0xFFFF0000) return 84;
    uint32_t shr = 2147483648U;
    shr >>= 0U;
    if (shr != 2147483648) return 90;
    shr = 2147483648U;
    shr >>= 1U;
    if (shr != 1073741824) return 91;
    shr = 2147483648U;
    shr >>= 31U;
    if (shr != 1) return 92;
    shr = 0xFFFF0000U;
    shr >>= 16U;
    if (shr != 0x0000FFFF) return 93;
    shr = 4294967295U;
    shr >>= 16U;
    if (shr != 65535) return 94;
    return 0;
}
