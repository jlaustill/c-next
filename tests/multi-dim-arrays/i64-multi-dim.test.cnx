/* test-execution */
// Tests: multi-dimensional i64 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: timestamps, large counters, high-precision measurements

i64 matrix2d[4][8];
i64 cube3d[2][3][4];

u32 main() {
    // 2D array: Write operations with large positive and negative values
    matrix2d[0][0] <- -9000000000000000000;
    matrix2d[0][7] <- 9000000000000000000;
    matrix2d[1][3] <- -5000000000000;
    matrix2d[3][7] <- 5000000000000;

    // 2D array: Read and verify
    if (matrix2d[0][0] != -9000000000000000000) return 1;
    if (matrix2d[0][7] != 9000000000000000000) return 2;
    if (matrix2d[1][3] != -5000000000000) return 3;
    if (matrix2d[3][7] != 5000000000000) return 4;

    // 3D array: Write operations
    cube3d[0][0][0] <- -1000000000000;
    cube3d[0][0][3] <- -100000000000;
    cube3d[0][2][3] <- 0;
    cube3d[1][0][0] <- 100000000000;
    cube3d[1][2][3] <- 8888888888888;

    // 3D array: Read and verify
    if (cube3d[0][0][0] != -1000000000000) return 5;
    if (cube3d[0][0][3] != -100000000000) return 6;
    if (cube3d[0][2][3] != 0) return 7;
    if (cube3d[1][0][0] != 100000000000) return 8;
    if (cube3d[1][2][3] != 8888888888888) return 9;

    // Test .length property at each dimension
    // 2D array dimensions
    if (matrix2d.length != 4) return 10;        // First dimension
    if (matrix2d[0].length != 8) return 11;     // Second dimension
    if (matrix2d[0][0].length != 64) return 12; // Element bit width

    // 3D array dimensions
    if (cube3d.length != 2) return 13;          // First dimension
    if (cube3d[0].length != 3) return 14;       // Second dimension
    if (cube3d[0][0].length != 4) return 15;    // Third dimension
    if (cube3d[0][0][0].length != 64) return 16; // Element bit width

    // Nested loop iteration - populate 2D array
    for (u32 i <- 0; i < 4; i +<- 1) {
        for (u32 j <- 0; j < 8; j +<- 1) {
            matrix2d[i][j] <- i * 100 + j;
        }
    }

    // Verify populated values
    if (matrix2d[0][0] != 0) return 17;
    if (matrix2d[0][7] != 7) return 18;
    if (matrix2d[1][3] != 103) return 19;
    if (matrix2d[3][7] != 307) return 20;

    // Nested loop iteration - populate and sum 3D array
    i64 sum <- 0;
    for (u32 i <- 0; i < 2; i +<- 1) {
        for (u32 j <- 0; j < 3; j +<- 1) {
            for (u32 k <- 0; k < 4; k +<- 1) {
                cube3d[i][j][k] <- i * 100 + j * 10 + k;
                sum +<- cube3d[i][j][k];
            }
        }
    }

    // Verify sum: 6+46+86+406+446+486 = 1476
    if (sum != 1476) return 21;

    // Test modification after initialization
    matrix2d[2][4] <- -9000000000000000000;
    if (matrix2d[2][4] != -9000000000000000000) return 22;

    // Test boundary access
    matrix2d[matrix2d.length - 1][matrix2d[0].length - 1] <- -555;
    if (matrix2d[3][7] != -555) return 23;

    // Test i64 specific edge cases with very large values
    i64 testArray[4][2];
    // Initialize all elements first
    for (u32 ti <- 0; ti < 4; ti +<- 1) {
        for (u32 tj <- 0; tj < 2; tj +<- 1) {
            testArray[ti][tj] <- 0;
        }
    }
    testArray[0][0] <- -9000000000000000000;  // Large negative
    testArray[0][1] <- 9000000000000000000;   // Large positive
    testArray[1][0] <- 0;                     // Zero
    testArray[1][1] <- -1;                    // Negative
    testArray[2][0] <- 1;                     // Positive
    testArray[3][1] <- -1000000000000;        // Medium negative

    if (testArray[0][0] != -9000000000000000000) return 24;
    if (testArray[0][1] != 9000000000000000000) return 25;
    if (testArray[1][0] != 0) return 26;
    if (testArray[1][1] != -1) return 27;
    if (testArray[2][0] != 1) return 28;
    if (testArray[3][1] != -1000000000000) return 29;

    // Test 2D array with timestamp pattern (milliseconds since epoch)
    i64 timestamps[3][3];
    // Initialize all elements first
    for (u32 tsi <- 0; tsi < 3; tsi +<- 1) {
        for (u32 tsj <- 0; tsj < 3; tsj +<- 1) {
            timestamps[tsi][tsj] <- 0;
        }
    }
    timestamps[0][0] <- -2208988800000;    // Jan 1, 1900
    timestamps[0][1] <- 0;                 // Jan 1, 1970 (epoch)
    timestamps[0][2] <- 1609459200000;     // Jan 1, 2021
    timestamps[1][0] <- 1640995200000;     // Jan 1, 2022
    timestamps[1][1] <- 1672531200000;     // Jan 1, 2023
    timestamps[1][2] <- 2524608000000;     // Jan 1, 2050

    if (timestamps[0][0] != -2208988800000) return 30;
    if (timestamps[0][1] != 0) return 31;
    if (timestamps[0][2] != 1609459200000) return 32;
    if (timestamps[1][0] != 1640995200000) return 33;
    if (timestamps[1][1] != 1672531200000) return 34;
    if (timestamps[1][2] != 2524608000000) return 35;

    // Test time difference calculations
    i64 diff <- timestamps[0][2] - timestamps[0][1];
    if (diff != 1609459200000) return 36;

    // Test negative differences
    i64 negDiff <- timestamps[0][0] - timestamps[0][1];
    if (negDiff != -2208988800000) return 37;

    // Test with nano-precision timestamps (nanoseconds)
    i64 nanos[2][2];
    // Initialize all elements first
    for (u32 ni <- 0; ni < 2; ni +<- 1) {
        for (u32 nj <- 0; nj < 2; nj +<- 1) {
            nanos[ni][nj] <- 0;
        }
    }
    nanos[0][0] <- 1609459200000000000;   // Jan 1, 2021 in nanoseconds
    nanos[0][1] <- 1609459200123456789;   // With nanosecond precision
    nanos[1][0] <- -1000000000;           // -1 second in nanoseconds
    nanos[1][1] <- 1000000000;            // +1 second in nanoseconds

    if (nanos[0][0] != 1609459200000000000) return 38;
    if (nanos[0][1] != 1609459200123456789) return 39;
    if (nanos[1][0] != -1000000000) return 40;
    if (nanos[1][1] != 1000000000) return 41;

    // Test large financial calculations (atomic units, e.g., satoshis)
    i64 balances[2][2];
    // Initialize all elements first
    for (u32 bi <- 0; bi < 2; bi +<- 1) {
        for (u32 bj <- 0; bj < 2; bj +<- 1) {
            balances[bi][bj] <- 0;
        }
    }
    balances[0][0] <- 2100000000000000;   // 21 million BTC in satoshis
    balances[0][1] <- -100000000;         // -1 BTC debt
    i64 netBalance <- balances[0][0] + balances[0][1];
    if (netBalance != 2099999900000000) return 42;

    return 0;
}
