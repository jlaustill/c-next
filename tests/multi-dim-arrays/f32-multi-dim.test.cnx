/* test-execution */
// Tests: multi-dimensional f32 arrays (2D and 3D)
// Validates array indexing, length properties, and nested iteration
// Typical use case: sensor readings, graphics coordinates, physics simulations

f32 matrix2d[4][8];
f32 cube3d[2][3][4];

u32 main() {
    // 2D array: Write operations with decimal values
    matrix2d[0][0] <- 3.14159;
    matrix2d[0][7] <- -2.71828;
    matrix2d[1][3] <- 100.5;
    matrix2d[3][7] <- 0.0;

    // 2D array: Read and verify
    if (matrix2d[0][0] != 3.14159) return 1;
    if (matrix2d[0][7] != -2.71828) return 2;
    if (matrix2d[1][3] != 100.5) return 3;
    if (matrix2d[3][7] != 0.0) return 4;

    // 3D array: Write operations
    cube3d[0][0][0] <- 1.5;
    cube3d[0][0][3] <- -10.25;
    cube3d[0][2][3] <- 0.0;
    cube3d[1][0][0] <- 99.9;
    cube3d[1][2][3] <- -0.001;

    // 3D array: Read and verify
    if (cube3d[0][0][0] != 1.5) return 5;
    if (cube3d[0][0][3] != -10.25) return 6;
    if (cube3d[0][2][3] != 0.0) return 7;
    if (cube3d[1][0][0] != 99.9) return 8;
    if (cube3d[1][2][3] != -0.001) return 9;

    // Test .length property at each dimension
    // 2D array dimensions
    if (matrix2d.length != 4) return 10;        // First dimension
    if (matrix2d[0].length != 8) return 11;     // Second dimension
    if (matrix2d[0][0].length != 32) return 12; // Element bit width

    // 3D array dimensions
    if (cube3d.length != 2) return 13;          // First dimension
    if (cube3d[0].length != 3) return 14;       // Second dimension
    if (cube3d[0][0].length != 4) return 15;    // Third dimension
    if (cube3d[0][0][0].length != 32) return 16; // Element bit width

    // Nested loop iteration - populate 2D array with decimal pattern
    for (u32 i <- 0; i < 4; i +<- 1) {
        for (u32 j <- 0; j < 8; j +<- 1) {
            matrix2d[i][j] <- i * 2.5 + j * 0.5;
        }
    }

    // Verify populated values
    if (matrix2d[0][0] != 0.0) return 17;
    if (matrix2d[0][7] != 3.5) return 18;
    if (matrix2d[1][3] != 4.0) return 19;
    if (matrix2d[3][7] != 11.0) return 20;

    // Nested loop iteration - populate and sum 3D array
    f32 sum <- 0.0;
    for (u32 i <- 0; i < 2; i +<- 1) {
        for (u32 j <- 0; j < 3; j +<- 1) {
            for (u32 k <- 0; k < 4; k +<- 1) {
                cube3d[i][j][k] <- i * 10.5 + j * 2.25 + k * 0.5;
                sum +<- cube3d[i][j][k];
            }
        }
    }

    // Verify sum: 3.0+12.0+21.0+45.0+54.0+63.0 = 198.0
    if (sum != 198.0) return 21;

    // Test modification after initialization
    matrix2d[2][4] <- -999.999;
    if (matrix2d[2][4] != -999.999) return 22;

    // Test boundary access
    matrix2d[matrix2d.length - 1][matrix2d[0].length - 1] <- 42.42;
    if (matrix2d[3][7] != 42.42) return 23;

    // Test f32 specific edge cases
    f32 testArray[4][2];
    testArray[0][0] <- 0.0;       // Zero
    testArray[0][1] <- -0.0;      // Negative zero
    testArray[1][0] <- 1.0;       // One
    testArray[1][1] <- -1.0;      // Negative one
    testArray[2][0] <- 0.1;       // Small positive
    testArray[3][1] <- -0.1;      // Small negative

    if (testArray[0][0] != 0.0) return 24;
    if (testArray[0][1] != -0.0) return 25;
    if (testArray[1][0] != 1.0) return 26;
    if (testArray[1][1] != -1.0) return 27;
    if (testArray[2][0] != 0.1) return 28;
    if (testArray[3][1] != -0.1) return 29;

    // Test 2D array with temperature pattern (Celsius)
    f32 temps[3][3];
    temps[0][0] <- -273.15;  // Absolute zero
    temps[0][1] <- 0.0;      // Freezing point
    temps[0][2] <- 100.0;    // Boiling point
    temps[1][0] <- 37.0;     // Body temperature
    temps[1][1] <- 20.5;     // Room temperature
    temps[2][0] <- -40.0;    // Very cold
    temps[2][1] <- 1000.0;   // Very hot

    if (temps[0][0] != -273.15) return 30;
    if (temps[0][1] != 0.0) return 31;
    if (temps[0][2] != 100.0) return 32;
    if (temps[1][0] != 37.0) return 33;
    if (temps[2][0] != -40.0) return 34;

    // Test decimal precision
    f32 precise[2][2];
    precise[0][0] <- 0.123456;
    precise[0][1] <- 0.00001;
    precise[1][0] <- 999.999;
    precise[1][1] <- -123.456;

    if (precise[0][0] != 0.123456) return 35;
    if (precise[0][1] != 0.00001) return 36;
    if (precise[1][0] != 999.999) return 37;
    if (precise[1][1] != -123.456) return 38;

    // Test floating point arithmetic
    f32 calc[2][2];
    calc[0][0] <- 10.5;
    calc[0][1] <- 5.25;
    f32 calcSum <- calc[0][0] + calc[0][1];
    if (calcSum != 15.75) return 39;

    // Test with graphics coordinates (normalized 0.0-1.0)
    f32 coords[2][4];
    coords[0][0] <- 0.0;
    coords[0][1] <- 0.25;
    coords[0][2] <- 0.5;
    coords[0][3] <- 0.75;
    coords[1][0] <- 1.0;
    coords[1][1] <- 0.333;
    coords[1][2] <- 0.666;
    coords[1][3] <- 0.999;

    if (coords[0][0] != 0.0) return 40;
    if (coords[0][3] != 0.75) return 41;
    if (coords[1][0] != 1.0) return 42;

    return 0;
}
